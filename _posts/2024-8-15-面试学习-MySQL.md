---
layout: article
title: MySQL
---

<!-- TOC -->

- [MySQL](#mysql)
  - [1.MySQL 的内连接、左连接、右连接有什么区别？](#1mysql-的内连接左连接右连接有什么区别)
  - [2.什么是三大范式，为什么要有三大范式，什么场景下不用遵循三大范式，举一个场景?](#2什么是三大范式为什么要有三大范式什么场景下不用遵循三大范式举一个场景)
    - [什么是三大范式？](#什么是三大范式)
    - [第一范式（1NF）](#第一范式1nf)
    - [第二范式（2NF）](#第二范式2nf)
    - [第三范式（3NF）](#第三范式3nf)
    - [为什么要有三大范式？](#为什么要有三大范式)
    - [什么场景下不用遵循三大范式？](#什么场景下不用遵循三大范式)
    - [举一个场景](#举一个场景)
    - [总结](#总结)
  - [3.varchar 与 char 的区别？](#3varchar-与-char-的区别)
  - [4.blob 和 text 有什么区别？](#4blob-和-text-有什么区别)
  - [5.DATETIME 和 TIMESTAMP 的异同？](#5datetime-和-timestamp-的异同)
  - [6.MySQL 中 in 和 exists 的区别？](#6mysql-中-in-和-exists-的区别)
  - [7.MySQL 里记录货币用什么字段类型比较好？](#7mysql-里记录货币用什么字段类型比较好)
  - [8.MySQL 怎么存储 emoji?](#8mysql-怎么存储-emoji)
  - [9.drop、delete 与 truncate 的区别？](#9dropdelete-与-truncate-的区别)
  - [10.UNION 与 UNION ALL 的区别？](#10union-与-union-all-的区别)
  - [11.count(1)、count(\*) 与 count(列名) 的区别？](#11count1count-与-count列名-的区别)
  - [12.一条 SQL 查询语句的执行顺序？](#12一条-sql-查询语句的执行顺序)
  - [13.介绍一下 MySQL 的常用命令](#13介绍一下-mysql-的常用命令)
    - [数据库操作命令](#数据库操作命令)
    - [表操作命令](#表操作命令)
    - [数据操作命令](#数据操作命令)
    - [用户和权限管理命令](#用户和权限管理命令)
    - [备份和恢复命令](#备份和恢复命令)
    - [查看和管理命令](#查看和管理命令)
    - [事务管理命令](#事务管理命令)
    - [总结](#总结-1)
  - [14.介绍一下 MySQL bin 目录下的可执行文件](#14介绍一下-mysql-bin-目录下的可执行文件)
  - [15.MySQL 第 3-10 条记录怎么查？](#15mysql-第-3-10-条记录怎么查)
  - [16.用过哪些 MySQL 函数？](#16用过哪些-mysql-函数)
    - [字符串函数](#字符串函数)
    - [数值函数](#数值函数)
    - [日期和时间函数](#日期和时间函数)
    - [聚合函数](#聚合函数)
    - [条件函数](#条件函数)
    - [JSON 函数](#json-函数)
    - [类型转换函数](#类型转换函数)
  - [17.说说 SQL 的隐式数据类型转换？](#17说说-sql-的隐式数据类型转换)
  - [18.说说 MySQL 的基础架构?](#18说说-mysql-的基础架构)
  - [19.一条 SQL 查询语句在 MySQL 中如何执行的？](#19一条-sql-查询语句在-mysql-中如何执行的)
    - [1. 客户端发送查询请求](#1-客户端发送查询请求)
    - [2. 连接处理](#2-连接处理)
    - [3. 查询缓存](#3-查询缓存)
    - [4. 解析器](#4-解析器)
    - [5. 预处理器](#5-预处理器)
    - [6. 查询优化器](#6-查询优化器)
    - [7. 执行器](#7-执行器)
    - [8. 存储引擎](#8-存储引擎)
    - [9. 返回结果](#9-返回结果)
    - [执行过程解析](#执行过程解析)
  - [20.说说 MySQL 的数据存储形式](#20说说-mysql-的数据存储形式)
  - [21.MySQL 有哪些常见存储引擎？](#21mysql-有哪些常见存储引擎)
  - [22.存储引擎应该怎么选择？](#22存储引擎应该怎么选择)
  - [23.InnoDB 和 MyISAM 主要有什么区别？](#23innodb-和-myisam-主要有什么区别)
  - [24.MySQL 日志文件有哪些？分别介绍下作用？](#24mysql-日志文件有哪些分别介绍下作用)
    - [请重点说说 binlog？](#请重点说说-binlog)
  - [25.binlog 和 redo log 有什么区别？](#25binlog-和-redo-log-有什么区别)
  - [26.一条更新语句怎么执行的了解吗？](#26一条更新语句怎么执行的了解吗)
    - [为什么要两阶段提交呢？](#为什么要两阶段提交呢)
  - [27.redo log 怎么刷入磁盘的知道吗？](#27redo-log-怎么刷入磁盘的知道吗)
  - [28.慢 SQL 如何定位呢？](#28慢-sql-如何定位呢)
    - [什么是慢 SQL？](#什么是慢-sql)
    - [那怎么定位慢 SQL 呢？](#那怎么定位慢-sql-呢)
    - [慢sql日志怎么开启？](#慢sql日志怎么开启)
  - [29.有哪些方式优化 SQL？](#29有哪些方式优化-sql)
    - [如何避免不必要的列？](#如何避免不必要的列)
    - [如何进行分页优化？](#如何进行分页优化)
    - [如何进行索引优化？](#如何进行索引优化)
    - [如何进行 JOIN 优化？](#如何进行-join-优化)
    - [如何进行排序优化？](#如何进行排序优化)
    - [如何进行 UNION 优化？](#如何进行-union-优化)
  - [30.怎么看执行计划 explain，如何理解其中各个字段的含义？](#30怎么看执行计划-explain如何理解其中各个字段的含义)
  - [31.为什么使用索引会加快查询？](#31为什么使用索引会加快查询)
  - [32.能简单说一下索引的分类吗？](#32能简单说一下索引的分类吗)
    - [功能上的分类](#功能上的分类)
    - [数据结构上分类](#数据结构上分类)
  - [从存储位置上分类](#从存储位置上分类)
  - [33.创建索引有哪些注意点？](#33创建索引有哪些注意点)
  - [34.索引哪些情况下会失效呢？](#34索引哪些情况下会失效呢)
  - [35.索引不适合哪些场景呢？](#35索引不适合哪些场景呢)
    - [性别字段要建立索引吗？](#性别字段要建立索引吗)
    - [什么是区分度？](#什么是区分度)
    - [MySQL查看字段区分度的命令？](#mysql查看字段区分度的命令)
    - [索引是不是建的越多越好呢？](#索引是不是建的越多越好呢)

<!-- /TOC -->

## MySQL

### 1.MySQL 的内连接、左连接、右连接有什么区别？

①、inner join 内连接，在两张表进行连接查询时，只保留两张表中完全匹配的结果集。

只有当两个表中都有匹配的记录时，这些记录才会出现在查询结果中。如果某一方没有匹配的记录，则该记录不会出现在结果集中。

内联可以用来找出两个表中共同的记录，相当于两个数据集的交集。

②、left join 返回左表（FROM 子句中指定的表）的所有记录，以及右表中匹配记录的记录。如果右表中没有匹配的记录，则结果中右表的部分会以 NULL 填充。

③、right join 刚好与左联相反，返回右表（FROM 子句中指定的表）的所有记录，以及左表中匹配记录的记录。如果左表中没有匹配的记录，则结果中左表的部分会以 NULL 填充。

### 2.什么是三大范式，为什么要有三大范式，什么场景下不用遵循三大范式，举一个场景?

#### 什么是三大范式？

数据库设计中的三大范式是指关系数据库的设计原则，用于减少数据冗余和提高数据一致性。三大范式分别是第一范式（1NF）、第二范式（2NF）和第三范式（3NF）。

#### 第一范式（1NF）

第一范式要求数据库表中的每一列都是原子性的，即每一列的数据都是不可再分的基本数据项。

**示例**：

| 学生ID | 姓名   | 电话号码         |
|--------|--------|------------------|
| 1      | 张三   | 1234567890       |
| 2      | 李四   | 0987654321       |

#### 第二范式（2NF）

第二范式在满足第一范式的基础上，要求表中的每个非主键列都完全依赖于主键，而不能依赖于主键的一部分（消除部分依赖）。

**示例**：

将学生信息和课程信息分开存储：

学生表：

| 学生ID | 姓名   |
|--------|--------|
| 1      | 张三   |
| 2      | 李四   |

课程表：

| 课程ID | 课程名 |
|--------|--------|
| 101    | 数学   |
| 102    | 英语   |

选课表：

| 学生ID | 课程ID |
|--------|--------|
| 1      | 101    |
| 2      | 102    |

#### 第三范式（3NF）

第三范式在满足第二范式的基础上，要求表中的每个非主键列都直接依赖于主键，而不能依赖于其他非主键列（消除传递依赖）。

**示例**：

将学生信息和班级信息分开存储：

学生表：

| 学生ID | 姓名   | 班级ID |
|--------|--------|--------|
| 1      | 张三   | 1      |
| 2      | 李四   | 2      |

班级表：

| 班级ID | 班级名 |
|--------|--------|
| 1      | 一班   |
| 2      | 二班   |

#### 为什么要有三大范式？

三大范式的主要目的是减少数据冗余、提高数据一致性和完整性。通过遵循三大范式，可以避免数据的重复存储和更新异常，从而提高数据库的设计质量和维护效率。

#### 什么场景下不用遵循三大范式？

在某些特定场景下，为了提高查询性能或简化数据操作，可以适当放宽对三大范式的遵循。这种情况通常发生在数据量较大且查询频繁的场景中。

#### 举一个场景

假设有一个电商系统，需要频繁查询订单及其对应的用户信息。为了提高查询性能，可以将订单信息和用户信息存储在同一个表中，而不是严格遵循第三范式将其分开存储。

**示例**：

订单表：

| 订单ID | 用户ID | 用户名 | 用户地址       | 商品ID | 商品名 | 订单金额 |
|--------|--------|--------|----------------|--------|--------|----------|
| 1      | 101    | 张三   | 北京市朝阳区   | 1001   | 手机   | 3000     |
| 2      | 102    | 李四   | 上海市浦东新区 | 1002   | 电脑   | 5000     |

在这个例子中，用户信息（用户名、用户地址）被重复存储在每个订单记录中，违反了第三范式的要求，但这样可以减少查询时的表连接操作，提高查询性能。

#### 总结

三大范式是数据库设计的重要原则，*用于减少数据冗余和提高数据一致性*。然而，在某些特定场景下，为了提高查询性能或简化数据操作，可以适当放宽对三大范式的遵循。

### 3.varchar 与 char 的区别？

![varchar](https://raw.githubusercontent.com/BugLeesir/image_host01/main/blogs_img/mysql-40f42d59-a295-4543-8a03-43925da4d6d9.jpg)

**char**：

- char 表示定长字符串，长度是固定的；
- 如果插入数据的长度小于 char 的固定长度时，则用空格填充；
- 因为长度固定，所以存取速度要比 varchar 快很多，甚至能快 50%，但正因为其长度固定，所以会占据多余的空间，是空间换时间的做法；
- 对于 char 来说，最多能存放的字符个数为 255，和编码无关

**varchar**：

- varchar 表示可变长字符串，长度是可变的；
- 插入的数据是多长，就按照多长来存储；
- varchar 在存取方面与 char 相反，它存取慢，因为长度不固定，但正因如此，不占据多余的空间，是时间换空间的做法；
- 对于 varchar 来说，最多能存放的字符个数为 65532

日常的设计，对于长度相对固定的字符串，可以使用 char，对于长度不确定的，使用 varchar 更合适一些。

### 4.blob 和 text 有什么区别？

- blob 用于存储二进制数据，而 text 用于存储大字符串。
- blob 没有字符集，text 有一个字符集，并且根据字符集的校对规则对值进行排序和比较

### 5.DATETIME 和 TIMESTAMP 的异同？

**相同点**：

1. 两个数据类型存储时间的表现格式一致。均为 `YYYY-MM-DD HH:MM:SS`
2. 两个数据类型都包含「日期」和「时间」部分。
3. 两个数据类型都可以存储微秒的小数秒（秒后 6 位小数秒）

**区别**：

DATETIME 和 TIMESTAMP 的区别

1. **日期范围**：DATETIME 的日期范围是 `1000-01-01 00:00:00.000000` 到 `9999-12-31 23:59:59.999999`；TIMESTAMP 的时间范围是`1970-01-01 00:00:01.000000` UTC `到 ``2038-01-09 03:14:07.999999` UTC
2. **存储空间**：DATETIME 的存储空间为 8 字节；TIMESTAMP 的存储空间为 4 字节
3. **时区相关**：DATETIME 存储时间与时区无关；TIMESTAMP 存储时间与时区有关，显示的值也依赖于时区
4. **默认值**：DATETIME 的默认值为 null；TIMESTAMP 的字段默认不为空(not null)，默认值为当前时间(CURRENT\_TIMESTAMP)

### 6.MySQL 中 in 和 exists 的区别？

MySQL 中的 in 语句是把外表和内表作 hash 连接，而 exists 语句是对外表作 loop 循环，每次 loop 循环再对内表进行查询。我们可能认为 exists 比 in 语句的效率要高，这种说法其实是不准确的，要区分情景：

1. 如果查询的两个表大小相当，那么用 in 和 exists 差别不大。
2. 如果两个表中一个较小，一个是大表，则子查询表大的用 exists，子查询表小的用 in。
3. not in 和 not exists：如果查询语句使用了 not in，那么内外表都进行全表扫描，没有用到索引；而 not extsts 的子查询依然能用到表上的索引。所以无论那个表大，用 not exists 都比 not in 要快。

### 7.MySQL 里记录货币用什么字段类型比较好？

货币在数据库中 MySQL 常用 Decimal 和 Numeric 类型表示，这两种类型被 MySQL 实现为同样的类型。他们被用于保存与货币有关的数据。

例如 salary DECIMAL(9,2)，9(precision)代表将被用于存储值的总的小数位数，而 2(scale)代表将被用于存储小数点后的位数。存储在 salary 列中的值的范围是从-9999999.99 到 9999999.99。

DECIMAL 和 NUMERIC 值作为字符串存储，而不是作为二进制浮点数，以便保存那些值的小数精度。

之所以不使用 float 或者 double 的原因：因为 float 和 double 是以二进制存储的，所以有一定的误差。

### 8.MySQL 怎么存储 emoji?

MySQL 的 utf8 字符集仅支持最多 3 个字节的 UTF-8 字符，但是 emoji 表情（😊）是 4 个字节的 UTF-8 字符，所以在 MySQL 中存储 emoji 表情时，需要使用 utf8mb4 字符集。

```sql
ALTER TABLE mytable CONVERT TO CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;
```

MySQL 8.0 已经默认支持 utf8mb4 字符集，可以通过 `SHOW VARIABLES WHERE Variable_name LIKE 'character\_set\_%' OR Variable_name LIKE 'collation%';` 查看。

### 9.drop、delete 与 truncate 的区别？

三者都表示删除，但是三者有一些差别：

| 区别 | delete | truncate | drop |
| --- | --- | --- | --- |
| 类型 | 属于 DML | 属于 DDL | 属于 DDL |
| 回滚 | 可回滚 | 不可回滚 | 不可回滚 |
| 删除内容 | 表结构还在，删除表的全部或者一部分数据行 | 表结构还在，删除表中的所有数据 | 从数据库中删除表，所有数据行，索引和权限也会被删除 |
| 删除速度 | 删除速度慢，需要逐行删除 | 删除速度快 | 删除速度最快 |

因此，在不再需要一张表的时候，用 drop；在想删除部分数据行时候，用 delete；在保留表而删除所有数据的时候用 truncate。

### 10.UNION 与 UNION ALL 的区别？

- 如果使用 UNION，会在表链接后筛选掉重复的记录行
- 如果使用 UNION ALL，不会合并重复的记录行
- 从效率上说，UNION ALL 要比 UNION 快很多，如果合并没有刻意要删除重复行，那么就使用 UNION All

### 11.count(1)、count(*) 与 count(列名) 的区别？

**执行效果**：

- count(\*)包括了所有的列，相当于行数，在统计结果的时候，不会忽略列值为 NULL
- count(1)包括了忽略所有列，用 1 代表代码行，在统计结果的时候，不会忽略列值为 NULL
- count(列名)只包括列名那一列，在统计结果的时候，*会忽略列值为空（这里的空不是指空字符串或者 0，而是表示 null）的计数，即某个字段值为 NULL 时，不统计。*

**执行速度**：

- 列名为主键，count(列名)会比 count(1)快
- 列名不为主键，count(1)会比 count(列名)快
- 如果表多个列并且没有主键，则 count（1） 的执行效率优于 count（\*）
- 如果有主键，则 select count（主键）的执行效率是最优的
- 如果表只有一个字段，则 select count（\*）最优。

### 12.一条 SQL 查询语句的执行顺序？

![查询语句执行顺序](https://raw.githubusercontent.com/BugLeesir/image_host01/main/blogs_img/mysql-47ddea92-cf8f-49c4-ab2e-69a829ff1be2.jpg)

- **FROM**：对 FROM 子句中的左表<left\_table>和右表<right\_table>执行笛卡儿积（Cartesianproduct），产生虚拟表 VT1
- **ON**：对虚拟表 VT1 应用 ON 筛选，只有那些符合<join\_condition>的行才被插入虚拟表 VT2 中
- **JOIN**：如果指定了 OUTER JOIN（如 LEFT OUTER JOIN、RIGHT OUTER JOIN），那么保留表中未匹配的行作为外部行添加到虚拟表 VT2 中，产生虚拟表 VT3。如果 FROM 子句包含两个以上表，则对上一个连接生成的结果表 VT3 和下一个表重复执行步骤 1）～步骤 3），直到处理完所有的表为止
- **WHERE**：对虚拟表 VT3 应用 WHERE 过滤条件，只有符合<where\_condition>的记录才被插入虚拟表 VT4 中
- **GROUP BY**：根据 GROUP BY 子句中的列，对 VT4 中的记录进行分组操作，产生 VT5
- **CUBE|ROLLUP**：对表 VT5 进行 CUBE 或 ROLLUP 操作，产生表 VT6
- **HAVING**：对虚拟表 VT6 应用 HAVING 过滤器，只有符合<having\_condition>的记录才被插入虚拟表 VT7 中。
- **SELECT**：第二次执行 SELECT 操作，选择指定的列，插入到虚拟表 VT8 中
- **DISTINCT**：去除重复数据，产生虚拟表 VT9
- **ORDER BY**：将虚拟表 VT9 中的记录按照<order\_by\_list>进行排序操作，产生虚拟表 VT10。11）
- **LIMIT**：取出指定行的记录，产生虚拟表 VT11，并返回给查询用户

### 13.介绍一下 MySQL 的常用命令

MySQL 是一个广泛使用的关系数据库管理系统，提供了许多命令来管理数据库和数据。以下是一些常用的 MySQL 命令：

#### 数据库操作命令

**创建数据库**  

```sql
CREATE DATABASE database_name;
```

**删除数据库**  

```sql
DROP DATABASE database_name;
```

**选择数据库**  

```sql
USE database_name;
```

#### 表操作命令

**创建表**  

```sql
CREATE TABLE table_name (
    column1 datatype,
    column2 datatype,
    ...
);
```

**删除表**  

```sql
DROP TABLE table_name;
```

**修改表**  

- 添加列

```sql
ALTER TABLE table_name ADD column_name datatype;
```

- 删除列

```sql
ALTER TABLE table_name DROP COLUMN column_name;
```

- 修改列

```sql
ALTER TABLE table_name MODIFY COLUMN column_name datatype;
```

#### 数据操作命令

**插入数据**  

```sql
INSERT INTO table_name (column1, column2, ...) VALUES (value1, value2, ...);
```

**更新数据**  

```sql
UPDATE table_name SET column1 = value1, column2 = value2, ... WHERE condition;
```

**删除数据**  

```sql
DELETE FROM table_name WHERE condition;
```

**查询数据**  

```sql
SELECT column1, column2, ... FROM table_name WHERE condition;
```

#### 用户和权限管理命令

**创建用户**  

```sql
CREATE USER 'username'@'host' IDENTIFIED BY 'password';
```

**删除用户**  

```sql
DROP USER 'username'@'host';
```

**授予权限**  

```sql
GRANT ALL PRIVILEGES ON database_name.* TO 'username'@'host';
```

**撤销权限**  

```sql
REVOKE ALL PRIVILEGES ON database_name.* FROM 'username'@'host';
```

**刷新权限**  

```sh
FLUSH PRIVILEGES;
```

#### 备份和恢复命令

**备份数据库**  

```sh
mysqldump -u username -p database_name > backup_file.sql
```

**恢复数据库**  

```sh
mysql -u username -p database_name < backup_file.sql
```

#### 查看和管理命令

**查看数据库**  

```sql
SHOW DATABASES;
```

**查看表**  

```sql
SHOW TABLES;
```

**查看表结构**  

```sql
DESCRIBE table_name;
```

**查看当前用户**  

```sql
SELECT USER();
```

**查看当前数据库**  

```sql
SELECT DATABASE();
```

#### 事务管理命令

**开始事务**  

```sql
START TRANSACTION;
```

**提交事务**  

```sql
COMMIT;
```

**回滚事务**  

```sql
ROLLBACK;
```

#### 总结

这些是 MySQL 中一些常用的命令，涵盖了数据库和表的创建、修改、删除，数据的插入、更新、删除，用户和权限管理，以及备份和恢复等操作。通过熟练掌握这些命令，可以有效地管理和操作 MySQL 数据库。

### 14.介绍一下 MySQL bin 目录下的可执行文件

- mysql：客户端程序，用于连接 MySQL 服务器
- mysqldump：一个非常实用的 MySQL 数据库备份工具，用于创建一个或多个 MySQL 数据库级别的 SQL 转储文件，包括数据库的表结构和数据。对数据备份、迁移或恢复非常重要。
- mysqladmin：mysql 后面加上 admin 就表明这是一个 MySQL 的管理工具，它可以用来执行一些管理操作，比如说创建数据库、删除数据库、查看 MySQL 服务器的状态等。
- mysqlcheck：mysqlcheck 是 MySQL 提供的一个命令行工具，用于检查、修复、分析和优化数据库表，对数据库的维护和性能优化非常有用。
- mysqlimport：用于从文本文件中导入数据到数据库表中，非常适合用于批量导入数据。
- mysqlshow：用于显示 MySQL 数据库服务器中的数据库、表、列等信息。
- mysqlbinlog：用于查看 MySQL 二进制日志文件的内容，可以用于恢复数据、查看数据变更等。

### 15.MySQL 第 3-10 条记录怎么查？

在 MySQL 中，要查询第 3 到第 10 条记录，可以使用 limit 语句，结合偏移量 offset 和行数 row_count 来实现。

limit 语句用于限制查询结果的数量，偏移量表示从哪条记录开始，行数表示返回的记录数量。

```sql
SELECT * FROM table_name LIMIT 2, 8;
```

- 2：偏移量，表示跳过前两条记录，从第三条记录开始。
- 8：行数，表示从偏移量开始，返回 8 条记录。

*偏移量是从 0 开始的，即第一条记录的偏移量是 0*；如果想从第 3 条记录开始，偏移量就应该是 2。

### 16.用过哪些 MySQL 函数？

在 MySQL 中，有许多内置函数可以用于各种数据操作和查询。以下是一些常用的 MySQL 函数：

#### 字符串函数

**`CONCAT`**：连接两个或多个字符串。

```sql
SELECT CONCAT('Hello', ' ', 'World');
```

**`SUBSTRING`**：从字符串中提取子字符串。

```sql
SELECT SUBSTRING('Hello World', 1, 5);
```

**`LENGTH`**：返回字符串的长度。

```sql
SELECT LENGTH('Hello World');
```

**`UPPER`**：将字符串转换为大写。

```sql
SELECT UPPER('hello world');
```

**`LOWER`**：将字符串转换为小写。

```sql
SELECT LOWER('HELLO WORLD');
```

#### 数值函数

**`ABS`**：返回数值的绝对值。

```sql
SELECT ABS(-10);
```

**`ROUND`**：对数值进行四舍五入。

```sql
SELECT ROUND(123.456, 2);
```

**`CEIL`**：返回大于或等于指定数值的最小整数。

```sql
SELECT CEIL(123.456);
```

**`FLOOR`**：返回小于或等于指定数值的最大整数。

```sql
SELECT FLOOR(123.456);
```

**`MOD`**：返回两个数值相除的余数。

```sql
SELECT MOD(10, 3);
```

#### 日期和时间函数

**`NOW`**：返回当前日期和时间。

```sql
SELECT NOW();
```

**`CURDATE`**：返回当前日期。

```sql
SELECT CURDATE();
```

**`CURTIME`**：返回当前时间。

```sql
SELECT CURTIME();
```

**`DATE_ADD`**：向日期添加指定的时间间隔。

```sql
SELECT DATE_ADD('2023-01-01', INTERVAL 1 DAY);
```

**`DATEDIFF`**：返回两个日期之间的天数差。

```sql
SELECT DATEDIFF('2023-01-10', '2023-01-01');
```

#### 聚合函数

**`COUNT`**：返回结果集中的行数。

```sql
SELECT COUNT(*) FROM employees;
```

**`SUM`**：返回数值列的总和。

```sql
SELECT SUM(salary) FROM employees;
```

**`AVG`**：返回数值列的平均值。

```sql
SELECT AVG(salary) FROM employees;
```

**`MAX`**：返回数值列的最大值。

```sql
SELECT MAX(salary) FROM employees;
```

**`MIN`**：返回数值列的最小值。

```sql
SELECT MIN(salary) FROM employees;
```

#### 条件函数

**`IF`**：返回条件为真的值，否则返回条件为假的值。

```sql
SELECT IF(salary > 5000, 'High', 'Low') FROM employees;
```

**`CASE`**：类似于 `IF`，但可以处理多个条件。

```sql
SELECT 
    CASE 
        WHEN salary > 5000 THEN 'High'
        WHEN salary > 3000 THEN 'Medium'
        ELSE 'Low'
    END AS salary_level
FROM employees;
```

#### JSON 函数

**`JSON_EXTRACT`**：从 JSON 文档中提取数据。

```sql
SELECT JSON_EXTRACT('{"name": "John", "age": 30}', '$.name');
```

**`JSON_ARRAY`**：创建 JSON 数组。

```sql
SELECT JSON_ARRAY('apple', 'banana', 'cherry');
```

**`JSON_OBJECT`**：创建 JSON 对象。

```sql
SELECT JSON_OBJECT('name', 'John', 'age', 30);
```

#### 类型转换函数

**`CAST`**: 将一个值转换为指定的数据类型。

```sql
SELECT CAST('2024-01-01' AS DATE) AS casted_date;
```

**`CANVERT`**: 类似于CAST()，用于类型转换。

```sql
SELECT CONVERT('123', SIGNED INTEGER) AS converted_number;
```

### 17.说说 SQL 的隐式数据类型转换？

在 SQL 中，当不同数据类型的值进行运算或比较时，会发生隐式数据类型转换。

比如说，当一个整数和一个浮点数相加时，整数会被转换为浮点数，然后再进行相加。

```sql
SELECT 1 + 1.0; -- 结果为 2.0
```

比如说，当一个字符串和一个整数相加时，字符串会被转换为整数，然后再进行相加。

```sql
SELECT '1' + 1; -- 结果为 2
```

数据类型隐式转换会导致意想不到的结果，所以要尽量避免隐式转换。

可以通过显式转换来规避这种情况。

```sql
SELECT CAST('1' AS SIGNED INTEGER) + 1; -- 结果为 2
```

### 18.说说 MySQL 的基础架构?

![MySQL 逻辑架构图](https://raw.githubusercontent.com/BugLeesir/image_host01/main/blogs_img/mysql-77626fdb-d2b0-4256-a483-d1c60e68d8ec.jpg)

MySQL 逻辑架构图主要分三层：

- 客户端：最上层的服务并不是 MySQL 所独有的，大多数基于网络的客户端/服务器的工具或者服务都有类似的架构。比如连接处理、授权认证、安全等等。
- Server 层：大多数 MySQL 的核心服务功能都在这一层，包括查询解析、分析、优化、缓存以及所有的内置函数（例如，日期、时间、数学和加密函数），所有跨存储引擎的功能都在这一层实现：存储过程、触发器、视图等。
- 存储引擎层：第三层包含了存储引擎。存储引擎负责 MySQL 中数据的存储和提取。Server 层通过 API 与存储引擎进行通信。这些接口屏蔽了不同存储引擎之间的差异，使得这些差异对上层的查询过程透明。

### 19.一条 SQL 查询语句在 MySQL 中如何执行的？

在 MySQL 中，一条 SQL 查询语句的执行过程可以分为多个步骤。以下是一个典型的 SQL 查询语句在 MySQL 中的执行过程：

#### 1. 客户端发送查询请求

客户端通过连接器（Connector）向 MySQL 服务器发送查询请求。

#### 2. 连接处理

MySQL 服务器接收到查询请求后，首先会进行连接处理，包括用户身份验证和权限检查。通过身份验证和权限检查后，服务器会为该连接分配一个线程。

#### 3. 查询缓存

MySQL 会检查查询缓存（Query Cache），如果查询缓存中存在相同的查询且缓存未失效，则直接返回缓存结果。否则，继续执行下一步。

#### 4. 解析器

解析器（Parser）会对 SQL 语句进行词法分析和语法分析，生成解析树（Parse Tree）。解析器会检查 SQL 语句的语法是否正确，并将其转换为内部数据结构。

#### 5. 预处理器

预处理器（Preprocessor）会进一步检查解析树，包括检查表和列是否存在，检查用户是否有权限访问这些表和列等。

#### 6. 查询优化器

查询优化器（Optimizer）会对解析树进行优化，生成执行计划（Execution Plan）。优化器会选择最优的执行路径，包括选择合适的索引、确定表的连接顺序等。

#### 7. 执行器

执行器（Executor）根据执行计划执行查询操作。执行器会调用存储引擎接口，逐步获取数据并进行处理。

#### 8. 存储引擎

存储引擎（Storage Engine）负责实际的数据存储和提取。MySQL 支持多种存储引擎，如 InnoDB、MyISAM 等。存储引擎通过 API 与 Server 层进行通信，执行器会根据执行计划向存储引擎发出请求，存储引擎返回数据。

#### 9. 返回结果

执行器将查询结果返回给客户端。

#### 执行过程解析

1. **客户端发送查询请求**：客户端向 MySQL 服务器发送查询请求。
2. **连接处理**：MySQL 服务器进行用户身份验证和权限检查，通过后分配一个线程处理该请求。
3. **查询缓存**：检查查询缓存，如果缓存中存在相同的查询且未失效，则直接返回缓存结果。
4. **解析器**：解析器对 SQL 语句进行词法分析和语法分析，生成解析树。
5. **预处理器**：预处理器检查解析树，验证表和列是否存在，检查用户权限。
6. **查询优化器**：查询优化器对解析树进行优化，生成执行计划，选择最优的执行路径。
7. **执行器**：执行器根据执行计划执行查询操作，调用存储引擎接口获取数据。
8. **存储引擎**：存储引擎执行实际的数据存储和提取操作，返回数据给执行器。
9. **返回结果**：执行器将查询结果返回给客户端。

### 20.说说 MySQL 的数据存储形式

![段、区、页、行](https://raw.githubusercontent.com/BugLeesir/image_host01/main/blogs_img/mysql-20240515110034.png)

①、段（Segment）：表空间由多个段组成，常见的段有数据段、索引段、回滚段等。

创建索引时会创建两个段，数据段和索引段，数据段用来存储叶子阶段中的数据；索引段用来存储非叶子节点的数据。

回滚段包含了事务执行过程中用于数据回滚的旧数据。

②、区（Extent）：段由一个或多个区组成，区是一组连续的页，通常包含 64 个连续的页，也就是 1M 的数据。

使用区而非单独的页进行数据分配可以优化磁盘操作，减少磁盘寻道时间，特别是在大量数据进行读写时。

③、页（Page）：页是 InnoDB 存储数据的基本单元，标准大小为 16 KB，索引树上的一个节点就是一个页。

也就意味着数据库每次读写都是以 16 KB 为单位的，一次最少从磁盘中读取 16KB 的数据到内存，一次最少写入 16KB 的数据到磁盘。

④、行（Row）：InnoDB 采用行存储方式，意味着数据按照行进行组织和管理，行数据可能有多个格式，比如说 COMPACT、REDUNDANT、DYNAMIC 等。

MySQL 8.0 默认的行格式是 DYNAMIC，由COMPACT 演变而来，意味着这些数据如果超过了页内联存储的限制，则会被存储在溢出页中。

可以通过 `show table status like '%article%'` 查看行格式。

![行格式](https://raw.githubusercontent.com/BugLeesir/image_host01/main/blogs_img/mysql-20240515123301.png)

### 21.MySQL 有哪些常见存储引擎？

MySQL 支持多种存储引擎，常见的有 MyISAM、InnoDB、MEMORY 等。MEMORY 并不常用。

![存储引擎](https://raw.githubusercontent.com/BugLeesir/image_host01/main/blogs_img/mysql-20240408073338.png)

| 功能 | InnoDB | MyISAM | MEMORY |
| --- | --- | --- | --- |
| 支持事务 | Yes | No | No |
| 支持全文索引 | Yes | Yes | No |
| 支持 B+树索引 | Yes | Yes | Yes |
| 支持哈希索引 | Yes | No | Yes |
| 支持外键 | Yes | No | No |

除此之外，我还了解到：

①、MySQL 5.5 之前，默认存储引擎是 MyISAM，5.5 之后是 InnoDB。

②、InnoDB 支持的哈希索引是自适应的，不能人为干预。

③、InnoDB 从 MySQL 5.6 开始，支持全文索引。

④、InnoDB 的最小表空间略小于 10M，最大表空间取决于页面大小（page size）。

![innodb-limits.html](https://raw.githubusercontent.com/BugLeesir/image_host01/main/blogs_img/mysql-20240408074630.png)

如何切换 MySQL 的数据引擎？

可以通过 alter table 语句来切换 MySQL 的数据引擎。

```sql
ALTER TABLE your_table_name ENGINE=InnoDB;
```

不过不建议，应该提前设计好到底用哪一种存储引擎。

### 22.存储引擎应该怎么选择？

- 大多数情况下，使用默认的 InnoDB 就对了，InnoDB 可以提供事务、行级锁等能力。
- MyISAM 适合读更多的场景。
- MEMORY 适合临时表，数据量不大的情况。由于数据都存放在内存，所以速度非常快。

### 23.InnoDB 和 MyISAM 主要有什么区别？

InnoDB 和 MyISAM 之间的区别主要表现在存储结构、事务支持、最小锁粒度、索引类型、主键必需、表的具体行数、外键支持等方面。

**①、存储结构**：

- MyISAM：用三种格式的文件来存储，.frm 文件存储表的定义；.MYD 存储数据；.MYI 存储索引。
- InnoDB：用两种格式的文件来存储，.frm 文件存储表的定义；.ibd 存储数据和索引。

**②、事务支持**：

- MyISAM：不支持事务。
- InnoDB：支持事务。

**③、最小锁粒度**：

- MyISAM：表级锁，高并发中写操作存在性能瓶颈。
- InnoDB：行级锁，并发写入性能高。

**④、索引类型**：

MyISAM 为非聚簇索引，索引和数据分开存储，索引保存的是数据文件的指针。

![MyIsam](https://raw.githubusercontent.com/BugLeesir/image_host01/main/blogs_img/mysql-20240403130104.png)

InnoDB 为聚簇索引，索引和数据不分开。

![InnoDB](https://raw.githubusercontent.com/BugLeesir/image_host01/main/blogs_img/mysql-20240403130508.png)

**⑤、外键支持**：MyISAM 不支持外键；InnoDB 支持外键。

**⑥、主键必需**：MyISAM 表可以没有主键；InnoDB 表必须有主键。

**⑦、表的具体行数**：MyISAM 表的具体行数存储在表的属性中，查询时直接返回；InnoDB 表的具体行数需要扫描整个表才能返回。

### 24.MySQL 日志文件有哪些？分别介绍下作用？

![MySQL的主要日志](https://raw.githubusercontent.com/BugLeesir/image_host01/main/blogs_img/mysql-c0ef6e68-bb33-48fc-b3a2-b9cdadd8e403.jpg)

MySQL 的日志文件主要包括：

①、**错误日志**（Error Log）：记录 MySQL 服务器启动、运行或停止时出现的问题。

②、**慢查询日志**（Slow Query Log）：记录执行时间超过 long\_query\_time 值的所有 SQL 语句。这个时间值是可配置的，默认情况下，慢查询日志功能是关闭的。可以用来识别和优化慢 SQL。

③、**一般查询日志**（General Query Log）：记录所有 MySQL 服务器的连接信息及所有的 SQL 语句，不论这些语句是否修改了数据。

④、**二进制日志**（Binary Log）：记录了所有修改数据库状态的 SQL 语句，以及每个语句的执行时间，如 INSERT、UPDATE、DELETE 等，但不包括 SELECT 和 SHOW 这类的操作。

⑤、**重做日志**（Redo Log）：记录了对于 InnoDB 表的每个写操作，不是 SQL 级别的，而是物理级别的，主要用于崩溃恢复。

⑥、**回滚日志**（Undo Log，或者叫事务日志）：记录数据被修改前的值，用于事务的回滚。

#### 请重点说说 binlog？

binlog 是一种物理日志，会在磁盘上记录下数据库的所有修改操作，以便进行数据恢复和主从复制。

- 当发生数据丢失时，binlog 可以将数据库恢复到特定的时间点。
- 主服务器（master）上的二进制日志可以被从服务器（slave）读取，从而实现数据同步。

binlog 包括两类文件：

- 二进制索引文件（.index）
- 二进制日志文件（.00000\*）

binlog 默认是没有启用的。要启用它，需要在 MySQL 的配置文件（my.cnf 或 my.ini）中设置 log\_bin 参数。

```conf
log_bin = mysql-bin //开启binlog

mysql-bin.*日志文件最大字节（单位：字节）
设置最大100MB
max_binlog_size=104857600

设置了只保留7天BINLOG（单位：天）
expire_logs_days = 7

binlog日志只记录指定库的更新
binlog-do-db=db_name

binlog日志不记录指定库的更新
binlog-ignore-db=db_name

写缓冲多少次，刷一次磁盘，默认0
sync_binlog=0
```

简单说一下这里面参数的作用：

①、`log_bin = mysql-bin`，启用 binlog，这样就可以在 MySQL 的数据目录中找到 db-bin.000001、db-bin.000002 等日志文件。

![binlog](https://raw.githubusercontent.com/BugLeesir/image_host01/main/blogs_img/mysql-20240417074049.png)

②、`max_binlog_size=104857600`

设置每个 binlog 文件的最大大小为 100MB（104857600 字节）。当 binlog 文件达到这个大小时，MySQL 会关闭当前文件并创建一个新的 binlog 文件。

③、`expire_logs_days = 7`

这条配置设置了 binlog 文件的自动过期时间为 7 天。过期的 binlog 文件将被自动删除。这有助于管理磁盘空间，防止长时间累积的 binlog 文件占用过多存储空间。

④、`binlog-do-db=db_name`

指定哪些数据库表的更新应该被记录。

⑤、`binlog-ignore-db=db_name`

指定忽略哪些数据库表的更新。

⑥、`sync_binlog=0`

这条配置设置了每多少次 binlog 写操作会触发一次磁盘同步操作。默认值 0 表示 MySQL 不会主动触发同步操作，而是依赖操作系统的磁盘缓存策略。

即当执行写操作时，数据会先写入操作系统的缓存，当缓存区满了再由操作系统将数据写入磁盘。

设置为 1 意味着每次 binlog 写操作后都会同步到磁盘，这可以提高数据安全性，但可能会对性能产生影响。

可以通过 `show variables like '%log_bin%';` 查看 binlog 是否开启。

![binary](https://raw.githubusercontent.com/BugLeesir/image_host01/main/blogs_img/mysql-20240326102701.png)

### 25.binlog 和 redo log 有什么区别？

binlog，即二进制日志，对所有存储引擎都可用，是 MySQL 服务器级别的日志，用于数据的复制、恢复和备份。而 redo log 主要用于保证事务的持久性，是 InnoDB 存储引擎特有的日志类型。

binlog 记录的是逻辑 SQL 语句，而 redo log 记录的是物理数据页的修改操作，不是具体的 SQL 语句。

redo log 是固定大小的，通常配置为一组文件，使用环形方式写入，旧的日志会在空间需要时被覆盖。*binlog 是追加写入*的，新的事件总是被添加到当前日志文件的末尾，当文件达到一定大小后，会创建新的 binlog 文件继续记录。

### 26.一条更新语句怎么执行的了解吗？

更新语句的执行是 Server 层和引擎层配合完成，数据除了要写入表中，还要记录相应的日志。

![update 执行](https://raw.githubusercontent.com/BugLeesir/image_host01/main/blogs_img/mysql-812fb038-39de-4204-ac9f-93d8b7448a18.jpg)

1. 执行器先找引擎获取 ID=2 这一行。ID 是主键，存储引擎检索数据，找到这一行。如果 ID=2 这一行所在的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回。
2. 执行器拿到引擎给的行数据，把这个值加上 1，比如原来是 N，现在就是 N+1，得到新的一行数据，再调用引擎接口写入这行新数据。
3. 引擎将这行新数据更新到内存中，同时将这个更新操作记录到 redo log 里面，此时 redo log 处于 prepare 状态。然后告知执行器执行完成了，随时可以提交事务。
4. 执行器生成这个操作的 binlog，并把 binlog 写入磁盘。
5. 执行器调用引擎的提交事务接口，引擎把刚刚写入的 redo log 改成提交（commit）状态，更新完成。

从上图可以看出，MySQL 在执行更新语句的时候，在服务层进行语句的解析和执行，在引擎层进行数据的提取和存储；同时在服务层对 binlog 进行写入，在 InnoDB 内进行 redo log 的写入。

不仅如此，在对 redo log 写入时有两个阶段的提交，一是 binlog 写入之前`prepare`状态的写入，二是 binlog 写入之后`commit`状态的写入。

#### 为什么要两阶段提交呢？

我们可以假设不采用两阶段提交的方式，而是采用“单阶段”进行提交，即要么先写入 redo log，后写入 binlog；要么先写入 binlog，后写入 redo log。这两种方式的提交都会导致原先数据库的状态和被恢复后的数据库的状态不一致。

**先写入 redo log，后写入 binlog：**

在写完 redo log 之后，数据此时具有`crash-safe`能力，因此系统崩溃，数据会恢复成事务开始之前的状态。但是，若在 redo log 写完时候，binlog 写入之前，系统发生了宕机。此时 binlog 没有对上面的更新语句进行保存，导致当使用 binlog 进行数据库的备份或者恢复时，就少了上述的更新语句。从而使得`id=2`这一行的数据没有被更新。

![先写 redo log，后写 bin log 的问题](https://raw.githubusercontent.com/BugLeesir/image_host01/main/blogs_img/mysql-75d5226b-cab9-461a-89a9-befcb2dfb996.jpg)

**先写入 binlog，后写入 redo log：**

写完 binlog 之后，所有的语句都被保存，所以通过 binlog 复制或恢复出来的数据库中 id=2 这一行的数据会被更新为 a=1。但是如果在 redo log 写入之前，系统崩溃，那么 redo log 中记录的这个事务会无效，导致实际数据库中`id=2`这一行的数据并没有更新。

![先写 bin log，后写 redo log 的问题](https://raw.githubusercontent.com/BugLeesir/image_host01/main/blogs_img/mysql-869c309b-9b93-46e1-8414-b35128e287a5.jpg)

简单说，redo log 和 binlog 都可以用于表示事务的提交状态，而两阶段提交就是让这两个状态保持逻辑上的一致。

### 27.redo log 怎么刷入磁盘的知道吗？

redo log 的写入不是直接落到磁盘，而是在内存中设置了一片称之为redo log buffer的连续内存空间，也就是redo日志缓冲区。

![redo log 缓冲](https://raw.githubusercontent.com/BugLeesir/image_host01/main/blogs_img/mysql-e1f59341-0695-45db-b759-30db73314e39.jpg)

> **什么时候会刷入磁盘？**

在如下的一些情况中，log buffer 的数据会刷入磁盘：

- log buffer 空间不足时

log buffer 的大小是有限的，如果不停的往这个有限大小的 log buffer 里塞入日志，很快它就会被填满。如果当前写入 log buffer 的 redo 日志量已经占满了 log buffer 总容量的大约**一半**左右，就需要把这些日志刷新到磁盘上。

- 事务提交时

在事务提交时，为了保证持久性，会把 log buffer 中的日志全部刷到磁盘。注意，这时候，除了本事务的，可能还会刷入其它事务的日志。

- 后台线程输入

有一个后台线程，大约每秒都会刷新一次`log buffer`中的`redo log`到磁盘。

- 正常关闭服务器时
- **触发 checkpoint 规则**

重做日志缓存、重做日志文件都是以**块（block）**的方式进行保存的，称之为**重做日志块（redo log block）**,块的大小是固定的 512 字节。我们的 redo log 它是固定大小的，可以看作是一个逻辑上的 **log group**，由一定数量的**log block** 组成。

![redo log 分块和写入](https://raw.githubusercontent.com/BugLeesir/image_host01/main/blogs_img/mysql-8d944e76-89ba-4fa6-9066-64ff4f55b532.jpg)

它的写入方式是从头到尾开始写，写到末尾又回到开头循环写。

其中有两个标记位置：

`write pos`是当前记录的位置，一边写一边后移，写到第 3 号文件末尾后就回到 0 号文件开头。`checkpoint`是当前要擦除的位置，也是往后推移并且循环的，擦除记录前要把记录更新到磁盘。

![write pos 和 checkpoint](https://raw.githubusercontent.com/BugLeesir/image_host01/main/blogs_img/mysql-31a14149-b261-45d9-bd3b-6afaec16e136.jpg)

当`write_pos`追上`checkpoint`时，表示 redo log 日志已经写满。这时候就不能接着往里写数据了，需要执行`checkpoint`规则腾出可写空间。

所谓的**checkpoint 规则**，就是 checkpoint 触发后，将 buffer 中日志页都刷到磁盘。

### 28.慢 SQL 如何定位呢？

#### 什么是慢 SQL？

顾名思义，慢 SQL 也就是执行时间较长的 SQL 语句，MySQL 中 long_query_time 默认值是 10 秒，也就是执行时间超过 10 秒的 SQL 语句会被记录到慢查询日志中。

可通过 show variables like 'long_query_time'; 查看当前的 long_query_time 值。

![long_query_time](https://raw.githubusercontent.com/BugLeesir/image_host01/main/blogs_img/mysql-20240327083506.png)

生产环境中，10 秒太久了，超过 1 秒的都可以认为是慢 SQL 了。

#### 那怎么定位慢 SQL 呢？

要想定位慢 SQL，需要了解一下 SQL 的执行过程：

1. 客户端发送 SQL 语句给 MySQL 服务器。
2. 如果查询缓存打开则会优先查询缓存，如果缓存中有对应的结果，直接返回给客户端。不过，MySQL 8.0 版本已经移除了查询缓存。
3. 分析器对 SQL 语句进行语法分析，判断是否有语法错误。
4. 搞清楚 SQL 语句要干嘛后，MySQL 还会通过优化器生成执行计划。
5. 执行器调用存储引擎的接口，执行 SQL 语句。

![SQL 执行过程](https://raw.githubusercontent.com/BugLeesir/image_host01/main/blogs_img/mysql-20240327083838.png)

SQL 执行过程中，优化器通过成本计算预估出执行效率最高的方式，基本的预估维度为：

- IO 成本：从磁盘读取数据到内存的开销。
- CPU 成本：CPU 处理内存中数据的开销。

基于这两个维度，可以得出影响 SQL 执行效率的因素有：

**①、IO 成本**  

- 数据量：数据量越大，IO 成本越高。所以要避免 `select *`；尽量分页查询。
- 数据从哪读取：尽量通过索引加快查询。

**②、CPU 成本**  

- 尽量避免复杂的查询条件，如有必要，考虑对子查询结果进行过滤。
- 尽量缩减计算成本，比如说为排序字段加上索引，提高排序效率；比如说使用 union all 替代 union，减少去重处理。

排查 SQL 效率主要通过两种手段：

- **慢查询日志**：开启 MySQL 慢查询日志，再通过一些工具比如 mysqldumpslow 去分析对应的慢查询日志，找出问题的根源。
- **服务监控**：可以在业务的基建中加入对慢 SQL 的监控，常见的方案有字节码插桩、连接池扩展、ORM 框架过程，对服务运行中的慢 SQL 进行监控和告警。

也可以使用 `show processlist;` 查看当前正在执行的 SQL 语句，找出执行时间较长的 SQL。

找到对应的慢 SQL 后，使用 EXPLAIN 命令查看 MySQL 是如何执行 SQL 语句的，再根据执行计划对 SQL 进行优化。

```sql
EXPLAIN SELECT * FROM your_table WHERE conditions;
```

#### 慢sql日志怎么开启？

慢 SQL 日志的开启方式有多种，比如说直接编辑 MySQL 的配置文件 my.cnf 或 my.ini，设置 slow_query_log 参数为 1，设置 slow_query_log_file 参数为慢查询日志的路径，设置 long_query_time 参数为慢查询的时间阈值。

```conf
[mysqld]
slow_query_log = 1
slow_query_log_file = /var/log/mysql/slow.log
long_query_time = 2   // 记录执行时间超过2秒的查询
```

然后重启 MySQL 服务就好了，也可以通过 set global 命令动态设置。

```sql
SET GLOBAL slow_query_log = 'ON';
SET GLOBAL slow_query_log_file = '/var/log/mysql/slow.log';
SET GLOBAL long_query_time = 2;
```

### 29.有哪些方式优化 SQL？

在进行 SQL 优化的时候，主要通过以下几个方面进行优化：

![SQL 优化](https://raw.githubusercontent.com/BugLeesir/image_host01/main/blogs_img/mysql-20240327104050.png)

#### 如何避免不必要的列？

比如说尽量避免使用 `select *`，只查询需要的列，减少数据传输量。

```sql
SELECT * FROM employees WHERE department_id = 5;
```

改成：

```sql
SELECT employee_id, first_name, last_name FROM employees WHERE department_id = 5;
```

#### 如何进行分页优化？

当数据量巨大时，传统的`LIMIT`和`OFFSET`可能会导致性能问题，因为数据库需要扫描`OFFSET + LIMIT`数量的行。

延迟关联（Late Row Lookups）和书签（Seek Method）是两种优化分页查询的有效方法。

**①、延迟关联**  

延迟关联适用于需要从多个表中获取数据且主表行数较多的情况。它首先从索引表中检索出需要的行 ID，然后再根据这些 ID 去关联其他的表获取详细信息。

```sql
SELECT e.id, e.name, d.details
FROM employees e
JOIN department d ON e.department_id = d.id
ORDER BY e.id
LIMIT 1000, 20;
```

延迟关联后：

```sql
SELECT e.id, e.name, d.details
FROM (
    SELECT id
    FROM employees
    ORDER BY id
    LIMIT 1000, 20
) AS sub
JOIN employees e ON sub.id = e.id
JOIN department d ON e.department_id = d.id;
```

首先对employees表进行分页查询，仅获取需要的行的 ID，然后再根据这些 ID 关联获取其他信息，减少了不必要的 JOIN 操作。

**②、书签（Seek Method）**  

书签方法通过记住上一次查询返回的最后一行的某个值，然后下一次查询从这个值开始，避免了扫描大量不需要的行。

假设需要对用户表进行分页，根据用户 ID 升序排列。

```sql
SELECT id, name
FROM users
ORDER BY id
LIMIT 1000, 20;
```

书签方式：

```sql
SELECT id, name
FROM users
WHERE id > last_max_id  -- 假设last_max_id是上一页最后一行的ID
ORDER BY id
LIMIT 20;
```

优化后的查询不再使用`OFFSET`，而是直接从上一页最后一个用户的 ID 开始查询。这里的`last_max_id`是上一次查询返回的最后一行的用户 ID。这种方法有效避免了不必要的数据扫描，提高了分页查询的效率。

#### 如何进行索引优化？

正确地使用索引可以显著减少 SQL 的查询时间，通常可以从索引覆盖、避免使用 `!=` 或者 `<>` 操作符、适当使用前缀索引、避免列上函数运算、正确使用联合索引等方面进行优化。

**①、利用覆盖索引**  

使用非主键索引查询数据时需要回表，但如果索引的叶节点中已经包含要查询的字段，那就不会再回表查询了，这就叫覆盖索引。

举个例子，现在要从 test 表中查询 city 为上海的 name 字段。

```sql
select name from test where city='上海'
```

如果仅在 city 字段上添加索引，那么这条查询语句会先通过索引找到 city 为上海的行，然后再回表查询 name 字段，这就是回表查询。

为了避免回表查询，可以在 city 和 name 字段上建立联合索引，这样查询结果就可以直接从索引中获取。

```sql
alter table test add index index1(city,name);
```

**②、避免使用 != 或者 <> 操作符**  

`!=` 或者 `<>` 操作符会导致 MySQL 无法使用索引，从而导致全表扫描。

例如，可以把`column<>'aaa'`，改成`column>'aaa' or column<'aaa'`，就可以使用索引了。

优化策略就是尽可能使用 `=`、`>`、`<`、`BETWEEN`等操作符，它们能够更好地利用索引。

>为什么 != 或 <> 操作符会导致无法使用索引？

- **索引的工作原理**：索引是通过排序和查找来加速数据访问的。对于等值查询（如 =）、范围查询（如 BETWEEN、<、>）等，索引可以快速定位到符合条件的记录。
- **不等查询的特性**：!= 或 <> 操作符表示不等于某个值，这意味着需要查找所有不等于该值的记录。由于这些记录可能分布在整个数据集中，索引无法有效地利用排序特性来快速定位这些记录。

**③、适当使用前缀索引**  

适当使用前缀索引可以降低索引的空间占用，提高索引的查询效率。

比如，邮箱的后缀一般都是固定的`@xxx.com`，那么类似这种后面几位为固定值的字段就非常适合定义为前缀索引：

```sql
alter table test add index index2(email(6));
```

需要注意的是，MySQL 无法利用前缀索引做 order by 和 group by 操作。

**④、避免列上使用函数**  

在 where 子句中直接对列使用函数会导致索引失效，因为数据库需要对每行的列应用函数后再进行比较，无法直接利用索引

```sql
select name from test where date_format(create_time,'%Y-%m-%d')='2021-01-01';
```

可以改成：

```sql
select name from test where create_time>='2021-01-01 00:00:00' and create_time<'2021-01-02 00:00:00';
```

通过日期的范围查询，而不是在列上使用函数，可以利用 create_time 上的索引。

**⑤、正确使用联合索引**  

正确地使用联合索引可以极大地提高查询性能，联合索引的创建应遵循最左前缀原则，即索引的顺序应根据列在查询中的使用频率和重要性来安排。

```sql
select * from messages where sender_id=1 and receiver_id=2 and is_read=0;
```

那就可以为 sender_id、receiver_id 和 is_read 这三个字段创建联合索引，但是要注意索引的顺序，应该按照查询中的字段顺序来创建索引。

```sql
alter table messages add index index3(sender_id,receiver_id,is_read);
```

#### 如何进行 JOIN 优化？

对于 JOIN 操作，可以通过优化子查询、小表驱动大表、适当增加冗余字段、避免 join 太多表等方式来进行优化。

**①、优化子查询**  

子查询，特别是在 select 列表和 where 子句中的子查询，往往会导致性能问题，因为它们可能会为每一行外层查询执行一次子查询。

使用子查询：

```sql
select name from A where id in (select id from B);
```

使用 JOIN 代替子查询：

```sql
select A.name from A join B on A.id=B.id;
```

**②、小表驱动大表**  

在执行 JOIN 操作时，应尽量让行数较少的表（小表）驱动行数较多的表（大表），这样可以减少查询过程中需要处理的数据量。

比如 left join，左表是驱动表，所以 A 表应小于 B 表，这样建立连接的次数就少，查询速度就快了。

```sql
select name from A left join B;
```

**③、适当增加冗余字段**  

在某些情况下，通过在表中适当增加冗余字段来避免 JOIN 操作，可以提高查询效率，尤其是在高频查询的场景下。

比如，我们有一个订单表和一个商品表，查询订单时需要显示商品名称，如果每次都通过 JOIN 操作查询商品表，会降低查询效率。这时可以在订单表中增加一个冗余字段，存储商品名称，这样就可以避免 JOIN 操作。

```sql
select order_id,product_name from orders;
```

**④、避免使用 JOIN 关联太多的表**  

《阿里巴巴 Java 开发手册》上就规定，不要使用 join 关联太多的表，最多不要超过 3 张表。

因为 join 太多表会降低查询的速度，返回的数据量也会变得非常大，不利于后续的处理。

如果业务逻辑允许，可以考虑将复杂的 JOIN 查询分解成多个简单查询，然后在应用层组合这些查询的结果。

#### 如何进行排序优化？

MySQL 生成有序结果的方式有两种：一种是对结果集进行排序操作，另外一种是按照索引顺序扫描得出的自然有序结果。

因此在设计索引的时候要充分考虑到排序的需求。

```sql
select id, name from users order by name;
```

如果 name 字段上有索引，那么 MySQL 可以直接利用索引的有序性，避免排序操作。

#### 如何进行 UNION 优化？

UNION 操作用于合并两个或者多个 SELECT 语句的结果集。

**①、条件下推**  

条件下推是指将 where、limit 等子句下推到 union 的各个子查询中，以便优化器可以充分利用这些条件进行优化。

假设我们有两个查询分支，需要合并结果并过滤：

```sql
SELECT * FROM (
    SELECT * FROM A
    UNION
    SELECT * FROM B
) AS sub
WHERE sub.id = 1;
```

可以改写成：

```sql
SELECT * FROM A WHERE id = 1
UNION
SELECT * FROM B WHERE id = 1;
```

通过将查询条件下推到 UNION 的每个分支中，每个分支查询都只处理满足条件的数据，减少了不必要的数据合并和过滤。

### 30.怎么看执行计划 explain，如何理解其中各个字段的含义？

explain 是 MySQL 提供的一个用于查看查询执行计划的工具，可以帮助我们分析查询语句的性能瓶颈，找出慢 SQL 的原因。

使用方式也非常简单，在 select 语句前加上 explain 关键字就可以了。

```sql
explain select * from students where id =9
```

接下来，我们需要理解 explain 输出结果中各个字段的含义。

![EXPLAIN](https://raw.githubusercontent.com/BugLeesir/image_host01/main/blogs_img/mysql-e234658f-5672-4a8d-9a75-872b305a171d.jpg)

①、**id** 列：查询的标识符。

②、**select\_type** 列：查询的类型。常见的类型有：

- SIMPLE：简单查询，不包含子查询或者 UNION 查询。
- PRIMARY：查询中如果包含子查询，则最外层查询被标记为 PRIMARY。
- SUBQUERY：子查询。
- DERIVED：派生表的 SELECT，FROM 子句的子查询。

③、**table** 列：查的哪个表。

④、**type** 列：表示 MySQL 在表中找到所需行的方式，性能从最优到最差分别为：system > const > eq\_ref > ref > range > index > ALL。

- system，表只有一行，一般是系统表，往往不需要进行磁盘 IO，速度非常快
- const、eq\_ref、ref：这些类型表示 MySQL 可以使用索引来查找单个行，其中 const 是最优的，表示查询最多返回一行。
- range：只检索给定范围的行，使用索引来检索。在`where`语句中使用 `bettween...and`、`<`、`>`、`<=`、`in` 等条件查询 `type` 都是 `range`。
- index：遍历索引树读取。
- ALL：全表扫描，效率最低。

⑤、**possible\_keys** 列：可能会用到的索引，但并不一定实际被使用。

⑥、**key** 列：实际使用的索引。如果为 NULL，则没有使用索引。

⑦、**key\_len** 列：MySQL 决定使用的索引长度（以字节为单位）。当表有多个索引可用时，key\_len 字段可以帮助识别哪个索引最有效。通常情况下，更短的 key\_len 意味着数据库在比较键值时需要处理更少的数据。

⑧、**ref** 列：用于与索引列比较的值来源。

- const：表示常量，这个值是在查询中被固定的。例如在 WHERE `column = 'value'`中。
- 一个或多个列的名称，通常在 JOIN 操作中，表示 JOIN 条件依赖的字段。
- NULL，表示没有使用索引，或者查询使用的是全表扫描。

⑨、**rows** 列：估算查到结果集需要扫描的数据行数，原则上 rows 越少越好。

⑩、**Extra** 列：附加信息。

- Using index：表示只利用了索引。
- Using where：表示使用了 WHERE 过滤。
- Using temporary ：表示使用了临时表来存储中间结果。

示例：

![explain](https://raw.githubusercontent.com/BugLeesir/image_host01/main/blogs_img/mysql-20240417092646.png)

### 31.为什么使用索引会加快查询？

数据库文件是存储在磁盘上的，磁盘 I/O 是数据库操作中最耗时的部分之一。没有索引时，数据库会进行全表扫描（Sequential Scan），这意味着它必须读取表中的每一行数据来查找匹配的行（时间效率为 O(n)）。当表的数据量非常大时，就会导致大量的磁盘 I/O 操作。

有了索引，就可以直接跳到索引指示的数据位置，而不必扫描整张表，从而大大减少了磁盘 I/O 操作的次数。

MySQL 的 InnoDB 存储引擎默认使用 B+ 树来作为索引的数据结构，而 B+ 树的查询效率非常高，时间复杂度为 O(logN)。

索引文件相较于数据库文件，体积小得多，查到索引之后再映射到数据库记录，查询效率就会高很多。

索引就好像书的目录，通过目录去查找对应的章节内容会比一页一页的翻书快很多。

可通过 create index 创建索引，比如：

```SQL
create index idx_name on students(name);
```

### 32.能简单说一下索引的分类吗？

MySQL 的索引可以显著提高查询的性能，可以从三个不同的维度对索引进行分类（功能、数据结构、存储位置）：

![索引类型](https://raw.githubusercontent.com/BugLeesir/image_host01/main/blogs_img/mysql-20240311225809.png)

#### 功能上的分类

①、**主键索引**: 表中每行数据唯一标识的索引，强调列值的唯一性和非空性。

当创建表的时候，可以直接指定主键索引：

```sql
CREATE TABLE users (
    id INT AUTO_INCREMENT PRIMARY KEY,
    username VARCHAR(255) NOT NULL,
    email VARCHAR(255)
);
```

id 列被指定为主键索引，同时，MySQL 会自动为这个列创建一个聚簇索引（主键索引一定是聚簇索引）。

可以通过 `show index from table_name` 查看索引信息，比如前面创建的 users 表：

![索引信息](https://raw.githubusercontent.com/BugLeesir/image_host01/main/blogs_img/mysql-20240312090221.png)

- `Non_unique` 如果索引不能包含重复词，则为 0；如果可以，则为 1。这可以帮助我们区分是唯一索引还是普通索引。
- `Key_name` 索引的名称。如果索引是主键，那么这个值是 PRIMARY。
- `Column_name` 索引所包含的字段名。
- `Index_type` 索引的类型，比如 BTREE、HASH 等。

②、**唯一索引**: 保证数据列中每行数据的唯一性，但允许有空值。

可以通过下面的语句创建唯一索引：

```sql
CREATE UNIQUE INDEX idx_username ON users(username);
```

同样可以通过 show index from table_name 确认索引信息

`Non_unique` 为 0，表示这是一个唯一索引。

③、**普通索引**: 基本的索引类型，用于加速查询。

可以通过下面的语句创建普通索引：

```sql
CREATE INDEX idx_email ON users(email);
```

这次我们通过下面的语句一起把三个索引的关键信息查出来：

```sql
SELECT `TABLE_NAME` AS `Table`, `NON_UNIQUE`, `INDEX_NAME` AS `Key_name`, `COLUMN_NAME` AS `Column_name`, `INDEX_TYPE` AS `Index_type`
FROM information_schema.statistics
WHERE `TABLE_NAME` = 'users' AND `TABLE_SCHEMA` = DATABASE();
```

![普通索引](https://raw.githubusercontent.com/BugLeesir/image_host01/main/blogs_img/mysql-20240312091632.png)

可以确定 idx_email 是一个普通索引，因为 `Non_unique` 为 1。

④、**全文索引**：特定于文本数据的索引，用于提高文本搜索的效率。

假设有一个名为 articles 的表，下面这条语句在 content 列上创建了一个全文索引。

```sql
CREATE FULLTEXT INDEX idx_article_content ON articles(content);
```

#### 数据结构上分类

①、B+树索引：最常见的索引类型，一种将索引值按照一定的算法，存入一个树形的数据结构中（二叉树），每次查询都从树的根节点开始，一次遍历叶子节点，找到对应的值。查询效率是 O(logN)。

也是 **InnoDB 存储引擎的默认索引类型**。

B+ 树是 B 树的升级版，B+ 树中的非叶子节点都不存储数据，只存储索引。叶子节点中存储了所有的数据，并且构成了一个从小到大的有序双向链表，使得在完成一次树的遍历定位到范围查询的起点后，可以直接通过叶子节点间的指针顺序访问整个查询范围内的所有记录，而无需对树进行多次遍历。这在处理大范围的查询时特别高效。

因为 B+ 树是 InnoDB 的默认索引类型，所以创建 B+ 树的时候不需要指定索引类型。

```sql
CREATE TABLE example_btree (
    id INT AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(255),
    INDEX name_index (name)
) ENGINE=InnoDB;
```

②、Hash 索引：基于哈希表的索引，查询效率可以达到 O(1)，但是只适合 = 和 in 查询，不适合范围查询。

Hash 索引在原理上和 Java 中的 HashMap 类似，当发生哈希冲突的时候也是通过拉链法来解决

![哈希索引](https://raw.githubusercontent.com/BugLeesir/image_host01/main/blogs_img/mysql-20240312094537.png)

可以通过下面的语句创建哈希索引：

```sql
CREATE TABLE example_hash (
    id INT AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(255),
    UNIQUE HASH (name)
) ENGINE=MEMORY;
```

注意，我们这里创建的是 MEMORY 存储引擎，InnoDB 并不提供直接创建哈希索引的选项，因为 B+ 树索引能够很好地支持范围查询和等值查询，满足了大多数数据库操作的需要。

不过，InnoDB 存储引擎内部使用了一种名为“自适应哈希索引”（Adaptive Hash Index, AHI）的技术。

自适应哈希索引并不是由用户显式创建的，而是 InnoDB 根据数据访问的模式自动建立和管理的。当 InnoDB 发现某个索引被频繁访问时，会在内存中创建一个哈希索引，以加速对这个索引的访问。

```sql
SHOW VARIABLES LIKE 'innodb_adaptive_hash_index';
```

如果返回的值是 ON，说明自适应哈希索引是开启的。

![hash](https://raw.githubusercontent.com/BugLeesir/image_host01/main/blogs_img/mysql-20240312095811.png)

### 从存储位置上分类

①、聚簇索引：聚簇索引的叶子节点保存了一行记录的所有列信息。也就是说，聚簇索引的叶子节点中，包含了一个完整的记录行。

![聚簇索引](https://raw.githubusercontent.com/BugLeesir/image_host01/main/blogs_img/mysql-20240311231652.png)

②、非聚簇索引：它的叶子节点只包含一个主键值，通过非聚簇索引查找记录要先找到主键，然后通过主键再到聚簇索引中找到对应的记录行，这个过程被称为回表。

![非聚簇索引](https://raw.githubusercontent.com/BugLeesir/image_host01/main/blogs_img/mysql-20240311231611.png)

InnoDB 存储引擎的主键使用的是聚簇索引，MyISAM 存储引擎不管是主键索引，还是二级索引使用的都是非聚簇索引。

### 33.创建索引有哪些注意点？

尽管索引能提高查询性能，但不当的使用也会带来一系列问题。在加索引时需要注意以下几点：

①、选择合适的列作为索引

- 经常作为查询条件（WHERE 子句）、排序条件（ORDER BY 子句）、分组条件（GROUP BY 子句）的列是建立索引的好候选。
- 区分度低的字段，例如性别，不要建索引
- 频繁更新的字段，不要作为主键或者索引
- 不建议用无序的值(例如身份证、UUID )作为索引，当主键具有不确定性，会造成叶子节点频繁分裂，出现磁盘存储的碎片化

②、避免过多的索引

- 每个索引都需要占用额外的磁盘空间。
- 更新表（INSERT、UPDATE、DELETE 操作）时，所有的索引都需要被更新。
- 维护索引文件需要成本；还会导致页分裂，IO 次数增多。

③、利用前缀索引和索引列的顺序

- 对于字符串类型的列，可以考虑使用前缀索引来减少索引大小。
- 在创建复合索引时，应该根据查询条件将最常用作过滤条件的列放在前面。

### 34.索引哪些情况下会失效呢？

- **在索引列上使用函数或表达式**：如果在查询中对索引列使用了函数或表达式，那么索引可能无法使用，因为数据库无法预先计算出函数或表达式的结果。例如：`SELECT * FROM table WHERE YEAR(date_column) = 2021`。
- 使用不等于（`<>`）或者 NOT 操作符：这些操作符通常会使索引失效，因为它们会扫描全表。
- **使用 LIKE 操作符，但是通配符在最前面**：如果 LIKE 的模式串是以“%”或者“\_”开头的，那么索引也无法使用。例如：`SELECT * FROM table WHERE column LIKE '%abc'`。
- **OR 操作符**：如果查询条件中使用了 OR，并且 OR 两边的条件分别涉及不同的索引，那么这些索引可能都无法使用。
- 联合索引不满足最左前缀原则时，索引会失效。

### 35.索引不适合哪些场景呢？

- **数据表较小**：当表中的数据量很小，或者查询需要扫描表中大部分数据时，数据库优化器可能会选择全表扫描而不是使用索引。在这种情况下，维护索引的开销可能大于其带来的性能提升。
- **频繁更新的列**：对于经常进行更新、删除或插入操作的列，使用索引可能会导致性能下降。因为每次数据变更时，索引也需要更新，这会增加额外的写操作负担。

#### 性别字段要建立索引吗？

性别字段通常不适合建立索引。因为性别字段的选择性（区分度）较低，独立索引效果有限。

如果性别字段又很少用于查询，表的数据规模较小，那么建立索引反而会增加额外的存储空间和维护成本。

如果性别字段确实经常用于查询条件，数据规模也比较大，可以将性别字段作为复合索引的一部分，与选择性较高的字段一起加索引，会更好一些。

#### 什么是区分度？

区分度（Selectivity）是衡量一个字段在数据库表中唯一值的比例，用来表示该字段在索引优化中的有效性。

区分度 = 字段的唯一值数量 / 字段的总记录数；接近 1，字段值大部分是唯一的。例如，用户的唯一 ID，一般都是主键索引。接近 0，则说明字段值重复度高。

例如，一个表中有 1000 条记录，其中性别字段只有两个值（男、女），那么性别字段的区分度只有 0.002。

高区分度的字段更适合拿来作为索引，因为索引可以更有效地缩小查询范围。

#### MySQL查看字段区分度的命令？

在 MySQL 中，可以通过 COUNT(DISTINCT column_name) 和 COUNT(*) 的比值来计算字段的区分度。例如：

```sql
SELECT 
    COUNT(DISTINCT gender) / COUNT(*) AS gender_selectivity
FROM 
    users;
```

#### 索引是不是建的越多越好呢？

当然不是。

- **索引会占据磁盘空间**
- **索引虽然会提高查询效率，但是会降低更新表的效率**。比如每次对表进行增删改操作，MySQL 不仅要保存数据，还有保存或者更新对应的索引文件。
