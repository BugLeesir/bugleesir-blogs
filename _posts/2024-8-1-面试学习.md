---
layout: article
title: 面试题目
---




## Java集合框架

### 1.阻塞队列的阻塞是什么含义？

阻塞队列的“阻塞”指的是当生产者往队列中添加元素时，如果队列已满，则生产者的添加操作会被阻塞，直到队列中有空闲空间；同样地，当消费者从队列中移除元素时，如果队列为空，则消费者的移除操作会被阻塞，直到队列中有新的元素被添加进来。这种机制确保了在多线程环境下队列的操作是线程安全的，并且能够有效地协调生产者和消费者之间的同步问题。

### 2.阻塞队列的实现方式？

Java中的BlockingQueue接口定义了阻塞队列的行为，并且Java并发库java.util.concurrent提供了多种BlockingQueue的具体实现。

**ArrayBlockingQueue：**

基于数组结构的有界阻塞队列。
固定大小的队列，当队列满时，生产者线程会被阻塞，直到队列中的元素被消费掉。
当队列空时，消费者线程会被阻塞，直到队列中有新的元素加入。

**LinkedBlockingQueue：**

基于链表结构的阻塞队列。
可以指定容量大小，如果不指定，默认为Integer.MAX_VALUE。
当队列满时，生产者线程会被阻塞；当队列空时，消费者线程会被阻塞。

**PriorityBlockingQueue：**

具有优先级的无界阻塞队列。
类似于PriorityQueue，但是加入了阻塞的功能。
不会阻塞生产者线程，但是可以保证具有较高优先级的元素会被先消费。

**DelayQueue：**

使用Delayed类型的元素的无界阻塞队列。
队列中的元素只有在其延迟过期后才能被消费者线程消费。
生产者线程不会被阻塞，但消费者线程可能会因为没有到期的元素而被阻塞。

**SynchronousQueue：**

不存储元素的阻塞队列。
每个插入操作必须等待另一个线程的对应移除操作，反之亦然。
实际上不存储任何元素，更多地用于线程间的数据交换。

**LinkedTransferQueue：**

基于链表结构的无界阻塞队列。
提供了更强的传递语义，允许生产者直接将元素传给消费者，如果消费者不存在则放入内部队列。
支持传递操作，即生产者可以直接将元素传递给消费者线程

### 3.线程不安全的集合变成线程安全的方法？

**使用synchronizedXxx()方法：**

java.util.Collections类提供了一系列静态方法，如synchronizedList(), synchronizedSet(), synchronizedMap()等，可以将线程不安全的集合包装成线程安全的集合。
例如，对于ArrayList，可以使用Collections.synchronizedList(new ArrayList<>())将其转换为线程安全的列表。

**使用同步容器：**

Java标准库提供了一些内置的线程安全容器，如Vector和Hashtable。
Vector是线程安全的List实现，而Hashtable是线程安全的Map实现。

**显式同步：**

可以手动对集合的操作进行同步控制，比如在访问集合前加上synchronized关键字，并使用集合对象本身或其外部的对象作为锁。
示例代码如下：

```java
List list = new ArrayList<>();
Object lock = new Object();
synchronized(lock) {
    // 在这里执行对list的安全操作
}
```

**使用并发集合：**

Java并发包java.util.concurrent提供了线程安全的集合实现，如ConcurrentHashMap, CopyOnWriteArrayList, CopyOnWriteArraySet等。
这些集合在设计时就考虑到了并发访问的问题，因此不需要额外的同步措施。

**使用ReentrantLock或其他锁机制：**

可以使用更高级的锁机制，如ReentrantLock，来替代synchronized关键字，以获得更细粒度的锁控制。

**使用不可变集合：**

创建不可变集合，一旦创建就不能改变，这样也避免了并发修改的问题。
不可变集合可以被认为是线程安全的，因为它们的状态不会改变。

### 4.HashMap的底层数据结构?

JDK 8 中 HashMap 的数据结构是数组+链表+红黑树。

HashMap 的核心是一个动态数组（Node[] table），用于存储键值对。这个数组的每个元素称为一个“桶”（Bucket），每个桶的索引是通过对键的哈希值进行哈希函数处理得到的。

当多个键经哈希处理后得到相同的索引时，会发生哈希冲突。HashMap 通过链表来解决哈希冲突——即将具有相同索引的键值对通过链表连接起来。

不过，链表过长时，查询效率会比较低，于是当链表的长度超过 8 时（且数组的长度大于 64），链表就会转换为红黑树。红黑树的查询效率是 O(logn)，比链表的 O(n) 要快。数组的查询效率是 O(1)。

链表转换为红黑树的条件

链表长度：当单个桶（bucket）中的链表长度达到 8 时，该链表会被转换为红黑树。
最小树化容量：HashMap 的总容量（桶数组大小）必须至少为 64。如果 HashMap 的容量小于 64，即使链表长度达到 8，也不会进行树化，而是会选择扩容。

红黑树转换为链表的条件

树节点数量：当红黑树节点元素小于等于 6 时，红黑树会被转换回链表形式。这是因为，在小数据量时，链表的效率更高。

转换逻辑

树化：当一个桶中的链表长度达到 8，并且 HashMap 的容量大于等于 64 时，这个链表会被转换成红黑树。这样做的目的是为了减少链表的长度，从而提高查找的效率。红黑树的平均查找长度是 O(log n)，相比于链表的 O(n)，在链表长度较长时性能更好。

链表化：当红黑树中的节点数量减少到 6 或更少时，红黑树会被转换回链表。这是因为对于少量的数据，链表的开销较小，转换为链表可以减少不必要的内存占用和管理开销。

扩容机制

扩容：在某些情况下，如果 HashMap 的容量不足以容纳更多的元素，或者链表长度达到树化阈值但容量不足时，HashMap 会进行扩容。扩容操作会将容量加倍，并重新散列所有的元素。

当向 HashMap 中添加一个键值对时，会使用哈希函数计算键的哈希码，确定其在数组中的位置，哈希函数的目标是尽量减少哈希冲突，保证元素能够均匀地分布在数组的每个位置上。

```java
static final int hash(Object key) {
    int h;
    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
}
```

当向 HashMap 中添加元素时，如果该位置已有元素（发生哈希冲突），则新元素将被添加到链表的末尾或红黑树中。如果键已经存在，其对应的值将被新值覆盖。

当从 HashMap 中获取元素时，也会使用哈希函数计算键的位置，然后根据位置在数组、链表或者红黑树中查找元素。

HashMap 的初始容量是 16，随着元素的不断添加，HashMap 的容量（也就是数组大小）可能不足，于是就需要进行扩容，阈值是capacity * loadFactor，capacity 为容量，loadFactor 为负载因子，默认为 0.75。

扩容后的数组大小是原来的 2 倍，然后把原来的元素重新计算哈希值，放到新的数组中。

总的来说，HashMap 是一种通过哈希表实现的键值对集合，它通过将键哈希化成数组索引，并在冲突时使用链表或红黑树来存储元素，从而实现快速的查找、插入和删除操作。

### 5.为什么 HashMap 是线程不安全的？

修改操作非原子性

HashMap 的修改操作（如 put 和 remove）并没有使用锁来保证原子性，这意味着在多线程环境中，这些操作可能会被中断，导致数据不一致。
例如，在 put 操作中，HashMap 需要计算哈希值、找到桶的位置、插入键值对等步骤，这些步骤在多线程环境下可能被其他线程干扰。

扩容时的竞态条件

当 HashMap 达到其容量限制时，它会进行扩容操作，这个过程涉及到重新散列所有已存在的键值对。
如果多个线程同时触发扩容操作，可能会导致竞态条件，其中一个线程的扩容操作可能被另一个线程覆盖，从而导致数据丢失或不一致。

链表或红黑树操作的不一致性

当多个线程同时操作同一个桶中的链表或红黑树时，如果没有适当的同步机制，可能会导致链表或红黑树的结构被破坏，进而导致数据丢失或无限循环等问题。

可见性问题

HashMap 中的变量（如容量、阈值等）在多线程环境中如果没有正确的同步机制，可能会导致线程间的可见性问题，即一个线程修改的数据不能被另一个线程及时看到。

解决方案

为了使 HashMap 在多线程环境中安全使用，可以采取以下措施：

使用 Collections.synchronizedMap：将 HashMap 包装成线程安全的集合。

使用 ConcurrentHashMap：这是 HashMap 的线程安全版本，专为多线程环境设计。
显式同步：在访问 HashMap 时手动加锁，确保同一时刻只有一个线程能够修改 HashMap。

### 6.平衡二叉树

平衡二叉树（Balanced Binary Tree）是一种特殊的二叉树，其中任意节点的左右子树高度差不超过一定范围。常见的平衡二叉树有 AVL 树和红黑树。

#### AVL 树

AVL 树是一种自平衡的二叉查找树，它通过在每个节点上存储一个平衡因子（balance factor）来保持树的平衡。平衡因子定义为左右子树的高度差，它可以是 -1、0 或 1。

**AVL 树的基本操作**  

插入操作：

插入新节点。
通过旋转操作来保持平衡。

删除操作：

删除指定节点。
通过旋转操作来保持平衡。

查找操作：

在 AVL 树中查找指定键值的节点。

当平衡二叉树（如 AVL 树）的平衡性被破坏时，通常是因为插入或删除了一个节点，导致某些节点的平衡因子（左子树高度与右子树高度之差）的绝对值超过了允许的范围（对于 AVL 树来说是 1）。为了恢复平衡，需要执行一系列旋转操作。

**恢复平衡的步骤**  

确定破坏点：找到第一个平衡因子绝对值大于 1 的节点。

识别破坏模式：根据破坏点与其子节点的关系，确定破坏模式。

执行相应的旋转操作：根据破坏模式执行单旋转或多旋转（双旋转）。

常见的破坏模式和对应的旋转操作

LL（左左）：破坏点的左子节点有一个更高的左子树。

RR（右右）：破坏点的右子节点有一个更高的右子树。

LR（左右）：破坏点的左子节点有一个更高的右子树。

RL（右左）：破坏点的右子节点有一个更高的左子树。

旋转操作

单旋转：当破坏模式为 LL 或 RR 时，执行一次旋转即可恢复平衡。

双旋转：当破坏模式为 LR 或 RL 时，首先对破坏点的子节点执行一次旋转，然后对破坏点执行一次旋转。

LL模式的旋转操作

![error](https://raw.githubusercontent.com/BugLeesir/image_host01/main/blogs_img/e6ba79cc941b246e710758a75bd3b28.jpg)

RR模式的旋转操作

![error](https://raw.githubusercontent.com/BugLeesir/image_host01/main/blogs_img/06df2e2af3731aa9dea7003448bece4.jpg)

LR模式的旋转操作

![error](https://raw.githubusercontent.com/BugLeesir/image_host01/main/blogs_img/f8e97677dfdc3b526c5db85068edff1.jpg)

RL模式的旋转操作

![error](https://raw.githubusercontent.com/BugLeesir/image_host01/main/blogs_img/2991016a03a325661a32b44c6610dc4.jpg)

删除的旋转操作

![error](https://raw.githubusercontent.com/BugLeesir/image_host01/main/blogs_img/3a6327794b26a6bb0eb28469a8f3cb8.jpg)

#### 红黑树

红黑树（Red-Black Tree）是一种自平衡的二叉查找树，它通过特定的颜色标记以及旋转和重新着色操作来维持树的近似平衡，从而确保树的高度保持在(O(\log n))，这里(n)是树中节点的数量。这使得红黑树能够高效地执行查找、插入和删除操作。

**红黑树的特点**  

红黑树的每个节点都有一个颜色属性，可以是红色（red）或黑色（black），并且满足以下性质：

节点属性：每个节点要么是红色的，要么是黑色的。

根节点：根节点总是黑色。

叶子节点：所有叶子节点（NIL节点，空节点）都是黑色的。

红色节点：两个红色节点之间不能相邻，即一个红色节点的父节点和子节点必须是黑色。

黑色高度：从任一节点到其每个叶子的所有简单路径上包含相同数量的黑色节点。

**插入后恢复平衡的情况**  

当插入一个新节点后，该节点被标记为红色，并且可能违反红黑树的性质。常见的恢复策略包括：

变色：如果新插入的节点的父节点也是红色，那么需要考虑变色操作（若父节点为黑色则无需自平衡）。如果叔叔节点（父节点的兄弟节点）也是红色，则将父节点和叔叔节点都变为黑色，祖父节点变为红色，然后以祖父节点作为新的起点继续检查（即黑红红改为红黑红）。

旋转：如果叔叔节点是黑色或不存在，则需要进行旋转操作来调整树的结构。具体分为以下几种情况：

左左情况：如果新节点是其父节点的左孩子，而父节点又是其祖父节点的左孩子，则进行一次右旋。

右右情况：如果新节点是其父节点的右孩子，而父节点又是其祖父节点的右孩子，则进行一次左旋。

左右情况：如果新节点是其父节点的右孩子，而父节点是其祖父节点的左孩子，则先对其父节点进行左旋，再对祖父节点进行右旋。

右左情况：如果新节点是其父节点的左孩子，而父节点是其祖父节点的右孩子，则先对其父节点进行右旋，再对祖父节点进行左旋。

**删除后的恢复平衡**  

删除节点后，可能需要调整树的结构来恢复红黑树的性质。主要关注的是删除操作可能导致的黑色高度减少问题。常见的恢复策略包括：

双黑节点：如果删除了一个黑色节点，并且替换它的节点是红色，则直接将其替换为黑色即可。否则，如果替换节点是黑色，则会产生一个“双黑”节点（即节点和其原本的NIL节点都被视为黑色）。

旋转和变色：为了修复双黑问题，需要考虑以下几个方向：

如果双黑节点的兄弟节点是红色，则可以通过旋转和变色来解决。例如，如果兄弟节点是红色，且兄弟节点的外侧子节点是黑色，则可以先进行一次旋转（左旋或右旋），使兄弟节点成为父节点，然后进行变色。

如果兄弟节点是黑色，且兄弟节点的两个子节点都是黑色，则将兄弟节点变为红色，并继续在其父节点处进行检查。

如果兄弟节点是黑色，且兄弟节点的外侧子节点是红色，则可以先进行一次旋转（左旋或右旋），使兄弟节点成为父节点，然后进行变色。

如果兄弟节点是黑色，且兄弟节点的内侧子节点是红色，则可以先进行一次旋转（左旋或右旋），使兄弟节点成为父节点，然后进行变色。

### 7.HashMap 的 put 流程

第一步，通过 hash 方法计算 key 的哈希值。

```java
static final int hash(Object key) {
    int h;
    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
}
```

第二步，数组进行第一次扩容。

```java
if ((tab = table) == null || (n = tab.length) == 0)
    n = (tab = resize()).length;
```

第三步，根据哈希值计算 key 在数组中的下标，如果对应下标正好没有存放数据，则直接插入。

```java
if ((p = tab[i = (n - 1) & hash]) == null)
    tab[i] = newNode(hash, key, value, null);
```

如果对应下标已经有数据了，就需要判断是否为相同的 key，是则覆盖 value，否则需要判断是否为树节点，是则向树中插入节点，否则向链表中插入数据。

```java
else {
    Node<K,V> e; K k;
    if (p.hash == hash &&
        ((k = p.key) == key || (key != null && key.equals(k))))
        e = p;
    else if (p instanceof TreeNode)
        e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);
    else {
        for (int binCount = 0; ; ++binCount) {
            if ((e = p.next) == null) {
                p.next = newNode(hash, key, value, null);
                if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st
                    treeifyBin(tab, hash);
                break;
            }
            if (e.hash == hash &&
                ((k = e.key) == key || (key != null && key.equals(k))))
                break;
            p = e;
        }
    }
}
```

注意，在链表中插入节点的时候，如果链表长度大于等于 8，则需要把链表转换为红黑树。

```java
if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st
    treeifyBin(tab, hash);
```

所有元素处理完后，还需要判断是否超过阈值threshold，超过则扩容。

```java
if (++size > threshold)
    resize();
```

### 8.只重写 equals 没重写 hashcode，map put 的时候会发生什么?

如果只重写 equals 方法，没有重写 hashcode 方法，那么会导致 equals 相等的两个对象，hashcode 不相等，这样的话，这两个对象会被放到不同的桶中，这样就会导致 get 的时候，找不到对应的值。

当你使用一个键去 Map 中获取对应的值时，Map 会首先使用键的 hashCode 方法来定位可能的位置，然后再调用 equals 方法来确认键是否匹配。

如果你只重写了 equals 方法，那么即使两个键 equals 相等，但它们的 hashCode 不同，Map 将无法找到正确的条目，导致返回 null，即使该键实际上存在于 Map 中。

### 9.为什么要用高低做异或运算？为什么非得高低 16 位异或？

为什么使用高低位进行异或运算？

提高哈希值的均匀性：

哈希函数的目标是将输入数据映射到一个固定大小的空间中，使得输出尽可能均匀分布。
使用高低位异或运算可以帮助混合高阶位和低阶位的信息，从而提高哈希值的均匀性和随机性。

避免局部相关性：

在许多情况下，输入数据的高阶位和低阶位可能存在一定的相关性。通过异或运算，可以打破这种相关性，使得哈希值更加独立和随机。

增强扩散效果：

异或运算可以将高阶位和低阶位的信息混合在一起，从而增强哈希值的扩散效果。这有助于防止哈希冲突，提高哈希函数的质量。

为什么选择高低 16 位进行异或？

字长的一半：

对于 32 位整数，高低 16 位正好是字长的一半。这样可以充分利用整个字长，同时避免了不必要的复杂性。
选择 16 位是因为 16 是一个合理的中间值，既不是太小也不是太大，可以很好地混合高低位信息。

性能考虑：

16 位的位数适中，可以在性能和效果之间取得良好的平衡。如果位数太少，可能不足以充分混合信息；如果位数太多，可能会增加计算复杂度。

经验选择：

在实际应用中，高低 16 位异或已经被证明是一种有效的哈希函数优化方法。许多成熟的哈希函数（如 Jenkins Hash Function）都采用了这种方法。

### 10.为什么 HashMap 的容量是 2 的倍数呢？hashCode 对数组长度取模定位数组下标的优化策略？

哈希值计算：

HashMap 使用哈希码来确定元素存储的位置。哈希码通过与数组长度进行取模运算 (%) 来计算出元素在数组中的位置。
当数组长度是 2 的幂次方时，取模运算可以简化为位运算。具体来说，hash % capacity 可以简化为 hash & (capacity - 1)。这是因为当 capacity 是 2 的幂次方时，capacity - 1 将会是一个二进制数，其低位全部为 1，高位为 0。因此，hash & (capacity - 1) 实际上是保留了 hash 的低位部分，这比传统的取模运算更快。

减少哈希碰撞：

如果 HashMap 的容量是 2 的幂次方，那么哈希值的分布会更加均匀，从而减少了哈希碰撞的概率。这是因为位运算的结果依赖于哈希值的低位，如果低位分布均匀，则可以更好地分散元素，减少碰撞。

扩容时的重新哈希：

当 HashMap 的容量需要扩展时，如果新的容量仍然是 2 的幂次方，那么重新哈希的过程也会更加均匀。这是因为新的容量与旧的容量之间存在倍数关系，可以使得元素在新的数组中重新分布，减少由于扩容带来的碰撞。

硬件优化：

在现代计算机体系结构中，位运算通常比算术运算（如除法和取模）更快。因此，使用位运算来替代取模运算可以带来性能上的优势。

### 11.map 集合在使用时候一般都需要写容量值？为什么要写？扩容机制？

在使用 Java 中的 HashMap 时，通常会在创建 HashMap 实例时指定初始容量。这是因为 HashMap 的性能很大程度上取决于它的容量大小。指定合适的初始容量可以帮助避免不必要的扩容操作，从而提高程序的性能。

**为什么需要指定容量**  

1. 减少扩容次数：当 HashMap 的容量达到阈值时，会触发一次扩容操作。如果 HashMap 的容量过大，那么每次扩容都需要重新计算哈希值，这可能会导致不必要的性能开销。通过指定合适的初始容量，可以减少扩容操作的次数，提高 HashMap 的性能。

2. 减少哈希碰撞：如果 HashMap 的容量过小，可能会导致哈希碰撞（即两个不同的键计算出相同的哈希值）。这会导致在 HashMap 中存在多个键映射到同一个位置，从而导致查找和插入操作的时间复杂度提高。通过指定合适的初始容量，可以减少哈希碰撞，提高 HashMap 的性能。

3. 减少内存占用：当 HashMap 的容量过大时，可能会导致 HashMap 的内存占用过多。通过指定合适的初始容量，可以减少 HashMap 的内存占用，提高 HashMap 的性能。

**扩容机制**  

HashMap 的默认初始容量是 16，而且容量总是 2 的幂次方。当 HashMap 中的元素数量超过了当前容量与加载因子（默认为 0.75）的乘积时，就会触发扩容操作。扩容时，HashMap 会创建一个新的数组，其容量通常是原来的两倍，并将原有数组中的所有元素重新散列并放入新的数组中。

### 12.红黑树转回链表的阈值为什么默认是6而不是8？

因为如果这个阈值也设置成 8，假如发生碰撞，节点增减刚好在 8 附近，会发生链表和红黑树的不断转换，导致资源浪费。

### 13.JDK8对HashMap的实现原理做了哪些优化？

1. 底层数据结构由数组 + 链表改成了数组 + 链表或红黑树的结构。

原因：如果多个键映射到了同一个哈希值，链表会变得很长，在最坏的情况下，当所有的键都映射到同一个桶中时，性能会退化到 O(n)，而红黑树的时间复杂度是 O(logn)。

2.链表的插入方式由头插法改为了尾插法。

原因：头插法虽然简单快捷，但扩容后容易改变原来链表的顺序。

3.扩容的时机由插入时判断改为插入后判断。

原因：可以避免在每次插入时都进行不必要的扩容检查，因为有可能插入后仍然不需要扩容。

4.优化了哈希算法

JDK 7 进行了多次移位和异或操作来计算元素的哈希值。JDK 8 优化了这个算法，只进行了一次异或操作，但仍然能有效地减少冲突。并且能够保证扩容后，元素的新位置要么是原位置，要么是原位置加上旧容量大小。

### 14.HashMap和TreeMap的区别？

1.HashMap 是基于数组+链表+红黑树实现的，put 元素的时候会先计算 key 的哈希值，然后通过哈希值计算出数组的索引，然后将元素插入到数组中，如果发生哈希冲突，会使用链表来解决，如果链表长度大于 8，会转换为红黑树。

get 元素的时候同样会先计算 key 的哈希值，然后通过哈希值计算出数组的索引，如果遇到链表或者红黑树，会通过 key 的 equals 方法来判断是否是要找的元素。

2.TreeMap 是基于红黑树实现的，put 元素的时候会先判断根节点是否为空，如果为空，直接插入到根节点，如果不为空，会通过 key 的比较器来判断元素应该插入到左子树还是右子树。

get 元素的时候会通过 key 的比较器来判断元素的位置，然后递归查找。

由于 HashMap 是基于哈希表实现的，所以在没有发生哈希冲突的情况下，HashMap 的查找效率是 O(1)。适用于查找操作比较频繁的场景。

而 TreeMap 是基于红黑树实现的，所以 TreeMap 的查找效率是 O(logn)。并且保证了元素的顺序，因此适用于需要大量范围查找或者有序遍历的场景。

## Java并发编程

### 1.你对线程安全的理解是什么？

线程安全是并发编程中一个重要的概念，如果一段代码块或者一个方法在多线程环境中被多个线程同时执行时能够正确地处理共享数据，那么这段代码块或者方法就是线程安全的。

可以从三个要素来确保线程安全：

①、原子性：确保当某个线程修改共享变量时，没有其他线程可以同时修改这个变量，即这个操作是不可分割的。

②、可见性：确保一个线程对共享变量的修改可以立即被其他线程看到。

③、活跃性问题：要确保线程不会因为死锁、饥饿、活锁等问题导致无法继续执行。

### 2.线程和进程的区别？

**定义**  

进程：进程是操作系统中程序的一次执行实例，它是系统进行资源分配和调度的基本单位。每个进程都有独立的地址空间和其他资源（如文件句柄、环境变量等）。

线程：线程是进程内的一个执行流，它是处理器调度和分派的基本单位。同一进程内的线程共享该进程的地址空间和资源。

**资源占用**  

进程拥有独立的内存空间，因此每个进程都有自己的数据段、堆栈段和代码段等，这意味着进程间的资源是隔离的。

线程共享所属进程的数据段、堆栈段和代码段等资源，因此创建线程比创建进程消耗更少的资源。

**上下文切换开销**  

进程间的上下文切换涉及到更多的资源转移和保护，因此开销较大。

线程间的上下文切换仅需保存和恢复少量寄存器值及栈指针，因此开销较小。

**通信方式**  

进程间通信（IPC）通常需要通过操作系统提供的机制来实现，如管道、消息队列、共享内存等，这增加了通信的复杂度。

线程可以直接访问同一进程内的全局变量或数据结构，因此线程间的通信更为简单直接。

**生命周期管理**  

进程的创建和销毁涉及更多资源的初始化和清理工作，因此相对于线程来说更加耗时。

线程的生命周期管理较为轻量级，创建和销毁速度快。

**依赖关系**  

线程依赖于进程的存在，没有进程就没有线程。进程是独立的执行环境，可以不依赖其他进程单独存在。

### 3.线程共享内存和进程共享内存的区别？

#### 进程共享内存

**共享范围**  

不同进程之间默认情况下是不共享内存的，每个进程都有自己的独立地址空间。进程间的内存共享需要通过特定的技术手段实现，例如通过共享内存段、映射文件等方式。

**通信复杂度**  

进程间通信（IPC）通常需要通过操作系统提供的机制来实现，如管道、消息队列、共享内存、套接字等。这些机制比线程间的直接内存访问要复杂得多。

**数据一致性**  

由于进程间通信需要通过特定的通道进行，因此在设计上更容易实现数据的一致性和安全性。

**资源开销**  

创建进程的资源开销相对较大，因为每个进程都需要自己的虚拟地址空间和系统资源（如文件句柄、环境变量等）。

#### 线程共享内存

**共享范围**  

同一进程内的所有线程共享该进程的整个地址空间，包括代码段、数据段、堆和栈等。

**通信复杂度**  

线程之间的通信非常简单，因为它们可以直接访问同一进程内的全局变量或其他数据结构，无需复杂的同步机制。

**数据一致性**  

虽然共享内存简化了线程间的通信，但也带来了数据一致性和同步的问题，需要通过锁机制（如互斥锁、信号量等）来保证数据访问的原子性和一致性。

**资源开销**  

创建线程的资源开销相对较小，因为不需要额外的内存空间分配，只需为每个线程维护一个栈和一些控制信息即可。

### 4.有多少种实现线程的方式？

**继承Thread类**  

```java
class ThreadTask extends Thread {
    public void run() {
        System.out.println("继承Thread类");
    }

    public static void main(String[] args) {
        ThreadTask task = new ThreadTask();
        task.start();
    }
}
```

直接继承Thread类，并重写其run方法。这种方式简单直观，但因为Java不支持多重继承，所以如果需要继承其他类，则不能使用这种方法。

**实现Runnable接口**  

```java
class RunnableTask implements Runnable {
    public void run() {
        System.out.println("实现Runnable接口");
    }

    public static void main(String[] args) {
        RunnableTask task = new RunnableTask();
        Thread thread = new Thread(task);
        thread.start();
    }
}
```

实现Runnable接口并重写run方法，然后将这个对象传递给Thread类的构造函数创建线程。这种方式更灵活，因为它允许类继承其他类的同时实现多线程功能。

**实现Callable接口配合FutureTask使用**  

```java
class CallableTask implements Callable<String> {
    public String call() {
        return "实现Callable接口";
    }

    public static void main(String[] args) throws ExecutionException, InterruptedException {
        CallableTask task = new CallableTask();
        FutureTask<String> futureTask = new FutureTask<>(task);
        Thread thread = new Thread(futureTask);
        thread.start();
        System.out.println(futureTask.get());
    }
}
```

Callable接口类似于Runnable，不同之处在于Callable的call方法可以返回结果，并且可以抛出异常。通过FutureTask包装Callable对象，然后将其传递给Thread类创建线程。这种方式适合需要返回结果的任务。

**使用Executor框架和线程池**  

[线程池的应用](#6讲一讲你对线程池的理解并讲一讲使用的场景)

### 5.为什么在项目中使用线程池？

1、频繁地创建和销毁线程会消耗系统资源，线程池能够复用已创建的线程。

2、提高响应速度，当任务到达时，任务可以不需要等待线程创建就立即执行。

3、线程池支持定时执行、周期性执行、单线程执行和并发数控制等功能。

### 6.讲一讲你对线程池的理解，并讲一讲使用的场景

#### 线程池的概念

线程池是一种管理线程的技术，它预先创建一组线程，并将它们组织在一起，以便能够高效地处理多个任务。线程池的核心思想是复用已创建的线程，而不是每次任务到来时都创建新的线程。

#### 线程池的基本组成

核心线程数（Core Pool Size）：线程池中始终维持的最小线程数。

最大线程数（Maximum Pool Size）：线程池中允许的最大线程数。

工作队列（Work Queue）：用来存储等待执行的任务。

拒绝策略（Rejection Policy）：当线程池无法接收更多任务时采取的策略。

线程工厂（Thread Factory）：用于创建新线程的对象。

**Java中线程池的主要参数**  

①、corePoolSize

定义了线程池中的核心线程数量。即使这些线程处于空闲状态，它们也不会被回收。这是线程池保持在等待状态下的线程数。

②、maximumPoolSize

线程池允许的最大线程数量。当工作队列满了之后，线程池会创建新线程来处理任务，直到线程数达到这个最大值。

③、keepAliveTime

非核心线程的空闲存活时间。如果线程池中的线程数量超过了 corePoolSize，那么这些多余的线程在空闲时间超过 keepAliveTime 时会被终止。

④、unit

keepAliveTime 参数的时间单位：

TimeUnit.DAYS; 天
TimeUnit.HOURS; 小时
TimeUnit.MINUTES; 分钟
TimeUnit.SECONDS; 秒
TimeUnit.MILLISECONDS; 毫秒
TimeUnit.MICROSECONDS; 微秒
TimeUnit.NANOSECONDS; 纳秒
⑤、workQueue

用于存放待处理任务的阻塞队列。当所有核心线程都忙时，新任务会被放在这个队列里等待执行。

⑥、threadFactory

一个创建新线程的工厂。它用于创建线程池中的线程。可以通过自定义 ThreadFactory 来给线程池中的线程设置有意义的名字，或设置优先级等。

⑦、handler

拒绝策略 RejectedExecutionHandler，定义了当线程池和工作队列都满了之后对新提交的任务的处理策略。常见的拒绝策略包括抛出异常、直接丢弃、丢弃队列中最老的任务、由提交任务的线程来直接执行任务等。

#### 线程池的工作流程

1.任务提交：当一个任务提交到线程池时，线程池会尝试分配一个线程来执行该任务。

2.核心线程数：如果当前活动线程少于核心线程数，即使有空闲线程，也会创建新的线程来执行任务。

3.工作队列：如果当前活动线程等于核心线程数，但还有任务需要执行，那么这些任务会被放入工作队列中等待执行。

4.最大线程数：如果工作队列已满，线程池会尝试创建新的线程，直到达到最大线程数。

5.拒绝策略：如果线程池已经达到最大线程数且工作队列已满，线程池将根据拒绝策略处理新任务。

#### 线程池的拒绝策略

**AbortPolicy：**

这是默认的拒绝策略。当线程池无法接受新任务时，它会抛出一个RejectedExecutionException异常。这通常意味着应用程序需要处理这个异常，并可能需要采取补救措施，比如记录日志或者通知管理员。

**CallerRunsPolicy：**

当线程池无法接受新任务时，这个策略会让调用者所在的线程来运行这个任务。如果调用者的线程本身已经在执行其他任务，那么可能会导致调用者线程的阻塞。*这种策略适合于并发度不高、性能要求不是特别高的场景。*

**DiscardPolicy：**

当线程池无法接受新任务时，这个策略会直接丢弃任务而不执行它，也不会抛出异常。*这种策略适用于那些可以容忍任务丢失的场景。*

**DiscardOldestPolicy：**

当线程池无法接受新任务时，这个策略会首先丢弃队列中最旧的任务，然后尝试再次提交新任务。*这种策略有助于优先处理最新的任务，但可能导致某些任务永远无法被执行。*

**自定义拒绝策略**  

除了这些内置的拒绝策略之外，还可以通过实现RejectedExecutionHandler接口来自定义拒绝策略，以适应特定的应用需求。

#### 线程池的阻塞队列

**ArrayBlockingQueue：**

一个由数组结构组成的有界阻塞队列。

按照先进先出（FIFO）排序元素。

是LinkedBlockingQueue的一个替代品，当需要一个容量固定的队列时使用。

**LinkedBlockingQueue：**

一个基于链表结构的阻塞队列，吞吐量通常要高于ArrayBlockingQueue。

默认情况下是无界的，但是可以通过构造函数指定队列长度。

适用于需要一个具有较高吞吐量的无界或有限阻塞队列的情况

**PriorityBlockingQueue：**

一个具有优先级的无界阻塞队列。

支持优先级排序的功能，可以按照优先级来决定哪个任务先被执行。

适用于需要根据任务优先级来调度执行的任务队列。

**DelayQueue：**

一个使用Delayed元素的无界阻塞队列。

队列中的元素只有在其延迟过期后才能被消费者线程获取。

适用于需要延迟执行的任务。

**SynchronousQueue：**

一个不存储元素的阻塞队列。

每个插入操作必须等待另一个线程的相应移除操作，反之亦然。

适用于传递元素，而不是存储元素的情况，通常用于实现生产者-消费者模型。

#### 线程池的提交

**execute(Runnable command)**  

```java
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class ThreadPoolExample {
    public static void main(String[] args) {
        // 创建线程池
        ExecutorService executor = Executors.newFixedThreadPool(5);

        // 提交任务
        for (int i = 0; i < 10; i++) {
            int taskId = i;
            executor.execute(() -> {
                System.out.println("Task " + taskId + " is running on thread " + Thread.currentThread().getName());
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
            });

            // 关闭线程池
            executor.shutdown();
            try {
                if (!executor.awaitTermination(1, TimeUnit.MINUTES)) {
                    executor.shutdownNow();
                }
            } catch (InterruptedException e) {
                executor.shutdownNow();
                Thread.currentThread().interrupt();
            }
        }
    }
}
```

execute方法用于提交一个Runnable任务，是最基本的提交方式。它没有返回值，也不支持获取任务执行结果。

**submit(Runnable task)**  

```java
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;

public class ThreadPoolExample {
    public static void main(String[] args) {
        // 创建线程池
        ExecutorService executor = Executors.newFixedThreadPool(5);

        // 提交任务
        for (int i = 0; i < 10; i++) {
            int taskId = i;
            Future<?> future = executor.submit(() -> {
                System.out.println("Task " + taskId + " is running on thread " + Thread.currentThread().getName());
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
            });

            // 关闭线程池
            executor.shutdown();
            try {
                if (!executor.awaitTermination(1, TimeUnit.MINUTES)) {
                    executor.shutdownNow();
                }
            } catch (InterruptedException e) {
                executor.shutdownNow();
                Thread.currentThread().interrupt();
            }
        }
    }
}
```

submit方法用于提交一个Runnable任务，并返回一个Future对象，可以用来获取任务的执行状态和结果。

#### 线程池的关闭

可以通过调用线程池的shutdown或shutdownNow方法来关闭线程池。它们的原理是遍历线程池中的工作线程，然后逐个调用线程的 interrupt 方法来中断线程，所以无法响应中断的任务可能永远无法终止。

**shutdown() 将线程池状态置为 shutdown,并不会立即停止：**

停止接收外部 submit 的任务
内部正在跑的任务和队列里等待的任务，会执行完
等到第二步完成后，才真正停止

**shutdownNow() 将线程池状态置为 stop。一般会立即停止，事实上不一定：**

和 shutdown()一样，先停止接收外部提交的任务
忽略队列里等待的任务
尝试将正在跑的任务 interrupt 中断
返回未执行的任务列表

shutdown 和 shutdownnow 简单来说区别如下：

shutdownNow()能立即停止线程池，正在跑的和正在等待的任务都停下了。这样做立即生效，但是风险也比较大。

shutdown()只是关闭了提交通道，用 submit()是无效的；而内部的任务该怎么跑还是怎么跑，跑完再彻底停止线程池。

#### 线程池的线程数配置

①、对于 CPU 密集型任务，我的目标是尽量减少线程上下文切换，以优化 CPU 使用率。一般来说，*核心线程数设置为处理器的核心数或核心数加一*（以备不时之需，如某些线程因等待系统资源而阻塞时）是较理想的选择。

②、对于 IO 密集型任务，由于线程经常处于等待状态（等待 IO 操作完成），可以*设置更多的线程来提高并发性（比如说 2 倍）*，从而增加 CPU 利用率。

#### 线程池的种类

**newFixedThreadPool (固定线程数目的线程池)**  

```java
public static ExecutorService newFixedThreadPool(int nThreads, ThreadFactory threadFactory) {
    return new ThreadPoolExecutor(nThreads, nThreads,
                                  0L, TimeUnit.MILLISECONDS,
                                  new LinkedBlockingQueue<Runnable>(),
                                  threadFactory);
}
```

**线程池特点**  

核心线程数和最大线程数大小一样

没有所谓的非空闲时间，即 keepAliveTime 为 0

阻塞队列为无界队列 LinkedBlockingQueue，可能会导致 OOM

**工作流程**  

提交任务

如果线程数少于核心线程，创建核心线程执行任务

如果线程数等于核心线程，把任务添加到 LinkedBlockingQueue 阻塞队列

如果线程执行完任务，去阻塞队列取任务，继续执行。

**适用场景**  

FixedThreadPool 适用于处理 CPU 密集型的任务，确保 CPU 在长期被工作线程使用的情况下，尽可能的少的分配线程，即适用执行长期的任务。

**newCachedThreadPool (可缓存线程的线程池)**  

```java
public static ExecutorService newCachedThreadPool(ThreadFactory threadFactory) {
    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                  60L, TimeUnit.SECONDS,
                                  new SynchronousQueue<Runnable>(),
                                  threadFactory);
}
```

**线程池特点**  

核心线程数为 0

最大线程数为 Integer.MAX_VALUE，即无限大，可能会因为无限创建线程，导致 OOM

阻塞队列是 SynchronousQueue

非核心线程空闲存活时间为 60 秒

当提交任务的速度大于处理任务的速度时，每次提交一个任务，就必然会创建一个线程。极端情况下会创建过多的线程，耗尽 CPU 和内存资源。由于空闲 60 秒的线程会被终止，长时间保持空闲的 CachedThreadPool 不会占用任何资源。

**工作流程**  

提交任务

因为没有核心线程，所以任务直接加到 SynchronousQueue 队列。

判断是否有空闲线程，如果有，就去取出任务执行。

如果没有空闲线程，就新建一个线程执行。

执行完任务的线程，还可以存活 60 秒，如果在这期间，接到任务，可以继续活下去；否则，被销毁。

**适用场景**  

用于并发执行大量短期的小任务。

**newSingleThreadExecutor (单线程的线程池)**  

```java
public static ExecutorService newSingleThreadExecutor(ThreadFactory threadFactory) {
    return new FinalizableDelegatedExecutorService
        (new ThreadPoolExecutor(1, 1,
                                0L, TimeUnit.MILLISECONDS,
                                new LinkedBlockingQueue<Runnable>(),
                                threadFactory));
}
```

**线程池特点**  

核心线程数为 1

最大线程数也为 1

阻塞队列是无界队列 LinkedBlockingQueue，可能会导致 OOM

keepAliveTime 为 0

**工作流程**  

提交任务

线程池是否有一条线程在，如果没有，新建线程执行任务

如果有，将任务加到阻塞队列

当前的唯一线程，从队列取任务，执行完一个，再继续取，一个线程执行任务。

**适用场景**  

适用于串行执行任务的场景，一个任务一个任务地执行。

**newScheduledThreadPool (定时及周期执行的线程池)**  

```java
public ScheduledThreadPoolExecutor(int corePoolSize) {
    super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS,
          new DelayedWorkQueue());
}
```

**线程池特点**  

最大线程数为 Integer.MAX_VALUE，也有 OOM 的风险

阻塞队列是 DelayedWorkQueue

keepAliveTime 为 0

scheduleAtFixedRate() ：按某种速率周期执行

scheduleWithFixedDelay()：在某个延迟后执行

**工作机制**  

线程从 DelayQueue 中获取已到期的 ScheduledFutureTask（DelayQueue.take()）。到期任务是指 ScheduledFutureTask 的 time 大于等于当前时间。

线程执行这个 ScheduledFutureTask。

线程修改 ScheduledFutureTask 的 time 变量为下次将要被执行的时间。

线程把这个修改 time 之后的 ScheduledFutureTask 放回 DelayQueue 中（DelayQueue.add()）。

**适用场景**  

周期性执行任务的场景，需要限制线程数量的场景

#### 线程池异常处理

1.try-catch 捕获异常

2.submit执行，Feture.get接受异常

3.重写ThreadPoolExecutor.afterExecute方法,处理传递的异常引用

4.实例化时，传入自己的ThreadFactory，设置Thread.UncaughtExceptionHandler处理未检测的异常

#### 线程池的状态

ThreadPoolExecutor 类使用一个名为 ctl 的原子变量来存储线程池的状态信息。这个变量是一个 long 类型的值，其中一部分位用于表示线程池的状态，另一部分位用于表示线程池中的活动线程数。ctl 变量的低三位用于表示线程池的状态，共有四种状态：

**RUNNING**  

该状态的线程池会接收新任务，并处理阻塞队列中的任务;

调用线程池的 shutdown()方法，可以切换到 SHUTDOWN 状态;

调用线程池的 shutdownNow()方法，可以切换到 STOP 状态;

这是线程池的初始状态

**SHUTDOWN**  

该状态的线程池不会接收新任务，但会处理阻塞队列中的任务；

队列为空，并且线程池中执行的任务也为空,进入 TIDYING 状态;

**STOP**  

该状态的线程不会接收新任务，也不会处理阻塞队列中的任务，而且会中断正在运行的任务；

线程池中执行的任务为空,进入 TIDYING 状态;

**TIDYING**  

该状态表明所有的任务已经运行终止，记录的任务数量为 0。

terminated()执行完毕，进入 TERMINATED 状态

当最后一个任务完成后，线程池会进入 TIDYING 状态。

**TERMINATED**  

线程池已经完成所有清理工作，处于终止状态。

#### 线程池对参数的动态修改

在我们微服务的架构下，可以利用配置中心如 Nacos、Apollo 等等，也可以自己开发配置中心。业务服务读取线程池配置，获取相应的线程池实例来修改线程池的参数。

如果限制了配置中心的使用，也可以自己去扩展ThreadPoolExecutor，重写方法，监听线程池参数变化，来动态修改线程池参数。

### 7. 线程池在使用时需要注意什么？

①、**选择合适的线程池大小**

过小的线程池可能会导致任务一直在排队

过大的线程池可能会导致大家都在竞争 CPU 资源，增加上下文切换的开销

可以根据业务是 IO 密集型还是 CPU 密集型来选择线程池大小：

CPU 密集型：指的是任务主要使用来进行大量的计算，没有什么导致线程阻塞。一般这种场景的线程数设置为 CPU 核心数+1。

IO 密集型：当执行任务需要大量的 io，比如磁盘 io，网络 io，可能会存在大量的阻塞，所以在 IO 密集型任务中使用多线程可以大大地加速任务的处理。一般线程数设置为 2*CPU 核心数。

②、**任务队列的选择**

使用有界队列可以避免资源耗尽的风险，但是可能会导致任务被拒绝

使用无界队列虽然可以避免任务被拒绝，但是可能会导致内存耗尽

一般需要设置有界队列的大小，比如 LinkedBlockingQueue 在构造的时候可以传入参数来限制队列中任务数据的大小，这样就不会因为无限往队列中扔任务导致系统的 oom。

③、**尽量使用自定义的线程池**，而不是使用 Executors 创建的线程池，因为 newFixedThreadPool 线程池由于使用了 LinkedBlockingQueue，队列的容量默认无限大，实际使用中出现任务过多时会导致内存溢出；

newCachedThreadPool 线程池由于核心线程数无限大，当任务过多的时候会导致创建大量的线程，可能机器负载过高导致服务宕机。

### 8.你能设计并实现一个线程池吗？

**核心流程**：

线程池中有 N 个工作线程

把任务提交给线程池运行

如果线程池已满，把任务放入队列

最后当有空闲时，获取队列中任务来执行

**代码示例**：

```java
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;

public class SimpleThreadPool {

    private final BlockingQueue<Runnable> workQueue;
    private final int corePoolSize;
    private final int maximumPoolSize;
    private final long keepAliveTime;
    private final TimeUnit unit;
    private volatile boolean isShutdown = false;

    private final AtomicInteger activeThreads = new AtomicInteger(0);
    private final ThreadFactory threadFactory;

    public SimpleThreadPool(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, ThreadFactory threadFactory) {
        this.corePoolSize = corePoolSize;
        this.maximumPoolSize = maximumPoolSize;
        this.keepAliveTime = keepAliveTime;
        this.unit = unit;
        this.threadFactory = threadFactory;
        this.workQueue = new LinkedBlockingQueue<>();
    }

    public void execute(Runnable command) {
        if (isShutdown) {
            throw new IllegalStateException("Executor has been shutdown");
        }

        // 尝试将任务放入队列
        if (workQueue.offer(command)) {
            addWorker();
        } else {
            // 队列已满，尝试创建新线程
            startWorker(command);
        }
    }

    private void addWorker() {
        if (activeThreads.get() < corePoolSize) {
            startWorker(null);
        }
    }

    private void startWorker(Runnable firstTask) {
        Thread worker = threadFactory.newThread(new Worker(firstTask));
        worker.start();
    }

    private class Worker implements Runnable {
        private Runnable currentTask;

        public Worker(Runnable firstTask) {
            this.currentTask = firstTask;
        }

        @Override
        public void run() {
            if (currentTask != null) {
                try {
                    currentTask.run();
                } finally {
                    currentTask = null;
                }
            }

            while (!isShutdown) {
                try {
                    currentTask = workQueue.take();
                    currentTask.run();
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                    break;
                } catch (RuntimeException e) {
                    // 处理异常
                    handleException(e);
                }
            }

            activeThreads.decrementAndGet();
        }
    }

    private void handleException(RuntimeException e) {
        System.err.println("Caught exception: " + e.getMessage());
        e.printStackTrace();
    }

    public void shutdown() {
        isShutdown = true;
        // 中断所有空闲线程
        interruptIdleWorkers();
    }

    private void interruptIdleWorkers() {
        for (int i = 0; i < activeThreads.get(); i++) {
            Thread worker = new Thread(() -> {});
            worker.interrupt();
        }
    }

    public static void main(String[] args) {
        SimpleThreadPool executor = new SimpleThreadPool(5, 10, 60, TimeUnit.SECONDS, new CustomThreadFactory("MyThread"));

        for (int i = 0; i < 20; i++) {
            int taskId = i;
            executor.execute(() -> {
                System.out.println("Processing task " + taskId);
                try {
                    Thread.sleep(1000);  // 模拟任务执行时间
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                    System.out.println("Task interrupted");
                }
            });
        }

        // 关闭线程池
        executor.shutdown();
    }
}

class CustomThreadFactory implements ThreadFactory {
    private final AtomicInteger threadNumber = new AtomicInteger(1);
    private final String namePrefix;

    public CustomThreadFactory(String namePrefix) {
        this.namePrefix = namePrefix;
    }

    @Override
    public Thread newThread(Runnable r) {
        Thread t = new Thread(r, namePrefix + threadNumber.getAndIncrement());
        t.setUncaughtExceptionHandler((thread, throwable) -> {
            System.out.println("Caught exception in thread " + thread.getName() + ": " + throwable.getMessage());
            throwable.printStackTrace();
        });
        return t;
    }
}
```
