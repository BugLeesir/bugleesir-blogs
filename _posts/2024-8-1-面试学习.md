---
layout: article
title: 面试题目
---

<!-- TOC -->

- [Java集合框架](#java集合框架)
  - [1.阻塞队列的阻塞是什么含义？](#1阻塞队列的阻塞是什么含义)
  - [2.阻塞队列的实现方式？](#2阻塞队列的实现方式)
  - [3.线程不安全的集合变成线程安全的方法？](#3线程不安全的集合变成线程安全的方法)
  - [4.HashMap的底层数据结构?](#4hashmap的底层数据结构)
  - [5.为什么 HashMap 是线程不安全的？](#5为什么-hashmap-是线程不安全的)
  - [6.平衡二叉树](#6平衡二叉树)
    - [AVL 树](#avl-树)
    - [红黑树](#红黑树)
  - [7.HashMap 的 put 流程](#7hashmap-的-put-流程)
  - [8.只重写 equals 没重写 hashcode，map put 的时候会发生什么?](#8只重写-equals-没重写-hashcodemap-put-的时候会发生什么)
  - [9.为什么要用高低做异或运算？为什么非得高低 16 位异或？](#9为什么要用高低做异或运算为什么非得高低-16-位异或)
  - [10.为什么 HashMap 的容量是 2 的倍数呢？hashCode 对数组长度取模定位数组下标的优化策略？](#10为什么-hashmap-的容量是-2-的倍数呢hashcode-对数组长度取模定位数组下标的优化策略)
  - [11.map 集合在使用时候一般都需要写容量值？为什么要写？扩容机制？](#11map-集合在使用时候一般都需要写容量值为什么要写扩容机制)
  - [12.红黑树转回链表的阈值为什么默认是6而不是8？](#12红黑树转回链表的阈值为什么默认是6而不是8)
  - [13.JDK8对HashMap的实现原理做了哪些优化？](#13jdk8对hashmap的实现原理做了哪些优化)
  - [14.HashMap和TreeMap的区别？](#14hashmap和treemap的区别)
- [Java并发编程](#java并发编程)
  - [1.你对线程安全的理解是什么？](#1你对线程安全的理解是什么)
  - [2.线程和进程的区别？](#2线程和进程的区别)
  - [3.线程共享内存和进程共享内存的区别？](#3线程共享内存和进程共享内存的区别)
    - [进程共享内存](#进程共享内存)
    - [线程共享内存](#线程共享内存)
  - [4.有多少种实现线程的方式？](#4有多少种实现线程的方式)
  - [5.为什么在项目中使用线程池？](#5为什么在项目中使用线程池)
  - [6.讲一讲你对线程池的理解，并讲一讲使用的场景](#6讲一讲你对线程池的理解并讲一讲使用的场景)
    - [线程池的概念](#线程池的概念)
    - [线程池的基本组成](#线程池的基本组成)
    - [线程池的工作流程](#线程池的工作流程)
    - [线程池的拒绝策略](#线程池的拒绝策略)
    - [线程池的阻塞队列](#线程池的阻塞队列)
    - [线程池的提交](#线程池的提交)
    - [线程池的关闭](#线程池的关闭)
    - [线程池的线程数配置](#线程池的线程数配置)
    - [线程池的种类](#线程池的种类)
    - [线程池异常处理](#线程池异常处理)
    - [线程池的状态](#线程池的状态)
    - [线程池对参数的动态修改](#线程池对参数的动态修改)
  - [7. 线程池在使用时需要注意什么？](#7-线程池在使用时需要注意什么)
  - [8.你能设计并实现一个线程池吗？](#8你能设计并实现一个线程池吗)
  - [9.调用 start()方法时会执行 run()方法，那怎么不直接调用 run()方法？](#9调用-start方法时会执行-run方法那怎么不直接调用-run方法)
  - [10.线程有哪些常用的调度方法？](#10线程有哪些常用的调度方法)
  - [11.线程的生命周期和状态？](#11线程的生命周期和状态)
  - [12.什么是线程的上下文切换？](#12什么是线程的上下文切换)
  - [13.守护线程了解吗？](#13守护线程了解吗)
  - [14.线程间的通信方式？](#14线程间的通信方式)
  - [15.sleep 和 wait 的区别？](#15sleep-和-wait-的区别)
  - [16.举例一个线程安全的使用场景？](#16举例一个线程安全的使用场景)
  - [17.请说一下 ThreadLocal 的作用和使用场景？](#17请说一下-threadlocal-的作用和使用场景)
    - [ThreadLocal是什么？](#threadlocal是什么)
    - [ThreadLocal 的工作原理](#threadlocal-的工作原理)
    - [ThreadLocal 的使用场景](#threadlocal-的使用场景)
    - [ThreadLocal 的使用步骤](#threadlocal-的使用步骤)
  - [18.除了 ThreadLocal，还有什么解决线程安全问题的方法？](#18除了-threadlocal还有什么解决线程安全问题的方法)
  - [19.ThreadLocal 怎么实现的呢？](#19threadlocal-怎么实现的呢)
  - [20.java中的引用类型？](#20java中的引用类型)
    - [强引用（Strong Reference）](#强引用strong-reference)
    - [软引用（Soft Reference）](#软引用soft-reference)
    - [弱引用（Weak Reference）](#弱引用weak-reference)
    - [虚引用（Phantom Reference）](#虚引用phantom-reference)
  - [21.ThreadLocal内存泄漏是怎么回事？](#21threadlocal内存泄漏是怎么回事)
  - [22.ThreadLocal结合线程池使用导致的复用问题？](#22threadlocal结合线程池使用导致的复用问题)
  - [23.ThreadLocal的删除过程？](#23threadlocal的删除过程)
  - [24.ThreadLocalMap的源码分析？](#24threadlocalmap的源码分析)
  - [25.ThreadLocalMap如何解决Hash冲突？](#25threadlocalmap如何解决hash冲突)
  - [26.ThreadLocalMap的扩容？](#26threadlocalmap的扩容)
  - [27.父子线程怎么共享数据？](#27父子线程怎么共享数据)
  - [28.为什么线程要使用自己的内存？](#28为什么线程要使用自己的内存)
  - [29.对原子性、可见性、有序性的理解？](#29对原子性可见性有序性的理解)
  - [30.什么是指令重排？](#30什么是指令重排)
    - [指令重排的原因](#指令重排的原因)
    - [指令重排的类型](#指令重排的类型)
    - [指令重排对多线程程序的影响](#指令重排对多线程程序的影响)
    - [避免指令重排的方法](#避免指令重排的方法)
    - [指令重排的限制](#指令重排的限制)
  - [31.volatile关键字的实现原理？](#31volatile关键字的实现原理)
  - [32.volatile加在基本类型和对象上的区别？](#32volatile加在基本类型和对象上的区别)
  - [33.synchronized 用过吗？怎么使用？](#33synchronized-用过吗怎么使用)
    - [synchronized 的实现原理？](#synchronized-的实现原理)
    - [Monitor 监视器](#monitor-监视器)
    - [可重入锁](#可重入锁)
    - [锁的优化](#锁的优化)
    - [锁的升级](#锁的升级)
  - [34.synchronized和ReentrantLock区别和场景？](#34synchronized和reentrantlock区别和场景)
  - [35.AQS 了解多少？](#35aqs-了解多少)
  - [36.ReentrantLock 实现原理？](#36reentrantlock-实现原理)
  - [37.ReentrantLock 怎么实现公平锁的？](#37reentrantlock-怎么实现公平锁的)
  - [38.CAS 了解多少？](#38cas-了解多少)
  - [39.CAS 有什么问题？如何解决？](#39cas-有什么问题如何解决)
    - [ABA 问题](#aba-问题)
    - [忙等待问题](#忙等待问题)
    - [只能保证单个变量的原子性](#只能保证单个变量的原子性)
  - [40.原子操作类了解多少？](#40原子操作类了解多少)
  - [41.线程死锁了解吗？该如何避免？](#41线程死锁了解吗该如何避免)
    - [死锁的必要条件](#死锁的必要条件)
    - [避免死锁的方法](#避免死锁的方法)
  - [42.死锁问题怎么排查呢？](#42死锁问题怎么排查呢)
  - [43.乐观锁和悲观锁？](#43乐观锁和悲观锁)
  - [44.CountDownLatch（倒计数器）了解吗？](#44countdownlatch倒计数器了解吗)
  - [45.CyclicBarrier（同步屏障）了解吗？](#45cyclicbarrier同步屏障了解吗)
  - [46.CyclicBarrier 和 CountDownLatch 有什么区别？](#46cyclicbarrier-和-countdownlatch-有什么区别)
  - [47.Semaphore（信号量）了解吗？](#47semaphore信号量了解吗)
  - [48.Exchanger 了解吗？](#48exchanger-了解吗)
  - [49.ConcurrentHashMap 对 HashMap 的优化？ConcurrentHashMap 1.8 比 1.7 的优化在哪里？](#49concurrenthashmap-对-hashmap-的优化concurrenthashmap-18-比-17-的优化在哪里)
  - [50.为什么 ConcurrentHashMap 在 JDK 1.7 中要用 ReentrantLock，而在 JDK 1.8 要用 synchronized？](#50为什么-concurrenthashmap-在-jdk-17-中要用-reentrantlock而在-jdk-18-要用-synchronized)
  - [51.为什么 ConcurrentHashMap 比 Hashtable 效率高](#51为什么-concurrenthashmap-比-hashtable-效率高)
    - [Hashtable 的锁机制](#hashtable-的锁机制)
    - [ConcurrentHashMap 的锁机制](#concurrenthashmap-的锁机制)
    - [JDK 1.7 中的 ConcurrentHashMap](#jdk-17-中的-concurrenthashmap)
    - [JDK 1.8 中的 ConcurrentHashMap](#jdk-18-中的-concurrenthashmap)
- [JVM](#jvm)
  - [1.什么是JVM？](#1什么是jvm)
  - [2.JVM的组织架构？](#2jvm的组织架构)
    - [1. 类加载器子系统（Class Loader Subsystem）](#1-类加载器子系统class-loader-subsystem)
    - [2. 运行时数据区（Runtime Data Area）](#2-运行时数据区runtime-data-area)
    - [3. 执行引擎（Execution Engine）](#3-执行引擎execution-engine)
    - [4. 本地方法接口（JNI - Java Native Interface）](#4-本地方法接口jni---java-native-interface)
  - [3.JVM内存结构](#3jvm内存结构)
    - [1. 方法区（Method Area）](#1-方法区method-area)
    - [2. 堆（Heap）](#2-堆heap)
    - [3. Java 栈（Java Stack）](#3-java-栈java-stack)
    - [4. 本地方法栈（Native Method Stack）](#4-本地方法栈native-method-stack)
    - [5. 程序计数器（Program Counter Register）](#5-程序计数器program-counter-register)
    - [6.内存结构图示](#6内存结构图示)
    - [6.总结-3](#6总结-3)
  - [4.说一下 JDK1.6、1.7、1.8 内存区域的变化？](#4说一下-jdk161718-内存区域的变化)
    - [JDK 1.6](#jdk-16)
    - [JDK 1.7](#jdk-17)
    - [JDK 1.8](#jdk-18)
    - [主要变化](#主要变化)
    - [配置参数变化](#配置参数变化)
    - [总结-4](#总结-4)
  - [5.JDK 1.8 中的元空间（Metaspace）相对于永久代（PermGen）的优势？](#5jdk-18-中的元空间metaspace相对于永久代permgen的优势)
    - [1. 使用本地内存](#1-使用本地内存)
    - [2. 动态调整大小](#2-动态调整大小)
    - [3. 更好的垃圾回收性能](#3-更好的垃圾回收性能)
    - [4. 减少内存泄漏风险](#4-减少内存泄漏风险)
    - [5.总结-5](#5总结-5)
  - [6.对象的创建销毁的过程？](#6对象的创建销毁的过程)
    - [对象创建](#对象创建)
    - [对象销毁](#对象销毁)
  - [7.JVM 里 new 对象时，堆会发生抢占吗？JVM 是怎么设计来保证线程安全的？](#7jvm-里-new-对象时堆会发生抢占吗jvm-是怎么设计来保证线程安全的)
    - [对象创建的线程安全机制](#对象创建的线程安全机制)
  - [8.对象的内存布局，对象的底层数据结构？](#8对象的内存布局对象的底层数据结构)
    - [1. 对象头（Header）](#1-对象头header)
    - [2. 实例数据（Instance Data）](#2-实例数据instance-data)
    - [3. 对齐填充（Padding）](#3-对齐填充padding)
    - [内存布局示意图](#内存布局示意图)
    - [总结-8](#总结-8)
  - [9.对象如何访问定位？](#9对象如何访问定位)
    - [1. 句柄访问（Handle Access）](#1-句柄访问handle-access)
    - [2. 直接指针访问（Direct Pointer Access）](#2-直接指针访问direct-pointer-access)
  - [10.说说内存溢出（OOM）和内存泄漏（Leak Memory）的原因？](#10说说内存溢出oom和内存泄漏leak-memory的原因)
    - [内存溢出是什么](#内存溢出是什么)
      - [1. 堆内存（Heap Memory）](#1-堆内存heap-memory)
      - [2. 方法区（Method Area）/元空间（Metaspace）](#2-方法区method-area元空间metaspace)
      - [3. 栈内存（Stack Memory）](#3-栈内存stack-memory)
      - [4. 直接内存（Direct Memory）](#4-直接内存direct-memory)
      - [总结-10-1](#总结-10-1)
    - [内存泄漏可能由哪些原因导致呢？](#内存泄漏可能由哪些原因导致呢)
  - [11.Java 堆的内存分区了解吗？](#11java-堆的内存分区了解吗)
    - [1. 新生代（Young Generation）](#1-新生代young-generation)
    - [2. 老年代（Old Generation）](#2-老年代old-generation)
    - [3. 永久代（PermGen）/元空间（Metaspace）](#3-永久代permgen元空间metaspace)
    - [内存分区示意图](#内存分区示意图)
    - [总结-11](#总结-11)
  - [12.对象什么时候会进入老年代？](#12对象什么时候会进入老年代)
    - [1. 对象年龄达到阈值](#1-对象年龄达到阈值)
    - [2. Survivor 区空间不足](#2-survivor-区空间不足)
    - [3. 大对象直接进入老年代](#3-大对象直接进入老年代)
    - [4. 新生代空间不足](#4-新生代空间不足)
    - [总结-12](#总结-12)
  - [13.什么是 Stop The World ? 什么是 OopMap ？什么是安全点？](#13什么是-stop-the-world--什么是-oopmap-什么是安全点)
    - [Stop The World (STW)](#stop-the-world-stw)
    - [OopMap](#oopmap)
    - [安全点（Safepoint）](#安全点safepoint)
    - [总结-13](#总结-13)
  - [14.对象一定分配在堆中吗？有没有了解逃逸分析技术？](#14对象一定分配在堆中吗有没有了解逃逸分析技术)
    - [对象一定分配在堆中吗？](#对象一定分配在堆中吗)
    - [逃逸分析（Escape Analysis）](#逃逸分析escape-analysis)
      - [逃逸分析的类型](#逃逸分析的类型)
      - [逃逸分析的优化](#逃逸分析的优化)
    - [总结-14](#总结-14)
  - [15.JVM垃圾回收机制？](#15jvm垃圾回收机制)
    - [对象回收判定](#对象回收判定)
      - [1. 引用计数法（Reference Counting）](#1-引用计数法reference-counting)
      - [2. 可达性分析法（Reachability Analysis）](#2-可达性分析法reachability-analysis)
      - [总结-15-1](#总结-15-1)
    - [垃圾回收算法](#垃圾回收算法)
      - [1. 标记-清除算法（Mark-Sweep）](#1-标记-清除算法mark-sweep)
      - [2. 复制算法（Copying）](#2-复制算法copying)
      - [3. 标记-整理算法（Mark-Compact）](#3-标记-整理算法mark-compact)
      - [4. 分代收集算法（Generational Collection）](#4-分代收集算法generational-collection)
      - [总结-15-2](#总结-15-2)
    - [垃圾回收类型](#垃圾回收类型)
      - [1. Minor GC / Young GC](#1-minor-gc--young-gc)
      - [2. Major GC / Old GC](#2-major-gc--old-gc)
      - [3. Mixed GC](#3-mixed-gc)
      - [4. Full GC](#4-full-gc)
      - [总结-15-3](#总结-15-3)
    - [垃圾收集器](#垃圾收集器)
      - [1. Serial 收集器](#1-serial-收集器)
      - [2. ParNew 收集器](#2-parnew-收集器)
      - [3. Parallel 收集器](#3-parallel-收集器)
      - [4. CMS 收集器](#4-cms-收集器)
      - [5. G1 收集器](#5-g1-收集器)
      - [6. ZGC 收集器](#6-zgc-收集器)
      - [7. Shenandoah 收集器](#7-shenandoah-收集器)
      - [总结-15-4](#总结-15-4)
  - [16.有了 CMS，为什么还要引入 G1？](#16有了-cms为什么还要引入-g1)
  - [16.有哪些常用的命令行性能监控和故障处理工具？](#16有哪些常用的命令行性能监控和故障处理工具)
  - [17.了解哪些可视化的性能监控和故障处理工具？](#17了解哪些可视化的性能监控和故障处理工具)
    - [1. VisualVM](#1-visualvm)
    - [2. JConsole](#2-jconsole)
    - [3. Java Mission Control (JMC)](#3-java-mission-control-jmc)
    - [4. Eclipse Memory Analyzer (MAT)](#4-eclipse-memory-analyzer-mat)
    - [5. Grafana + Prometheus](#5-grafana--prometheus)
    - [总结-17](#总结-17)
  - [18.JVM 的常见参数配置知道哪些？](#18jvm-的常见参数配置知道哪些)
    - [1. 内存设置参数](#1-内存设置参数)
    - [2. 垃圾回收参数](#2-垃圾回收参数)
    - [3. 性能调优参数](#3-性能调优参数)
    - [4. 调试和诊断参数](#4-调试和诊断参数)
    - [总结-18](#总结-18)
  - [19.线上服务 CPU 占用过高怎么排查？](#19线上服务-cpu-占用过高怎么排查)
    - [1. 使用操作系统工具查看 CPU 使用情况](#1-使用操作系统工具查看-cpu-使用情况)
    - [2. 使用 `jps` 和 `jstack` 查看 Java 线程的 CPU 使用情况](#2-使用-jps-和-jstack-查看-java-线程的-cpu-使用情况)
    - [3. 使用 `top` 和 `jstack` 结合分析](#3-使用-top-和-jstack-结合分析)
    - [4. 使用 `jstat` 查看垃圾回收情况](#4-使用-jstat-查看垃圾回收情况)
    - [5. 使用 `jmap` 查看内存使用情况](#5-使用-jmap-查看内存使用情况)
    - [6. 使用 `Java Mission Control` 和 `VisualVM` 进行深入分析](#6-使用-java-mission-control-和-visualvm-进行深入分析)
    - [总结-19](#总结-19)
  - [20.内存飙高问题怎么排查？](#20内存飙高问题怎么排查)
  - [21.频繁 minor gc 怎么办？](#21频繁-minor-gc-怎么办)
  - [22.频繁 Full GC 怎么办？](#22频繁-full-gc-怎么办)
    - [该怎么排查 Full GC 频繁问题？](#该怎么排查-full-gc-频繁问题)
  - [23.有没有处理过内存泄漏问题？是如何定位的？](#23有没有处理过内存泄漏问题是如何定位的)
  - [24.有没有处理过 OOM 问题？](#24有没有处理过-oom-问题)
  - [25.了解类的加载机制吗？](#25了解类的加载机制吗)
  - [26.类加载器有哪些？](#26类加载器有哪些)
    - [1. 启动类加载器（Bootstrap ClassLoader）](#1-启动类加载器bootstrap-classloader)
    - [2. 扩展类加载器（Extension ClassLoader）](#2-扩展类加载器extension-classloader)
    - [3. 应用程序类加载器（Application ClassLoader）](#3-应用程序类加载器application-classloader)
    - [4. 自定义类加载器（Custom ClassLoader）](#4-自定义类加载器custom-classloader)
    - [总结-26](#总结-26)
  - [27.能说一下类的生命周期吗？](#27能说一下类的生命周期吗)
    - [1. 加载（Loading）](#1-加载loading)
    - [2. 验证（Verification）](#2-验证verification)
    - [3. 准备（Preparation）](#3-准备preparation)
    - [4. 解析（Resolution）](#4-解析resolution)
    - [5. 初始化（Initialization）](#5-初始化initialization)
    - [6. 使用（Using）](#6-使用using)
    - [7. 卸载（Unloading）](#7-卸载unloading)
    - [总结-27](#总结-27)
  - [28.什么是双亲委派模型？](#28什么是双亲委派模型)
  - [29.为什么要用双亲委派模型？](#29为什么要用双亲委派模型)
  - [30.如何破坏双亲委派机制？](#30如何破坏双亲委派机制)
    - [示例：自定义类加载器](#示例自定义类加载器)
    - [解释](#解释)
    - [总结-30](#总结-30)
  - [31.Tomcat 的类加载机制了解吗？](#31tomcat-的类加载机制了解吗)
    - [1. 启动类加载器（Bootstrap  ClassLoader）](#1-启动类加载器bootstrap--classloader)
    - [2. 系统类加载器（System ClassLoader）](#2-系统类加载器system-classloader)
    - [3. 公共类加载器（Common ClassLoader）](#3-公共类加载器common-classloader)
    - [4. Web 应用程序类加载器（WebappClassLoader）](#4-web-应用程序类加载器webappclassloader)
    - [5. 自定义类加载器（Custom ClassLoader）](#5-自定义类加载器custom-classloader)
    - [类加载器的层次结构](#类加载器的层次结构)
    - [类加载顺序](#类加载顺序)
  - [32.你觉得应该怎么实现一个热部署功能？](#32你觉得应该怎么实现一个热部署功能)
    - [1. 监控文件变化](#1-监控文件变化)
    - [2. 卸载旧类](#2-卸载旧类)
    - [3. 加载新类](#3-加载新类)
    - [4. 重启应用](#4-重启应用)
    - [总结-32](#总结-32)
  - [33.解释执行和编译执行的区别?](#33解释执行和编译执行的区别)
    - [解释执行](#解释执行)
    - [编译执行](#编译执行)
    - [Java 的混合模式](#java-的混合模式)
    - [总结-33](#总结-33)
- [Spring](#spring)
  - [1.Spring是什么？](#1spring是什么)
    - [Spring的特性](#spring的特性)
  - [2.Spring的模块](#2spring的模块)
    - [1. 核心容器（Core Container）](#1-核心容器core-container)
    - [2. 数据访问/集成（Data Access/Integration）](#2-数据访问集成data-accessintegration)
    - [3. Web 模块（Web）](#3-web-模块web)
    - [4. 面向切面编程（Aspect-Oriented Programming, AOP）](#4-面向切面编程aspect-oriented-programming-aop)
    - [5. 消息（Messaging）](#5-消息messaging)
    - [6. 测试（Test）](#6-测试test)
    - [7. 安全（Security）](#7-安全security)
    - [8. 云（Cloud）](#8-云cloud)
    - [9. 批处理（Batch）](#9-批处理batch)
    - [10. 数据流（Data Flow）](#10-数据流data-flow)
    - [总结-1](#总结-1)
  - [3.Spring有哪些常用注解？](#3spring有哪些常用注解)
  - [4.Spring 中应用了哪些设计模式呢？](#4spring-中应用了哪些设计模式呢)
  - [5.spring的容器、web容器、springmvc的容器之间的区别？](#5spring的容器web容器springmvc的容器之间的区别)
    - [1. Spring 容器](#1-spring-容器)
    - [2. Web 容器](#2-web-容器)
    - [3. Spring MVC 容器](#3-spring-mvc-容器)
    - [总结-5](#总结-5)
  - [6.说一说什么是 IoC？什么是 DI？](#6说一说什么是-ioc什么是-di)
    - [控制反转（Inversion of Control, IoC）](#控制反转inversion-of-control-ioc)
    - [依赖注入（Dependency Injection, DI）](#依赖注入dependency-injection-di)
    - [IoC 和 DI 的关系](#ioc-和-di-的关系)
    - [Spring 中的 IoC 和 DI](#spring-中的-ioc-和-di)
    - [总结-6](#总结-6)
  - [7.能简单说一下 Spring IoC 的实现机制吗？](#7能简单说一下-spring-ioc-的实现机制吗)
    - [1. 配置元数据](#1-配置元数据)
    - [2. 解析配置元数据](#2-解析配置元数据)
    - [3. 创建 Bean 实例](#3-创建-bean-实例)
    - [4. 管理 Bean 生命周期](#4-管理-bean-生命周期)
    - [5. 提供 Bean](#5-提供-bean)
    - [XML 配置](#xml-配置)
    - [注解配置](#注解配置)
    - [Java 配置](#java-配置)
    - [总结-7](#总结-7)
  - [8.说说 BeanFactory 和 ApplicantContext?](#8说说-beanfactory-和-applicantcontext)
    - [1. BeanFactory](#1-beanfactory)
    - [2. ApplicationContext](#2-applicationcontext)
    - [主要区别](#主要区别)
    - [总结- 8](#总结--8)
  - [9.Spring 的 Bean 实例化方式？](#9spring-的-bean-实例化方式)
    - [1. 构造器实例化](#1-构造器实例化)
    - [2. 静态工厂方法实例化](#2-静态工厂方法实例化)
    - [3. 实例工厂方法实例化](#3-实例工厂方法实例化)
    - [总结-9](#总结-9)
  - [10.能说一下 Spring Bean 生命周期吗？](#10能说一下-spring-bean-生命周期吗)
  - [11.Bean 定义和依赖定义有哪些方式？](#11bean-定义和依赖定义有哪些方式)
  - [12.Spring 有哪些自动装配的方式？](#12spring-有哪些自动装配的方式)
  - [13.Spring 中的 Bean 的作用域有哪些?](#13spring-中的-bean-的作用域有哪些)
  - [14.Spring 中的单例 Bean 会存在线程安全问题吗？](#14spring-中的单例-bean-会存在线程安全问题吗)
    - [单例 Bean 的线程安全问题](#单例-bean-的线程安全问题)
    - [线程安全问题的示例](#线程安全问题的示例)
    - [解决线程安全问题的方法](#解决线程安全问题的方法)
    - [总结- 14](#总结--14)
  - [15.循环依赖问题](#15循环依赖问题)
    - [Spring 可以解决哪些情况的循环依赖？](#spring-可以解决哪些情况的循环依赖)
    - [Spring 怎么解决循环依赖的呢？](#spring-怎么解决循环依赖的呢)
    - [为什么要三级缓存？二级不行吗？](#为什么要三级缓存二级不行吗)
  - [16.@Autowired 的实现原理？](#16autowired-的实现原理)
  - [17.说说什么是 AOP？](#17说说什么是-aop)
    - [AOP 的核心概念](#aop-的核心概念)
    - [织入有哪几种方式？](#织入有哪几种方式)
    - [AspectJ是什么？](#aspectj是什么)
    - [AOP有几种环绕方式？](#aop有几种环绕方式)
    - [Spring AOP 示例](#spring-aop-示例)
    - [总结- 17](#总结--17)
  - [18.说说 JDK 动态代理和 CGLIB 代理？](#18说说-jdk-动态代理和-cglib-代理)
    - [JDK 动态代理](#jdk-动态代理)
    - [CGLIB 代理](#cglib-代理)
    - [Spring AOP 中的代理选择](#spring-aop-中的代理选择)
    - [总结- 18](#总结--18)
  - [19.说说 Spring AOP 和 AspectJ AOP 区别?](#19说说-spring-aop-和-aspectj-aop-区别)

<!-- /TOC -->

## Java集合框架

### 1.阻塞队列的阻塞是什么含义？

阻塞队列的“阻塞”指的是当生产者往队列中添加元素时，如果队列已满，则生产者的添加操作会被阻塞，直到队列中有空闲空间；同样地，当消费者从队列中移除元素时，如果队列为空，则消费者的移除操作会被阻塞，直到队列中有新的元素被添加进来。这种机制确保了在多线程环境下队列的操作是线程安全的，并且能够有效地协调生产者和消费者之间的同步问题。

### 2.阻塞队列的实现方式？

Java中的BlockingQueue接口定义了阻塞队列的行为，并且Java并发库java.util.concurrent提供了多种BlockingQueue的具体实现。

**ArrayBlockingQueue：**

基于数组结构的有界阻塞队列。
固定大小的队列，当队列满时，生产者线程会被阻塞，直到队列中的元素被消费掉。
当队列空时，消费者线程会被阻塞，直到队列中有新的元素加入。

**LinkedBlockingQueue：**

基于链表结构的阻塞队列。
可以指定容量大小，如果不指定，默认为Integer.MAX_VALUE。
当队列满时，生产者线程会被阻塞；当队列空时，消费者线程会被阻塞。

**PriorityBlockingQueue：**

具有优先级的无界阻塞队列。
类似于PriorityQueue，但是加入了阻塞的功能。
不会阻塞生产者线程，但是可以保证具有较高优先级的元素会被先消费。

**DelayQueue：**

使用Delayed类型的元素的无界阻塞队列。
队列中的元素只有在其延迟过期后才能被消费者线程消费。
生产者线程不会被阻塞，但消费者线程可能会因为没有到期的元素而被阻塞。

**SynchronousQueue：**

不存储元素的阻塞队列。
每个插入操作必须等待另一个线程的对应移除操作，反之亦然。
实际上不存储任何元素，更多地用于线程间的数据交换。

**LinkedTransferQueue：**

基于链表结构的无界阻塞队列。
提供了更强的传递语义，允许生产者直接将元素传给消费者，如果消费者不存在则放入内部队列。
支持传递操作，即生产者可以直接将元素传递给消费者线程

### 3.线程不安全的集合变成线程安全的方法？

**使用synchronizedXxx()方法：**

java.util.Collections类提供了一系列静态方法，如synchronizedList(), synchronizedSet(), synchronizedMap()等，可以将线程不安全的集合包装成线程安全的集合。
例如，对于ArrayList，可以使用Collections.synchronizedList(new ArrayList<>())将其转换为线程安全的列表。

**使用同步容器：**

Java标准库提供了一些内置的线程安全容器，如Vector和Hashtable。
Vector是线程安全的List实现，而Hashtable是线程安全的Map实现。

**显式同步：**

可以手动对集合的操作进行同步控制，比如在访问集合前加上synchronized关键字，并使用集合对象本身或其外部的对象作为锁。
示例代码如下：

```java
List list = new ArrayList<>();
Object lock = new Object();
synchronized(lock) {
    // 在这里执行对list的安全操作
}
```

**使用并发集合：**

Java并发包java.util.concurrent提供了线程安全的集合实现，如ConcurrentHashMap, CopyOnWriteArrayList, CopyOnWriteArraySet等。
这些集合在设计时就考虑到了并发访问的问题，因此不需要额外的同步措施。

**使用ReentrantLock或其他锁机制：**

可以使用更高级的锁机制，如ReentrantLock，来替代synchronized关键字，以获得更细粒度的锁控制。

**使用不可变集合：**

创建不可变集合，一旦创建就不能改变，这样也避免了并发修改的问题。
不可变集合可以被认为是线程安全的，因为它们的状态不会改变。

### 4.HashMap的底层数据结构?

JDK 8 中 HashMap 的数据结构是数组+链表+红黑树。

HashMap 的核心是一个动态数组（Node[] table），用于存储键值对。这个数组的每个元素称为一个“桶”（Bucket），每个桶的索引是通过对键的哈希值进行哈希函数处理得到的。

当多个键经哈希处理后得到相同的索引时，会发生哈希冲突。HashMap 通过链表来解决哈希冲突——即将具有相同索引的键值对通过链表连接起来。

不过，链表过长时，查询效率会比较低，于是当链表的长度超过 8 时（且数组的长度大于 64），链表就会转换为红黑树。红黑树的查询效率是 O(logn)，比链表的 O(n) 要快。数组的查询效率是 O(1)。

链表转换为红黑树的条件

链表长度：当单个桶（bucket）中的链表长度达到 8 时，该链表会被转换为红黑树。
最小树化容量：HashMap 的总容量（桶数组大小）必须至少为 64。如果 HashMap 的容量小于 64，即使链表长度达到 8，也不会进行树化，而是会选择扩容。

红黑树转换为链表的条件

树节点数量：当红黑树节点元素小于等于 6 时，红黑树会被转换回链表形式。这是因为，在小数据量时，链表的效率更高。

转换逻辑

树化：当一个桶中的链表长度达到 8，并且 HashMap 的容量大于等于 64 时，这个链表会被转换成红黑树。这样做的目的是为了减少链表的长度，从而提高查找的效率。红黑树的平均查找长度是 O(log n)，相比于链表的 O(n)，在链表长度较长时性能更好。

链表化：当红黑树中的节点数量减少到 6 或更少时，红黑树会被转换回链表。这是因为对于少量的数据，链表的开销较小，转换为链表可以减少不必要的内存占用和管理开销。

扩容机制

扩容：在某些情况下，如果 HashMap 的容量不足以容纳更多的元素，或者链表长度达到树化阈值但容量不足时，HashMap 会进行扩容。扩容操作会将容量加倍，并重新散列所有的元素。

当向 HashMap 中添加一个键值对时，会使用哈希函数计算键的哈希码，确定其在数组中的位置，哈希函数的目标是尽量减少哈希冲突，保证元素能够均匀地分布在数组的每个位置上。

```java
static final int hash(Object key) {
    int h;
    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
}
```

当向 HashMap 中添加元素时，如果该位置已有元素（发生哈希冲突），则新元素将被添加到链表的末尾或红黑树中。如果键已经存在，其对应的值将被新值覆盖。

当从 HashMap 中获取元素时，也会使用哈希函数计算键的位置，然后根据位置在数组、链表或者红黑树中查找元素。

HashMap 的初始容量是 16，随着元素的不断添加，HashMap 的容量（也就是数组大小）可能不足，于是就需要进行扩容，阈值是capacity * loadFactor，capacity 为容量，loadFactor 为负载因子，默认为 0.75。

扩容后的数组大小是原来的 2 倍，然后把原来的元素重新计算哈希值，放到新的数组中。

总的来说，HashMap 是一种通过哈希表实现的键值对集合，它通过将键哈希化成数组索引，并在冲突时使用链表或红黑树来存储元素，从而实现快速的查找、插入和删除操作。

### 5.为什么 HashMap 是线程不安全的？

修改操作非原子性

HashMap 的修改操作（如 put 和 remove）并没有使用锁来保证原子性，这意味着在多线程环境中，这些操作可能会被中断，导致数据不一致。
例如，在 put 操作中，HashMap 需要计算哈希值、找到桶的位置、插入键值对等步骤，这些步骤在多线程环境下可能被其他线程干扰。

扩容时的竞态条件

当 HashMap 达到其容量限制时，它会进行扩容操作，这个过程涉及到重新散列所有已存在的键值对。
如果多个线程同时触发扩容操作，可能会导致竞态条件，其中一个线程的扩容操作可能被另一个线程覆盖，从而导致数据丢失或不一致。

链表或红黑树操作的不一致性

当多个线程同时操作同一个桶中的链表或红黑树时，如果没有适当的同步机制，可能会导致链表或红黑树的结构被破坏，进而导致数据丢失或无限循环等问题。

可见性问题

HashMap 中的变量（如容量、阈值等）在多线程环境中如果没有正确的同步机制，可能会导致线程间的可见性问题，即一个线程修改的数据不能被另一个线程及时看到。

解决方案

为了使 HashMap 在多线程环境中安全使用，可以采取以下措施：

使用 Collections.synchronizedMap：将 HashMap 包装成线程安全的集合。

使用 ConcurrentHashMap：这是 HashMap 的线程安全版本，专为多线程环境设计。
显式同步：在访问 HashMap 时手动加锁，确保同一时刻只有一个线程能够修改 HashMap。

### 6.平衡二叉树

平衡二叉树（Balanced Binary Tree）是一种特殊的二叉树，其中任意节点的左右子树高度差不超过一定范围。常见的平衡二叉树有 AVL 树和红黑树。

#### AVL 树

AVL 树是一种自平衡的二叉查找树，它通过在每个节点上存储一个平衡因子（balance factor）来保持树的平衡。平衡因子定义为左右子树的高度差，它可以是 -1、0 或 1。

**AVL 树的基本操作**  

插入操作：

插入新节点。
通过旋转操作来保持平衡。

删除操作：

删除指定节点。
通过旋转操作来保持平衡。

查找操作：

在 AVL 树中查找指定键值的节点。

当平衡二叉树（如 AVL 树）的平衡性被破坏时，通常是因为插入或删除了一个节点，导致某些节点的平衡因子（左子树高度与右子树高度之差）的绝对值超过了允许的范围（对于 AVL 树来说是 1）。为了恢复平衡，需要执行一系列旋转操作。

**恢复平衡的步骤**  

确定破坏点：找到第一个平衡因子绝对值大于 1 的节点。

识别破坏模式：根据破坏点与其子节点的关系，确定破坏模式。

执行相应的旋转操作：根据破坏模式执行单旋转或多旋转（双旋转）。

常见的破坏模式和对应的旋转操作

LL（左左）：破坏点的左子节点有一个更高的左子树。

RR（右右）：破坏点的右子节点有一个更高的右子树。

LR（左右）：破坏点的左子节点有一个更高的右子树。

RL（右左）：破坏点的右子节点有一个更高的左子树。

旋转操作

单旋转：当破坏模式为 LL 或 RR 时，执行一次旋转即可恢复平衡。

双旋转：当破坏模式为 LR 或 RL 时，首先对破坏点的子节点执行一次旋转，然后对破坏点执行一次旋转。

LL模式的旋转操作

![error](https://raw.githubusercontent.com/BugLeesir/image_host01/main/blogs_img/e6ba79cc941b246e710758a75bd3b28.jpg)

RR模式的旋转操作

![error](https://raw.githubusercontent.com/BugLeesir/image_host01/main/blogs_img/06df2e2af3731aa9dea7003448bece4.jpg)

LR模式的旋转操作

![error](https://raw.githubusercontent.com/BugLeesir/image_host01/main/blogs_img/f8e97677dfdc3b526c5db85068edff1.jpg)

RL模式的旋转操作

![error](https://raw.githubusercontent.com/BugLeesir/image_host01/main/blogs_img/2991016a03a325661a32b44c6610dc4.jpg)

删除的旋转操作

![error](https://raw.githubusercontent.com/BugLeesir/image_host01/main/blogs_img/3a6327794b26a6bb0eb28469a8f3cb8.jpg)

#### 红黑树

红黑树（Red-Black Tree）是一种自平衡的二叉查找树，它通过特定的颜色标记以及旋转和重新着色操作来维持树的近似平衡，从而确保树的高度保持在(O(\log n))，这里(n)是树中节点的数量。这使得红黑树能够高效地执行查找、插入和删除操作。

**红黑树的特点**  

红黑树的每个节点都有一个颜色属性，可以是红色（red）或黑色（black），并且满足以下性质：

节点属性：每个节点要么是红色的，要么是黑色的。

根节点：根节点总是黑色。

叶子节点：所有叶子节点（NIL节点，空节点）都是黑色的。

红色节点：两个红色节点之间不能相邻，即一个红色节点的父节点和子节点必须是黑色。

黑色高度：从任一节点到其每个叶子的所有简单路径上包含相同数量的黑色节点。

**插入后恢复平衡的情况**  

当插入一个新节点后，该节点被标记为红色，并且可能违反红黑树的性质。常见的恢复策略包括：

变色：如果新插入的节点的父节点也是红色，那么需要考虑变色操作（若父节点为黑色则无需自平衡）。如果叔叔节点（父节点的兄弟节点）也是红色，则将父节点和叔叔节点都变为黑色，祖父节点变为红色，然后以祖父节点作为新的起点继续检查（即黑红红改为红黑红）。

旋转：如果叔叔节点是黑色或不存在，则需要进行旋转操作来调整树的结构。具体分为以下几种情况：

左左情况：如果新节点是其父节点的左孩子，而父节点又是其祖父节点的左孩子，则进行一次右旋。

右右情况：如果新节点是其父节点的右孩子，而父节点又是其祖父节点的右孩子，则进行一次左旋。

左右情况：如果新节点是其父节点的右孩子，而父节点是其祖父节点的左孩子，则先对其父节点进行左旋，再对祖父节点进行右旋。

右左情况：如果新节点是其父节点的左孩子，而父节点是其祖父节点的右孩子，则先对其父节点进行右旋，再对祖父节点进行左旋。

**删除后的恢复平衡**  

删除节点后，可能需要调整树的结构来恢复红黑树的性质。主要关注的是删除操作可能导致的黑色高度减少问题。常见的恢复策略包括：

双黑节点：如果删除了一个黑色节点，并且替换它的节点是红色，则直接将其替换为黑色即可。否则，如果替换节点是黑色，则会产生一个“双黑”节点（即节点和其原本的NIL节点都被视为黑色）。

旋转和变色：为了修复双黑问题，需要考虑以下几个方向：

如果双黑节点的兄弟节点是红色，则可以通过旋转和变色来解决。例如，如果兄弟节点是红色，且兄弟节点的外侧子节点是黑色，则可以先进行一次旋转（左旋或右旋），使兄弟节点成为父节点，然后进行变色。

如果兄弟节点是黑色，且兄弟节点的两个子节点都是黑色，则将兄弟节点变为红色，并继续在其父节点处进行检查。

如果兄弟节点是黑色，且兄弟节点的外侧子节点是红色，则可以先进行一次旋转（左旋或右旋），使兄弟节点成为父节点，然后进行变色。

如果兄弟节点是黑色，且兄弟节点的内侧子节点是红色，则可以先进行一次旋转（左旋或右旋），使兄弟节点成为父节点，然后进行变色。

### 7.HashMap 的 put 流程

第一步，通过 hash 方法计算 key 的哈希值。

```java
static final int hash(Object key) {
    int h;
    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
}
```

第二步，数组进行第一次扩容。

```java
if ((tab = table) == null || (n = tab.length) == 0)
    n = (tab = resize()).length;
```

第三步，根据哈希值计算 key 在数组中的下标，如果对应下标正好没有存放数据，则直接插入。

```java
if ((p = tab[i = (n - 1) & hash]) == null)
    tab[i] = newNode(hash, key, value, null);
```

如果对应下标已经有数据了，就需要判断是否为相同的 key，是则覆盖 value，否则需要判断是否为树节点，是则向树中插入节点，否则向链表中插入数据。

```java
else {
    Node<K,V> e; K k;
    if (p.hash == hash &&
        ((k = p.key) == key || (key != null && key.equals(k))))
        e = p;
    else if (p instanceof TreeNode)
        e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);
    else {
        for (int binCount = 0; ; ++binCount) {
            if ((e = p.next) == null) {
                p.next = newNode(hash, key, value, null);
                if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st
                    treeifyBin(tab, hash);
                break;
            }
            if (e.hash == hash &&
                ((k = e.key) == key || (key != null && key.equals(k))))
                break;
            p = e;
        }
    }
}
```

注意，在链表中插入节点的时候，如果链表长度大于等于 8，则需要把链表转换为红黑树。

```java
if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st
    treeifyBin(tab, hash);
```

所有元素处理完后，还需要判断是否超过阈值threshold，超过则扩容。

```java
if (++size > threshold)
    resize();
```

### 8.只重写 equals 没重写 hashcode，map put 的时候会发生什么?

如果只重写 equals 方法，没有重写 hashcode 方法，那么会导致 equals 相等的两个对象，hashcode 不相等，这样的话，这两个对象会被放到不同的桶中，这样就会导致 get 的时候，找不到对应的值。

当你使用一个键去 Map 中获取对应的值时，Map 会首先使用键的 hashCode 方法来定位可能的位置，然后再调用 equals 方法来确认键是否匹配。

如果你只重写了 equals 方法，那么即使两个键 equals 相等，但它们的 hashCode 不同，Map 将无法找到正确的条目，导致返回 null，即使该键实际上存在于 Map 中。

### 9.为什么要用高低做异或运算？为什么非得高低 16 位异或？

为什么使用高低位进行异或运算？

提高哈希值的均匀性：

哈希函数的目标是将输入数据映射到一个固定大小的空间中，使得输出尽可能均匀分布。
使用高低位异或运算可以帮助混合高阶位和低阶位的信息，从而提高哈希值的均匀性和随机性。

避免局部相关性：

在许多情况下，输入数据的高阶位和低阶位可能存在一定的相关性。通过异或运算，可以打破这种相关性，使得哈希值更加独立和随机。

增强扩散效果：

异或运算可以将高阶位和低阶位的信息混合在一起，从而增强哈希值的扩散效果。这有助于防止哈希冲突，提高哈希函数的质量。

为什么选择高低 16 位进行异或？

字长的一半：

对于 32 位整数，高低 16 位正好是字长的一半。这样可以充分利用整个字长，同时避免了不必要的复杂性。
选择 16 位是因为 16 是一个合理的中间值，既不是太小也不是太大，可以很好地混合高低位信息。

性能考虑：

16 位的位数适中，可以在性能和效果之间取得良好的平衡。如果位数太少，可能不足以充分混合信息；如果位数太多，可能会增加计算复杂度。

经验选择：

在实际应用中，高低 16 位异或已经被证明是一种有效的哈希函数优化方法。许多成熟的哈希函数（如 Jenkins Hash Function）都采用了这种方法。

### 10.为什么 HashMap 的容量是 2 的倍数呢？hashCode 对数组长度取模定位数组下标的优化策略？

哈希值计算：

HashMap 使用哈希码来确定元素存储的位置。哈希码通过与数组长度进行取模运算 (%) 来计算出元素在数组中的位置。
当数组长度是 2 的幂次方时，取模运算可以简化为位运算。具体来说，hash % capacity 可以简化为 hash & (capacity - 1)。这是因为当 capacity 是 2 的幂次方时，capacity - 1 将会是一个二进制数，其低位全部为 1，高位为 0。因此，hash & (capacity - 1) 实际上是保留了 hash 的低位部分，这比传统的取模运算更快。

减少哈希碰撞：

如果 HashMap 的容量是 2 的幂次方，那么哈希值的分布会更加均匀，从而减少了哈希碰撞的概率。这是因为位运算的结果依赖于哈希值的低位，如果低位分布均匀，则可以更好地分散元素，减少碰撞。

扩容时的重新哈希：

当 HashMap 的容量需要扩展时，如果新的容量仍然是 2 的幂次方，那么重新哈希的过程也会更加均匀。这是因为新的容量与旧的容量之间存在倍数关系，可以使得元素在新的数组中重新分布，减少由于扩容带来的碰撞。

硬件优化：

在现代计算机体系结构中，位运算通常比算术运算（如除法和取模）更快。因此，使用位运算来替代取模运算可以带来性能上的优势。

### 11.map 集合在使用时候一般都需要写容量值？为什么要写？扩容机制？

在使用 Java 中的 HashMap 时，通常会在创建 HashMap 实例时指定初始容量。这是因为 HashMap 的性能很大程度上取决于它的容量大小。指定合适的初始容量可以帮助避免不必要的扩容操作，从而提高程序的性能。

**为什么需要指定容量**  

1. 减少扩容次数：当 HashMap 的容量达到阈值时，会触发一次扩容操作。如果 HashMap 的容量过大，那么每次扩容都需要重新计算哈希值，这可能会导致不必要的性能开销。通过指定合适的初始容量，可以减少扩容操作的次数，提高 HashMap 的性能。

2. 减少哈希碰撞：如果 HashMap 的容量过小，可能会导致哈希碰撞（即两个不同的键计算出相同的哈希值）。这会导致在 HashMap 中存在多个键映射到同一个位置，从而导致查找和插入操作的时间复杂度提高。通过指定合适的初始容量，可以减少哈希碰撞，提高 HashMap 的性能。

3. 减少内存占用：当 HashMap 的容量过大时，可能会导致 HashMap 的内存占用过多。通过指定合适的初始容量，可以减少 HashMap 的内存占用，提高 HashMap 的性能。

**扩容机制**  

HashMap 的默认初始容量是 16，而且容量总是 2 的幂次方。当 HashMap 中的元素数量超过了当前容量与加载因子（默认为 0.75）的乘积时，就会触发扩容操作。扩容时，HashMap 会创建一个新的数组，其容量通常是原来的两倍，并将原有数组中的所有元素重新散列并放入新的数组中。

### 12.红黑树转回链表的阈值为什么默认是6而不是8？

因为如果这个阈值也设置成 8，假如发生碰撞，节点增减刚好在 8 附近，会发生链表和红黑树的不断转换，导致资源浪费。

### 13.JDK8对HashMap的实现原理做了哪些优化？

1. 底层数据结构由数组 + 链表改成了数组 + 链表或红黑树的结构。

原因：如果多个键映射到了同一个哈希值，链表会变得很长，在最坏的情况下，当所有的键都映射到同一个桶中时，性能会退化到 O(n)，而红黑树的时间复杂度是 O(logn)。

2.链表的插入方式由头插法改为了尾插法。

原因：头插法虽然简单快捷，但扩容后容易改变原来链表的顺序。

3.扩容的时机由插入时判断改为插入后判断。

原因：可以避免在每次插入时都进行不必要的扩容检查，因为有可能插入后仍然不需要扩容。

4.优化了哈希算法

JDK 7 进行了多次移位和异或操作来计算元素的哈希值。JDK 8 优化了这个算法，只进行了一次异或操作，但仍然能有效地减少冲突。并且能够保证扩容后，元素的新位置要么是原位置，要么是原位置加上旧容量大小。

### 14.HashMap和TreeMap的区别？

1.HashMap 是基于数组+链表+红黑树实现的，put 元素的时候会先计算 key 的哈希值，然后通过哈希值计算出数组的索引，然后将元素插入到数组中，如果发生哈希冲突，会使用链表来解决，如果链表长度大于 8，会转换为红黑树。

get 元素的时候同样会先计算 key 的哈希值，然后通过哈希值计算出数组的索引，如果遇到链表或者红黑树，会通过 key 的 equals 方法来判断是否是要找的元素。

2.TreeMap 是基于红黑树实现的，put 元素的时候会先判断根节点是否为空，如果为空，直接插入到根节点，如果不为空，会通过 key 的比较器来判断元素应该插入到左子树还是右子树。

get 元素的时候会通过 key 的比较器来判断元素的位置，然后递归查找。

由于 HashMap 是基于哈希表实现的，所以在没有发生哈希冲突的情况下，HashMap 的查找效率是 O(1)。适用于查找操作比较频繁的场景。

而 TreeMap 是基于红黑树实现的，所以 TreeMap 的查找效率是 O(logn)。并且保证了元素的顺序，因此适用于需要大量范围查找或者有序遍历的场景。

## Java并发编程

### 1.你对线程安全的理解是什么？

线程安全是并发编程中一个重要的概念，如果一段代码块或者一个方法在多线程环境中被多个线程同时执行时能够正确地处理共享数据，那么这段代码块或者方法就是线程安全的。

可以从三个要素来确保线程安全：

①、原子性：确保当某个线程修改共享变量时，没有其他线程可以同时修改这个变量，即这个操作是不可分割的。

②、可见性：确保一个线程对共享变量的修改可以立即被其他线程看到。

③、活跃性问题：要确保线程不会因为死锁、饥饿、活锁等问题导致无法继续执行。

### 2.线程和进程的区别？

**定义**  

进程：进程是操作系统中程序的一次执行实例，它是系统进行资源分配和调度的基本单位。每个进程都有独立的地址空间和其他资源（如文件句柄、环境变量等）。

线程：线程是进程内的一个执行流，它是处理器调度和分派的基本单位。同一进程内的线程共享该进程的地址空间和资源。

**资源占用**  

进程拥有独立的内存空间，因此每个进程都有自己的数据段、堆栈段和代码段等，这意味着进程间的资源是隔离的。

线程共享所属进程的数据段、堆栈段和代码段等资源，因此创建线程比创建进程消耗更少的资源。

**上下文切换开销**  

进程间的上下文切换涉及到更多的资源转移和保护，因此开销较大。

线程间的上下文切换仅需保存和恢复少量寄存器值及栈指针，因此开销较小。

**通信方式**  

进程间通信（IPC）通常需要通过操作系统提供的机制来实现，如管道、消息队列、共享内存等，这增加了通信的复杂度。

线程可以直接访问同一进程内的全局变量或数据结构，因此线程间的通信更为简单直接。

**生命周期管理**  

进程的创建和销毁涉及更多资源的初始化和清理工作，因此相对于线程来说更加耗时。

线程的生命周期管理较为轻量级，创建和销毁速度快。

**依赖关系**  

线程依赖于进程的存在，没有进程就没有线程。进程是独立的执行环境，可以不依赖其他进程单独存在。

### 3.线程共享内存和进程共享内存的区别？

#### 进程共享内存

**共享范围**  

不同进程之间默认情况下是不共享内存的，每个进程都有自己的独立地址空间。进程间的内存共享需要通过特定的技术手段实现，例如通过共享内存段、映射文件等方式。

**通信复杂度**  

进程间通信（IPC）通常需要通过操作系统提供的机制来实现，如管道、消息队列、共享内存、套接字等。这些机制比线程间的直接内存访问要复杂得多。

**数据一致性**  

由于进程间通信需要通过特定的通道进行，因此在设计上更容易实现数据的一致性和安全性。

**资源开销**  

创建进程的资源开销相对较大，因为每个进程都需要自己的虚拟地址空间和系统资源（如文件句柄、环境变量等）。

#### 线程共享内存

**共享范围**  

同一进程内的所有线程共享该进程的整个地址空间，包括代码段、数据段、堆和栈等。

**通信复杂度**  

线程之间的通信非常简单，因为它们可以直接访问同一进程内的全局变量或其他数据结构，无需复杂的同步机制。

**数据一致性**  

虽然共享内存简化了线程间的通信，但也带来了数据一致性和同步的问题，需要通过锁机制（如互斥锁、信号量等）来保证数据访问的原子性和一致性。

**资源开销**  

创建线程的资源开销相对较小，因为不需要额外的内存空间分配，只需为每个线程维护一个栈和一些控制信息即可。

### 4.有多少种实现线程的方式？

**继承Thread类**  

```java
class ThreadTask extends Thread {
    public void run() {
        System.out.println("继承Thread类");
    }

    public static void main(String[] args) {
        ThreadTask task = new ThreadTask();
        task.start();
    }
}
```

直接继承Thread类，并重写其run方法。这种方式简单直观，但因为Java不支持多重继承，所以如果需要继承其他类，则不能使用这种方法。

**实现Runnable接口**  

```java
class RunnableTask implements Runnable {
    public void run() {
        System.out.println("实现Runnable接口");
    }

    public static void main(String[] args) {
        RunnableTask task = new RunnableTask();
        Thread thread = new Thread(task);
        thread.start();
    }
}
```

实现Runnable接口并重写run方法，然后将这个对象传递给Thread类的构造函数创建线程。这种方式更灵活，因为它允许类继承其他类的同时实现多线程功能。

**实现Callable接口配合FutureTask使用**  

```java
class CallableTask implements Callable<String> {
    public String call() {
        return "实现Callable接口";
    }

    public static void main(String[] args) throws ExecutionException, InterruptedException {
        CallableTask task = new CallableTask();
        FutureTask<String> futureTask = new FutureTask<>(task);
        Thread thread = new Thread(futureTask);
        thread.start();
        System.out.println(futureTask.get());
    }
}
```

Callable接口类似于Runnable，不同之处在于Callable的call方法可以返回结果，并且可以抛出异常。通过FutureTask包装Callable对象，然后将其传递给Thread类创建线程。这种方式适合需要返回结果的任务。

**使用Executor框架和线程池**  

[线程池的应用](#6讲一讲你对线程池的理解并讲一讲使用的场景)

### 5.为什么在项目中使用线程池？

1、频繁地创建和销毁线程会消耗系统资源，线程池能够复用已创建的线程。

2、提高响应速度，当任务到达时，任务可以不需要等待线程创建就立即执行。

3、线程池支持定时执行、周期性执行、单线程执行和并发数控制等功能。

### 6.讲一讲你对线程池的理解，并讲一讲使用的场景

#### 线程池的概念

线程池是一种管理线程的技术，它预先创建一组线程，并将它们组织在一起，以便能够高效地处理多个任务。线程池的核心思想是复用已创建的线程，而不是每次任务到来时都创建新的线程。

#### 线程池的基本组成

核心线程数（Core Pool Size）：线程池中始终维持的最小线程数。

最大线程数（Maximum Pool Size）：线程池中允许的最大线程数。

工作队列（Work Queue）：用来存储等待执行的任务。

拒绝策略（Rejection Policy）：当线程池无法接收更多任务时采取的策略。

线程工厂（Thread Factory）：用于创建新线程的对象。

**Java中线程池的主要参数**  

①、corePoolSize

定义了线程池中的核心线程数量。即使这些线程处于空闲状态，它们也不会被回收。这是线程池保持在等待状态下的线程数。

②、maximumPoolSize

线程池允许的最大线程数量。当工作队列满了之后，线程池会创建新线程来处理任务，直到线程数达到这个最大值。

③、keepAliveTime

非核心线程的空闲存活时间。如果线程池中的线程数量超过了 corePoolSize，那么这些多余的线程在空闲时间超过 keepAliveTime 时会被终止。

④、unit

keepAliveTime 参数的时间单位：

TimeUnit.DAYS; 天
TimeUnit.HOURS; 小时
TimeUnit.MINUTES; 分钟
TimeUnit.SECONDS; 秒
TimeUnit.MILLISECONDS; 毫秒
TimeUnit.MICROSECONDS; 微秒
TimeUnit.NANOSECONDS; 纳秒
⑤、workQueue

用于存放待处理任务的阻塞队列。当所有核心线程都忙时，新任务会被放在这个队列里等待执行。

⑥、threadFactory

一个创建新线程的工厂。它用于创建线程池中的线程。可以通过自定义 ThreadFactory 来给线程池中的线程设置有意义的名字，或设置优先级等。

⑦、handler

拒绝策略 RejectedExecutionHandler，定义了当线程池和工作队列都满了之后对新提交的任务的处理策略。常见的拒绝策略包括抛出异常、直接丢弃、丢弃队列中最老的任务、由提交任务的线程来直接执行任务等。

#### 线程池的工作流程

1.任务提交：当一个任务提交到线程池时，线程池会尝试分配一个线程来执行该任务。

2.核心线程数：如果当前活动线程少于核心线程数，即使有空闲线程，也会创建新的线程来执行任务。

3.工作队列：如果当前活动线程等于核心线程数，但还有任务需要执行，那么这些任务会被放入工作队列中等待执行。

4.最大线程数：如果工作队列已满，线程池会尝试创建新的线程，直到达到最大线程数。

5.拒绝策略：如果线程池已经达到最大线程数且工作队列已满，线程池将根据拒绝策略处理新任务。

#### 线程池的拒绝策略

**AbortPolicy：**

这是默认的拒绝策略。当线程池无法接受新任务时，它会抛出一个RejectedExecutionException异常。这通常意味着应用程序需要处理这个异常，并可能需要采取补救措施，比如记录日志或者通知管理员。

**CallerRunsPolicy：**

当线程池无法接受新任务时，这个策略会让调用者所在的线程来运行这个任务。如果调用者的线程本身已经在执行其他任务，那么可能会导致调用者线程的阻塞。*这种策略适合于并发度不高、性能要求不是特别高的场景。*

**DiscardPolicy：**

当线程池无法接受新任务时，这个策略会直接丢弃任务而不执行它，也不会抛出异常。*这种策略适用于那些可以容忍任务丢失的场景。*

**DiscardOldestPolicy：**

当线程池无法接受新任务时，这个策略会首先丢弃队列中最旧的任务，然后尝试再次提交新任务。*这种策略有助于优先处理最新的任务，但可能导致某些任务永远无法被执行。*

**自定义拒绝策略**  

除了这些内置的拒绝策略之外，还可以通过实现RejectedExecutionHandler接口来自定义拒绝策略，以适应特定的应用需求。

#### 线程池的阻塞队列

**ArrayBlockingQueue：**

一个由数组结构组成的有界阻塞队列。

按照先进先出（FIFO）排序元素。

是LinkedBlockingQueue的一个替代品，当需要一个容量固定的队列时使用。

**LinkedBlockingQueue：**

一个基于链表结构的阻塞队列，吞吐量通常要高于ArrayBlockingQueue。

默认情况下是无界的，但是可以通过构造函数指定队列长度。

适用于需要一个具有较高吞吐量的无界或有限阻塞队列的情况

**PriorityBlockingQueue：**

一个具有优先级的无界阻塞队列。

支持优先级排序的功能，可以按照优先级来决定哪个任务先被执行。

适用于需要根据任务优先级来调度执行的任务队列。

**DelayQueue：**

一个使用Delayed元素的无界阻塞队列。

队列中的元素只有在其延迟过期后才能被消费者线程获取。

适用于需要延迟执行的任务。

**SynchronousQueue：**

一个不存储元素的阻塞队列。

每个插入操作必须等待另一个线程的相应移除操作，反之亦然。

适用于传递元素，而不是存储元素的情况，通常用于实现生产者-消费者模型。

#### 线程池的提交

**execute(Runnable command)**  

```java
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class ThreadPoolExample {
    public static void main(String[] args) {
        // 创建线程池
        ExecutorService executor = Executors.newFixedThreadPool(5);

        // 提交任务
        for (int i = 0; i < 10; i++) {
            int taskId = i;
            executor.execute(() -> {
                System.out.println("Task " + taskId + " is running on thread " + Thread.currentThread().getName());
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
            });

            // 关闭线程池
            executor.shutdown();
            try {
                if (!executor.awaitTermination(1, TimeUnit.MINUTES)) {
                    executor.shutdownNow();
                }
            } catch (InterruptedException e) {
                executor.shutdownNow();
                Thread.currentThread().interrupt();
            }
        }
    }
}
```

execute方法用于提交一个Runnable任务，是最基本的提交方式。它没有返回值，也不支持获取任务执行结果。

**submit(Runnable task)**  

```java
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;

public class ThreadPoolExample {
    public static void main(String[] args) {
        // 创建线程池
        ExecutorService executor = Executors.newFixedThreadPool(5);

        // 提交任务
        for (int i = 0; i < 10; i++) {
            int taskId = i;
            Future<?> future = executor.submit(() -> {
                System.out.println("Task " + taskId + " is running on thread " + Thread.currentThread().getName());
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
            });

            // 关闭线程池
            executor.shutdown();
            try {
                if (!executor.awaitTermination(1, TimeUnit.MINUTES)) {
                    executor.shutdownNow();
                }
            } catch (InterruptedException e) {
                executor.shutdownNow();
                Thread.currentThread().interrupt();
            }
        }
    }
}
```

submit方法用于提交一个Runnable任务，并返回一个Future对象，可以用来获取任务的执行状态和结果。

#### 线程池的关闭

可以通过调用线程池的shutdown或shutdownNow方法来关闭线程池。它们的原理是遍历线程池中的工作线程，然后逐个调用线程的 interrupt 方法来中断线程，所以无法响应中断的任务可能永远无法终止。

**shutdown() 将线程池状态置为 shutdown,并不会立即停止：**

停止接收外部 submit 的任务
内部正在跑的任务和队列里等待的任务，会执行完
等到第二步完成后，才真正停止

**shutdownNow() 将线程池状态置为 stop。一般会立即停止，事实上不一定：**

和 shutdown()一样，先停止接收外部提交的任务
忽略队列里等待的任务
尝试将正在跑的任务 interrupt 中断
返回未执行的任务列表

shutdown 和 shutdownnow 简单来说区别如下：

shutdownNow()能立即停止线程池，正在跑的和正在等待的任务都停下了。这样做立即生效，但是风险也比较大。

shutdown()只是关闭了提交通道，用 submit()是无效的；而内部的任务该怎么跑还是怎么跑，跑完再彻底停止线程池。

#### 线程池的线程数配置

①、对于 CPU 密集型任务，我的目标是尽量减少线程上下文切换，以优化 CPU 使用率。一般来说，*核心线程数设置为处理器的核心数或核心数加一*（以备不时之需，如某些线程因等待系统资源而阻塞时）是较理想的选择。

②、对于 IO 密集型任务，由于线程经常处于等待状态（等待 IO 操作完成），可以*设置更多的线程来提高并发性（比如说 2 倍）*，从而增加 CPU 利用率。

#### 线程池的种类

**newFixedThreadPool (固定线程数目的线程池)**  

```java
public static ExecutorService newFixedThreadPool(int nThreads, ThreadFactory threadFactory) {
    return new ThreadPoolExecutor(nThreads, nThreads,
                                  0L, TimeUnit.MILLISECONDS,
                                  new LinkedBlockingQueue<Runnable>(),
                                  threadFactory);
}
```

**线程池特点**  

核心线程数和最大线程数大小一样

没有所谓的非空闲时间，即 keepAliveTime 为 0

阻塞队列为无界队列 LinkedBlockingQueue，可能会导致 OOM

**工作流程**  

提交任务

如果线程数少于核心线程，创建核心线程执行任务

如果线程数等于核心线程，把任务添加到 LinkedBlockingQueue 阻塞队列

如果线程执行完任务，去阻塞队列取任务，继续执行。

**适用场景**  

FixedThreadPool 适用于处理 CPU 密集型的任务，确保 CPU 在长期被工作线程使用的情况下，尽可能的少的分配线程，即适用执行长期的任务。

**newCachedThreadPool (可缓存线程的线程池)**  

```java
public static ExecutorService newCachedThreadPool(ThreadFactory threadFactory) {
    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                  60L, TimeUnit.SECONDS,
                                  new SynchronousQueue<Runnable>(),
                                  threadFactory);
}
```

**线程池特点**  

核心线程数为 0

最大线程数为 Integer.MAX_VALUE，即无限大，可能会因为无限创建线程，导致 OOM

阻塞队列是 SynchronousQueue

非核心线程空闲存活时间为 60 秒

当提交任务的速度大于处理任务的速度时，每次提交一个任务，就必然会创建一个线程。极端情况下会创建过多的线程，耗尽 CPU 和内存资源。由于空闲 60 秒的线程会被终止，长时间保持空闲的 CachedThreadPool 不会占用任何资源。

**工作流程**  

提交任务

因为没有核心线程，所以任务直接加到 SynchronousQueue 队列。

判断是否有空闲线程，如果有，就去取出任务执行。

如果没有空闲线程，就新建一个线程执行。

执行完任务的线程，还可以存活 60 秒，如果在这期间，接到任务，可以继续活下去；否则，被销毁。

**适用场景**  

用于并发执行大量短期的小任务。

**newSingleThreadExecutor (单线程的线程池)**  

```java
public static ExecutorService newSingleThreadExecutor(ThreadFactory threadFactory) {
    return new FinalizableDelegatedExecutorService
        (new ThreadPoolExecutor(1, 1,
                                0L, TimeUnit.MILLISECONDS,
                                new LinkedBlockingQueue<Runnable>(),
                                threadFactory));
}
```

**线程池特点**  

核心线程数为 1

最大线程数也为 1

阻塞队列是无界队列 LinkedBlockingQueue，可能会导致 OOM

keepAliveTime 为 0

**工作流程**  

提交任务

线程池是否有一条线程在，如果没有，新建线程执行任务

如果有，将任务加到阻塞队列

当前的唯一线程，从队列取任务，执行完一个，再继续取，一个线程执行任务。

**适用场景**  

适用于串行执行任务的场景，一个任务一个任务地执行。

**newScheduledThreadPool (定时及周期执行的线程池)**  

```java
public ScheduledThreadPoolExecutor(int corePoolSize) {
    super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS,
          new DelayedWorkQueue());
}
```

**线程池特点**  

最大线程数为 Integer.MAX_VALUE，也有 OOM 的风险

阻塞队列是 DelayedWorkQueue

keepAliveTime 为 0

scheduleAtFixedRate() ：按某种速率周期执行

scheduleWithFixedDelay()：在某个延迟后执行

**工作机制**  

线程从 DelayQueue 中获取已到期的 ScheduledFutureTask（DelayQueue.take()）。到期任务是指 ScheduledFutureTask 的 time 大于等于当前时间。

线程执行这个 ScheduledFutureTask。

线程修改 ScheduledFutureTask 的 time 变量为下次将要被执行的时间。

线程把这个修改 time 之后的 ScheduledFutureTask 放回 DelayQueue 中（DelayQueue.add()）。

**适用场景**  

周期性执行任务的场景，需要限制线程数量的场景

#### 线程池异常处理

1.try-catch 捕获异常

2.submit执行，Feture.get接受异常

3.重写ThreadPoolExecutor.afterExecute方法,处理传递的异常引用

4.实例化时，传入自己的ThreadFactory，设置Thread.UncaughtExceptionHandler处理未检测的异常

#### 线程池的状态

ThreadPoolExecutor 类使用一个名为 ctl 的原子变量来存储线程池的状态信息。这个变量是一个 long 类型的值，其中一部分位用于表示线程池的状态，另一部分位用于表示线程池中的活动线程数。ctl 变量的低三位用于表示线程池的状态，共有四种状态：

**RUNNING**  

该状态的线程池会接收新任务，并处理阻塞队列中的任务;

调用线程池的 shutdown()方法，可以切换到 SHUTDOWN 状态;

调用线程池的 shutdownNow()方法，可以切换到 STOP 状态;

这是线程池的初始状态

**SHUTDOWN**  

该状态的线程池不会接收新任务，但会处理阻塞队列中的任务；

队列为空，并且线程池中执行的任务也为空,进入 TIDYING 状态;

**STOP**  

该状态的线程不会接收新任务，也不会处理阻塞队列中的任务，而且会中断正在运行的任务；

线程池中执行的任务为空,进入 TIDYING 状态;

**TIDYING**  

该状态表明所有的任务已经运行终止，记录的任务数量为 0。

terminated()执行完毕，进入 TERMINATED 状态

当最后一个任务完成后，线程池会进入 TIDYING 状态。

**TERMINATED**  

线程池已经完成所有清理工作，处于终止状态。

#### 线程池对参数的动态修改

在我们微服务的架构下，可以利用配置中心如 Nacos、Apollo 等等，也可以自己开发配置中心。业务服务读取线程池配置，获取相应的线程池实例来修改线程池的参数。

如果限制了配置中心的使用，也可以自己去扩展ThreadPoolExecutor，重写方法，监听线程池参数变化，来动态修改线程池参数。

### 7. 线程池在使用时需要注意什么？

①、**选择合适的线程池大小**

过小的线程池可能会导致任务一直在排队

过大的线程池可能会导致大家都在竞争 CPU 资源，增加上下文切换的开销

可以根据业务是 IO 密集型还是 CPU 密集型来选择线程池大小：

CPU 密集型：指的是任务主要使用来进行大量的计算，没有什么导致线程阻塞。一般这种场景的线程数设置为 CPU 核心数+1。

IO 密集型：当执行任务需要大量的 io，比如磁盘 io，网络 io，可能会存在大量的阻塞，所以在 IO 密集型任务中使用多线程可以大大地加速任务的处理。一般线程数设置为 2*CPU 核心数。

②、**任务队列的选择**

使用有界队列可以避免资源耗尽的风险，但是可能会导致任务被拒绝

使用无界队列虽然可以避免任务被拒绝，但是可能会导致内存耗尽

一般需要设置有界队列的大小，比如 LinkedBlockingQueue 在构造的时候可以传入参数来限制队列中任务数据的大小，这样就不会因为无限往队列中扔任务导致系统的 oom。

③、**尽量使用自定义的线程池**，而不是使用 Executors 创建的线程池，因为 newFixedThreadPool 线程池由于使用了 LinkedBlockingQueue，队列的容量默认无限大，实际使用中出现任务过多时会导致内存溢出；

newCachedThreadPool 线程池由于核心线程数无限大，当任务过多的时候会导致创建大量的线程，可能机器负载过高导致服务宕机。

### 8.你能设计并实现一个线程池吗？

**核心流程**：

线程池中有 N 个工作线程

把任务提交给线程池运行

如果线程池已满，把任务放入队列

最后当有空闲时，获取队列中任务来执行

**代码示例**：

```java
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;

public class SimpleThreadPool {

    private final BlockingQueue<Runnable> workQueue;
    private final int corePoolSize;
    private final int maximumPoolSize;
    private final long keepAliveTime;
    private final TimeUnit unit;
    private volatile boolean isShutdown = false;

    private final AtomicInteger activeThreads = new AtomicInteger(0);
    private final ThreadFactory threadFactory;

    public SimpleThreadPool(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, ThreadFactory threadFactory) {
        this.corePoolSize = corePoolSize;
        this.maximumPoolSize = maximumPoolSize;
        this.keepAliveTime = keepAliveTime;
        this.unit = unit;
        this.threadFactory = threadFactory;
        this.workQueue = new LinkedBlockingQueue<>();
    }

    public void execute(Runnable command) {
        if (isShutdown) {
            throw new IllegalStateException("Executor has been shutdown");
        }

        // 尝试将任务放入队列
        if (workQueue.offer(command)) {
            addWorker();
        } else {
            // 队列已满，尝试创建新线程
            startWorker(command);
        }
    }

    private void addWorker() {
        if (activeThreads.get() < corePoolSize) {
            startWorker(null);
        }
    }

    private void startWorker(Runnable firstTask) {
        Thread worker = threadFactory.newThread(new Worker(firstTask));
        worker.start();
    }

    private class Worker implements Runnable {
        private Runnable currentTask;

        public Worker(Runnable firstTask) {
            this.currentTask = firstTask;
        }

        @Override
        public void run() {
            if (currentTask != null) {
                try {
                    currentTask.run();
                } finally {
                    currentTask = null;
                }
            }

            while (!isShutdown) {
                try {
                    currentTask = workQueue.take();
                    currentTask.run();
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                    break;
                } catch (RuntimeException e) {
                    // 处理异常
                    handleException(e);
                }
            }

            activeThreads.decrementAndGet();
        }
    }

    private void handleException(RuntimeException e) {
        System.err.println("Caught exception: " + e.getMessage());
        e.printStackTrace();
    }

    public void shutdown() {
        isShutdown = true;
        // 中断所有空闲线程
        interruptIdleWorkers();
    }

    private void interruptIdleWorkers() {
        for (int i = 0; i < activeThreads.get(); i++) {
            Thread worker = new Thread(() -> {});
            worker.interrupt();
        }
    }

    public static void main(String[] args) {
        SimpleThreadPool executor = new SimpleThreadPool(5, 10, 60, TimeUnit.SECONDS, new CustomThreadFactory("MyThread"));

        for (int i = 0; i < 20; i++) {
            int taskId = i;
            executor.execute(() -> {
                System.out.println("Processing task " + taskId);
                try {
                    Thread.sleep(1000);  // 模拟任务执行时间
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                    System.out.println("Task interrupted");
                }
            });
        }

        // 关闭线程池
        executor.shutdown();
    }
}

class CustomThreadFactory implements ThreadFactory {
    private final AtomicInteger threadNumber = new AtomicInteger(1);
    private final String namePrefix;

    public CustomThreadFactory(String namePrefix) {
        this.namePrefix = namePrefix;
    }

    @Override
    public Thread newThread(Runnable r) {
        Thread t = new Thread(r, namePrefix + threadNumber.getAndIncrement());
        t.setUncaughtExceptionHandler((thread, throwable) -> {
            System.out.println("Caught exception in thread " + thread.getName() + ": " + throwable.getMessage());
            throwable.printStackTrace();
        });
        return t;
    }
}
```

### 9.调用 start()方法时会执行 run()方法，那怎么不直接调用 run()方法？

在 Java 中，`start()` 方法用于启动一个线程，而 `run()` 方法则用于执行线程的任务。当你调用 `start()` 方法时，它将启动一个新的线程，并使其运行 `run()` 方法。

如果直接调用run()方法，那么run()方法就在当前线程中运行，没有新的线程被创建，也就没有实现多线程的效果。

start() 方法的调用会告诉 JVM 准备好所有必要的新线程结构，分配其所需资源，并调用线程的 run() 方法在这个新线程中执行。

### 10.线程有哪些常用的调度方法？

线程的等待与通知:

①、**wait()**：当一个线程 A 调用一个共享变量的 wait() 方法时，线程 A 会被阻塞挂起，直到发生下面几种情况才会返回 ：

线程 B 调用了共享对象 notify()或者 notifyAll() 方法；
其他线程调用了线程 A 的 interrupt() 方法，线程 A 抛出 InterruptedException 异常返回。

②、**wait(long timeout)** ：这个方法相比 wait() 方法多了一个超时参数，它的不同之处在于，如果线程 A 调用共享对象的 wait(long timeout)方法后，没有在指定的 timeout 时间内被其它线程唤醒，那么这个方法还是会因为超时而返回。

③、**wait(long timeout, int nanos)**，其内部调用的是 wait(long timout) 方法。

唤醒线程主要有下面两个方法：

①、**notify()**：一个线程 A 调用共享对象的 notify() 方法后，会唤醒一个在这个共享变量上调用 wait 系列方法后被挂起的线程。

一个共享变量上可能会有多个线程在等待，具体唤醒哪个等待的线程是随机的。

②、**notifyAll()**：不同于在共享变量上调用 notify() 方法会唤醒被阻塞到该共享变量上的一个线程，notifyAll 方法会唤醒所有在该共享变量上调用 wait 系列方法而被挂起的线程。

Thread 类还提供了一个 join() 方法，意思是如果一个线程 A 执行了 thread.join()，当前线程 A 会等待 thread 线程终止之后才从 thread.join() 返回。

线程休眠

**sleep(long millis)**：Thread 类中的静态方法，当一个执行中的线程 A 调用了 Thread 的 sleep 方法后，线程 A 会暂时让出指定时间的执行权。

但是线程 A 所拥有的监视器资源，比如锁，还是持有不让出的。指定的睡眠时间到了后该方法会正常返回，接着参与 CPU 的调度，获取到 CPU 资源后就可以继续运行。

让出优先权

**yield()**：Thread 类中的静态方法，当一个线程调用 yield 方法时，实际是在暗示线程调度器，当前线程请求让出自己的 CPU，但是线程调度器可能会“装看不见”忽略这个暗示。

线程中断

Java 中的线程中断是一种线程间的协作模式，通过设置线程的中断标志并不能直接终止该线程的执行。被中断的线程会根据中断状态自行处理。

**void interrupt()** 方法：中断线程，例如，当线程 A 运行时，线程 B 可以调用线程 interrupt() 方法来设置线程的中断标志为 true 并立即返回。设置标志仅仅是设置标志, 线程 B 实际并没有被中断，会继续往下执行。

**boolean isInterrupted()** 方法： 检测当前线程是否被中断。

**boolean interrupted()** 方法： 检测当前线程是否被中断，与 isInterrupted 不同的是，该方法如果发现当前线程被中断，则会清除中断标志。

为了响应中断，线程的执行代码应该这样编写：

```java
public void run() {
    try {
        while (!Thread.currentThread().isInterrupted()) {
            // 执行任务
        }
    } catch (InterruptedException e) {
        // 线程被中断时的清理代码
    } finally {
        // 线程结束前的清理代码
    }
}
```

stop 方法用来强制线程停止执行，目前已经处于废弃状态，因为 stop 方法会导致线程立即停止，可能会在不一致的状态下释放锁，破坏对象的一致性，导致难以发现的错误和资源泄漏。

### 11.线程的生命周期和状态？

**新建状态（New）**：

当创建一个新的线程对象时，线程处于新建状态。此时，JVM已经为线程分配了内存，但尚未开始执行线程。

**就绪状态（Runnable）**：

当调用线程对象的 start() 方法后，线程进入就绪状态。这意味着线程已经准备好被执行，但是还没有被调度器选中占用CPU时间。处于就绪状态的线程被放入可运行池中等待CPU时间片。

**运行状态（Running）**：

当就绪状态的线程被调度器选中并分配了CPU时间片后，线程开始执行其 run() 方法内的代码。此时线程处于运行状态。

**阻塞状态（Blocked）**：

线程由于某些原因暂时停止运行，比如等待I/O操作完成、等待用户输入、等待锁的获取等。阻塞状态下的线程不会占用CPU时间片，只有当阻塞原因解除后，线程才能重新进入就绪状态。

**等待状态（Waiting）**：

线程调用了 Object.wait() 方法或者其他会导致线程等待的方法时，线程会进入等待状态。在此状态下，线程会释放持有的锁，并等待其他线程的通知（通过 notify() 或 notifyAll() 方法）才能继续执行。

**定时等待状态（Timed Waiting）**：

当线程调用了一些具有指定等待时间的方法，如 Thread.sleep()、Object.wait(long timeout) 或 Thread.join(long millis) 时，线程会进入定时等待状态。在指定的时间过后，线程会自动恢复到就绪状态。

**死亡状态（Terminated）**：

当线程执行完毕或因异常退出了 run() 方法后，线程结束其生命周期，进入死亡状态。此时线程不再执行任何操作，也不会被再次调度。

### 12.什么是线程的上下文切换？

线程的上下文切换是指操作系统在多线程环境中，为了实现线程间的切换而进行的一系列操作。具体来说，当操作系统需要从一个线程切换到另一个线程时，它需要保存当前线程的状态（即上下文信息），然后加载另一个线程的状态，使得后者可以在CPU上继续执行。这个过程称为上下文切换。

**上下文切换的过程主要包括以下几个步骤：**

**保存当前线程的上下文：**

记录当前线程的CPU寄存器值（如程序计数器、状态寄存器等）。

保存当前线程的程序状态（如堆栈指针、栈顶指针等）。

更新当前线程的状态信息（如将其标记为就绪或等待状态）。

**选择新的线程：**

操作系统从就绪队列中选择一个线程作为下一个执行的线程。

**恢复新线程的上下文：**

加载新线程的CPU寄存器值。

恢复新线程的程序状态。

将新线程的状态更新为运行状态。

**上下文切换的影响**  

**开销**：上下文切换本身需要消耗时间和CPU资源，包括保存和恢复寄存器、更新任务控制块（TCB）等。频繁的上下文切换会导致额外的开销，从而影响系统的整体性能。

**中断**：上下文切换通常伴随着中断的发生，这会进一步增加系统的开销。

**并发度**：虽然上下文切换使得多个线程能够在单个CPU上并发执行，但如果切换过于频繁，反而会降低并发执行的效率。

### 13.守护线程了解吗？

守护线程（Daemon Thread）是在计算机程序中一种特殊的线程类型，主要用于执行后台任务，而不干扰程序的主要功能。守护线程的特点是它们的存在是为了服务其他线程或整个应用程序，而不是直接为用户提供服务。当所有的非守护线程（也称作用户线程）都结束执行后，Java虚拟机（JVM）会自动终止所有守护线程并退出程序，即使守护线程仍在运行中。

**守护线程的特点：**  

**生命周期**：

守护线程的生命周期与应用程序的主线程（或非守护线程）紧密相关。*当所有的非守护线程都终止时，即使还有守护线程在运行，虚拟机也会认为程序已经不再需要继续执行，并会停止所有守护线程，然后退出程序。*

**服务性质**：

守护线程通常用于执行那些不需要用户交互、对结果不敏感，且在程序运行过程中持续进行的后台任务。例如，垃圾回收（GC）线程、日志记录线程、监控线程、定时任务线程等。

**创建与设置**：

在Java中，线程默认创建为非守护线程。若要将其设置为守护线程，需要在创建线程后，通过 Thread.setDaemon(true) 方法进行设置。注意，只能在启动线程之前设置线程为守护线程。

**退出行为**：

*当主线程或最后一个非守护线程结束时，即使守护线程还在运行（如循环未结束、阻塞在 I/O 操作等），JVM 也会强制终止守护线程，不会等待其自然结束。*因此，守护线程不应该持有任何需要在程序退出时释放的重要资源，也不应该执行任何必须在程序退出前完成的清理工作。

**异常处理**：

如果守护线程抛出了未捕获的异常，且没有设置默认的未捕获异常处理器，那么该异常会被忽略，并且会导致守护线程立即终止。这与非守护线程不同，非守护线程抛出未捕获异常通常会导致整个程序终止。

### 14.线程间的通信方式？

①、**使用共享对象**，多个线程可以访问和修改同一个对象，从而实现信息的传递，比如说 volatile 和 synchronized 关键字。

关键字 volatile 用来修饰成员变量，告知程序任何对该变量的访问均需要从共享内存中获取，而对它的改变必须同步刷新回共享内存，保证所有线程对变量访问的可见性。

关键字 synchronized 可以修饰方法，或者以同步代码块的形式来使用，确保多个线程在同一个时刻，只能有一个线程在执行某个方法或某个代码块。

```java
public class SharedObject {
    private String message;
    private boolean hasMessage = false;

    public synchronized void writeMessage(String message) {
        while (hasMessage) {
            try {
                wait();
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }
        this.message = message;
        hasMessage = true;
        notifyAll();
    }

    public synchronized String readMessage() {
        while (!hasMessage) {
            try {
                wait();
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }
        hasMessage = false;
        notifyAll();
        return message;
    }
}

public class Main {
    public static void main(String[] args) {
        SharedObject sharedObject = new SharedObject();

        Thread writer = new Thread(() -> {
            sharedObject.writeMessage("Hello from Writer!");
        });

        Thread reader = new Thread(() -> {
            String message = sharedObject.readMessage();
            System.out.println("Reader received: " + message);
        });

        writer.start();
        reader.start();
    }
}
```

②、**使用 wait() 和 notify()**，例如，生产者-消费者模式中，生产者生产数据，消费者消费数据，通过 wait() 和 notify() 方法可以实现生产和消费的协调。

一个线程调用共享对象的 wait() 方法时，它会进入该对象的等待池，并释放已经持有的该对象的锁，进入等待状态，直到其他线程调用相同对象的 notify() 或 notifyAll() 方法。

一个线程调用共享对象的 notify() 方法时，它会唤醒在该对象等待池中等待的一个线程，使其进入锁池，等待获取锁。

Condition 也提供了类似的方法，await() 负责等待、signal() 和 signalAll() 负责通知。

通常与锁（特别是 ReentrantLock）一起使用，为线程提供了一种等待某个条件成真的机制，并允许其他线程在该条件变化时通知等待线程。更灵活、更强大。

```java
class MessageBox {
    private String message;
    private boolean empty = true;

    public synchronized void produce(String message) {
        while (!empty) {
            try {
                wait();
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }
        empty = false;
        this.message = message;
        notifyAll();
    }

    public synchronized String consume() {
        while (empty) {
            try {
                wait();
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }
        empty = true;
        notifyAll();
        return message;
    }
}

public class Main {
    public static void main(String[] args) {
        MessageBox box = new MessageBox();

        Thread producer = new Thread(() -> {
            box.produce("Message from producer");
        });

        Thread consumer = new Thread(() -> {
            String message = box.consume();
            System.out.println("Consumer received: " + message);
        });

        producer.start();
        consumer.start();
    }
}
```

③、**使用 Exchanger**，Exchanger 是一个同步点，可以在两个线程之间交换数据。一个线程调用 exchange() 方法，将数据传递给另一个线程，同时接收另一个线程的数据。

```java
import java.util.concurrent.Exchanger;

public class Main {
    public static void main(String[] args) {
        Exchanger<String> exchanger = new Exchanger<>();

        Thread thread1 = new Thread(() -> {
            try {
                String message = "Message from thread1";
                String response = exchanger.exchange(message);
                System.out.println("Thread1 received: " + response);
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        });

        Thread thread2 = new Thread(() -> {
            try {
                String message = "Message from thread2";
                String response = exchanger.exchange(message);
                System.out.println("Thread2 received: " + response);
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        });

        thread1.start();
        thread2.start();
    }
}
```

④、**使用 CompletableFuture**，CompletableFuture 是 Java 8 引入的一个类，支持异步编程，允许线程在完成计算后将结果传递给其他线程。

```java
public class Main {
    public static void main(String[] args) {
        CompletableFuture<String> future = CompletableFuture.supplyAsync(() -> {
            // 模拟长时间计算
            return "Message from CompletableFuture";
        });

        future.thenAccept(message -> {
            System.out.println("Received: " + message);
        });
    }
}
```

### 15.sleep 和 wait 的区别？

sleep() 和 wait() 是 Java 中用于暂停当前线程的两个重要方法，sleep 是让当前线程休眠，不涉及对象类，也不需要获取对象的锁，属于 Thread 类的方法；wait 是让获得对象锁的线程实现等待，前提要获得对象的锁，属于 Object 类的方法。

①、**所属类不同**

sleep() 方法专属于 Thread 类。
wait() 方法专属于 Object 类。

②、**锁行为不同**

当线程执行 sleep 方法时，它不会释放任何锁。也就是说，如果一个线程在持有某个对象的锁时调用了 sleep，它在睡眠期间仍然会持有这个锁。

```java
class SleepDoesNotReleaseLock {

    private static final Object lock = new Object();

    public static void main(String[] args) throws InterruptedException {
        Thread sleepingThread = new Thread(() -> {
            synchronized (lock) {
                System.out.println("Thread 1 会继续持有锁，并且进入睡眠状态");
                try {
                    Thread.sleep(5000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println("Thread 1 醒来了，并且释放了锁");
            }
        });

        Thread waitingThread = new Thread(() -> {
            synchronized (lock) {
                System.out.println("Thread 2 进入同步代码块");
            }
        });

        sleepingThread.start();
        Thread.sleep(1000);
        waitingThread.start();
    }
}
```

```console
Thread 1 会继续持有锁，并且进入睡眠状态
Thread 1 醒来了，并且释放了锁
Thread 2 进入同步代码块
```

从输出中我们可以看到，waitingThread 必须等待 sleepingThread 完成睡眠后才能进入同步代码块。

而当线程执行 wait 方法时，它会释放它持有的那个对象的锁，这使得其他线程可以有机会获取该对象的锁。

```java
class WaitReleasesLock {

    private static final Object lock = new Object();

    public static void main(String[] args) throws InterruptedException {
        Thread waitingThread = new Thread(() -> {
            synchronized (lock) {
                try {
                    System.out.println("Thread 1 持有锁，准备等待 5 秒");
                    lock.wait(5000);
                    System.out.println("Thread 1 醒来了，并且退出同步代码块");
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        });

        Thread notifyingThread = new Thread(() -> {
            synchronized (lock) {
                System.out.println("Thread 2 尝试唤醒等待中的线程");
                lock.notify();
                System.out.println("Thread 2 执行完了 notify");
            }
        });

        waitingThread.start();
        Thread.sleep(1000);
        notifyingThread.start();
    }
}
```

```console
Thread 1 持有锁，准备等待 5 秒
Thread 2 尝试唤醒等待中的线程
Thread 2 执行完了 notify
Thread 1 醒来了，并且退出同步代码块
```

这表明 waitingThread 在调用 wait 后确实释放了锁。

③、**使用条件不同**

sleep() 方法可以在任何地方被调用。

wait() 方法必须在同步代码块或同步方法中被调用，这是因为调用 wait() 方法的前提是当前线程必须持有对象的锁。否则会抛出 IllegalMonitorStateException 异常。

④、**唤醒方式不同**

sleep() 方法在指定的时间过后，线程会自动唤醒继续执行。

wait() 方法需要依靠 notify()、notifyAll() 方法或者 wait() 方法中指定的等待时间到期来唤醒线程。

⑤、**抛出异常不同**

sleep() 方法在等待期间，如果线程被中断，会抛出 InterruptedException。

如果线程被中断或等待时间到期时，wait() 方法同样会在等待期间抛出 InterruptedException。

sleep()的用法：

```java
class SleepExample {
    public static void main(String[] args) {
        Thread thread = new Thread(() -> {
            System.out.println("线程准备休眠 2 秒");
            try {
                Thread.sleep(2000); // 线程将睡眠2秒
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println("线程醒来了");
        });

        thread.start();
    }
}
```

wait()的用法：

```java
class WaitExample {
    public static void main(String[] args) {
        final Object lock = new Object();

        Thread thread = new Thread(() -> {
            synchronized (lock) {
                try {
                    System.out.println("线程准备等待 2 秒");
                    lock.wait(2000); // 线程会等待2秒，或者直到其他线程调用 lock.notify()/notifyAll()
                    System.out.println("线程结束等待");
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        });

        thread.start();
    }
}
```

### 16.举例一个线程安全的使用场景？

线程安全是 Java 并发编程中一个非常重要的概念，它指的是多线程环境下，多个线程对共享资源的访问不会导致数据的不一致性。

一个常见的使用场景是在实现单例模式时确保线程安全。

单例模式确保一个类只有一个实例，并提供一个全局访问点。在多线程环境下，如果多个线程同时尝试创建实例，单例类必须确保只创建一个实例。

饿汉式是一种比较直接的实现方式，它通过在类加载时就立即初始化单例对象来保证线程安全。

```java
public class EagerSingleton {
    private static final EagerSingleton instance = new EagerSingleton();

    private EagerSingleton() {}

    public static EagerSingleton getInstance() {
        return instance;
    }
}
```

这种方式简单高效，但由于实例在类加载时就已经创建，可能会浪费内存资源。

懒汉式是一种更常用的实现方式，它通过延迟初始化单例对象，在第一次使用时才创建实例。

```java
public class LazySingleton {
    private volatile static LazySingleton instance;

    private LazySingleton() {}

    public static LazySingleton getInstance() {
        if (instance == null) {
            synchronized (LazySingleton.class) {
                if (instance == null) {
                    instance = new LazySingleton();
                }
            }
        }
        return instance;
    }
}
```

双重检查锁定确保了线程安全，并且只在第一次创建实例时加锁，提高了效率。

### 17.请说一下 ThreadLocal 的作用和使用场景？

#### ThreadLocal是什么？

ThreadLocal 是 Java 中提供的一种用于实现线程局部变量的工具类。它允许每个线程都拥有自己的独立副本，从而实现线程隔离，用于解决多线程中共享对象的线程安全问题。

#### ThreadLocal 的工作原理  

ThreadLocal 的核心思想是为每个线程提供一个独立的变量副本，这样每个线程都可以独立地修改自己的副本，而不会影响到其他线程的数据。ThreadLocal 类本身维护了一个映射表（ThreadLocalMap），其中键是 ThreadLocal 对象，值则是每个线程对应的变量副本。

#### ThreadLocal 的使用场景  

**线程上下文传递**  

在跨线程调用的场景中，可以使用 ThreadLocal 来存储和传递线程上下文信息。例如，可以将请求 ID、用户身份信息等存储在线程局部变量中，以便在后续的请求处理过程中方便地访问这些信息。

**数据库连接管理**  

在使用数据库连接池的情况下，可以将数据库连接存储在 ThreadLocal 中，这样每个线程可以独立管理自己的数据库连接，避免了线程间的竞争和冲突。例如，MyBatis 中的 SqlSession 对象就使用 ThreadLocal 来存储当前线程的数据库会话信息。

**事务管理**  

在需要手动管理事务的场景下，可以使用 ThreadLocal 来存储事务上下文信息，每个线程可以独立控制自己的事务，保证事务的隔离性。Spring 中的 TransactionSynchronizationManager 就使用 ThreadLocal 来存储事务相关的上下文信息。

**工具类或辅助类**  

有时为了方便，可以将一些工具类或辅助类的实例存储在 ThreadLocal 中，这样在多线程环境中每个线程都有自己独立的实例，避免了线程间的干扰。

**临时数据存储**  

在线程内部，如果需要存储一些临时数据，并且这些数据只在当前线程中有效，可以使用 ThreadLocal 来存储这些数据，避免了复杂的参数传递。

#### ThreadLocal 的使用步骤

①、创建 ThreadLocal

```java
//创建一个ThreadLocal变量
public static ThreadLocal<String> localVariable = new ThreadLocal<>();
```

②、设置 ThreadLocal 的值

```java
//设置ThreadLocal变量的值
localVariable.set("java");
```

③、获取 ThreadLocal 的值

```java
//获取ThreadLocal变量的值
String value = localVariable.get();
```

④、删除 ThreadLocal 的值

```java
//删除ThreadLocal变量的值
localVariable.remove();
```

### 18.除了 ThreadLocal，还有什么解决线程安全问题的方法？

①、Java 中的 synchronized 关键字可以用于方法和代码块，确保同一时间只有一个线程可以执行特定的代码段。

```java
public synchronized void method() {
    // 线程安全的操作
}
```

②、Java 并发包（java.util.concurrent.locks）中提供了 Lock 接口和一些实现类，如 ReentrantLock。相比于 synchronized，ReentrantLock 提供了公平锁和非公平锁。

```java
ReentrantLock lock = new ReentrantLock();

public void method() {
    lock.lock();
    try {
        // 线程安全的操作
    } finally {
        lock.unlock();
    }
}
```

③、Java 并发包还提供了一组原子变量类（如 AtomicInteger，AtomicLong 等），它们利用 CAS（比较并交换），实现了无锁的原子操作，适用于简单的计数器场景。

```java
AtomicInteger atomicInteger = new AtomicInteger(0);

public void increment() {
    atomicInteger.incrementAndGet();
}
```

④、Java 并发包提供了一些线程安全的集合类，如 ConcurrentHashMap，CopyOnWriteArrayList 等。这些集合类内部实现了必要的同步策略，提供了更高效的并发访问。

```java
ConcurrentHashMap<String, String> map = new ConcurrentHashMap<>();
```

⑤、volatile 变量保证了变量的可见性，修改操作是立即同步到主存的，读操作从主存中读取。

```java
private volatile boolean flag = false;
```

### 19.ThreadLocal 怎么实现的呢？

ThreadLocal 本身并不存储任何值，它只是作为一个映射，来映射线程的局部变量。当一个线程调用 ThreadLocal 的 set 或 get 方法时，实际上是访问线程自己的 ThreadLocal.ThreadLocalMap。

ThreadLocalMap 是 ThreadLocal 的静态内部类，它内部维护了一个 Entry 数组，key 是 ThreadLocal 对象，value 是线程的局部变量本身。

早期的 ThreadLocal 不是这样的，它的 ThreadLocalMap 中使用 Thread 作为 key，这也是最简单的实现方式。

优化后的方案有两个好处，一个是 Map 中存储的键值对变少了；另一个是 ThreadLocalMap 的生命周期和线程一样长，线程销毁的时候，ThreadLocalMap 也会被销毁。

Entry 继承了 WeakReference，它限定了 key 是一个[弱引用](#弱引用weak-reference)，弱引用的好处是当内存不足时，JVM 会回收 ThreadLocal 对象，并且将其对应的 Entry 的 value 设置为 null，这样在很大程度上可以避免内存泄漏。

**ThreadLocal 的实现原理**就是，每个线程维护一个 Map，key 为 ThreadLocal 对象，value 为想要实现线程隔离的对象。

1、当需要存线程隔离的对象时，通过 ThreadLocal 的 set 方法将对象存入 Map 中。

2、当需要取线程隔离的对象时，通过 ThreadLocal 的 get 方法从 Map 中取出对象。

3、Map 的大小由 ThreadLocal 对象的多少决定。

### 20.java中的引用类型？

在 Java 中，引用类型有四种：强引用（Strong Reference）、软引用（Soft Reference）、弱引用（Weak Reference）和虚引用（Phantom Reference）。每种引用类型都有其特定的用途和行为。下面详细介绍这四种引用类型及其应用场景。

#### 强引用（Strong Reference）

特点：

最常用的引用类型。

只要有强引用指向一个对象，垃圾回收器不会回收该对象。

对象的生命周期最长。

```java
public class StrongReferenceExample {
    public static void main(String[] args) {
        Object obj = new Object(); // 强引用
        obj = null; // 断开强引用
        // 如果没有其他强引用指向这个对象，垃圾回收器可以回收它
    }
}
```

应用场景：

适用于需要长期保持对象引用的场景，如全局变量、成员变量等。

#### 软引用（Soft Reference）

特点：

软引用用于描述一些非必需但仍然有用的对象。

当系统即将发生内存溢出（OutOfMemoryError）时，会尝试回收软引用指向的对象。

软引用比弱引用更持久，只有在系统内存不足时才会被回收。

```java
import java.lang.ref.SoftReference;

public class SoftReferenceExample {
    public static void main(String[] args) {
        Object obj = new Object();
        SoftReference<Object> softRef = new SoftReference<>(obj);
        obj = null; // 断开强引用
        
        // 如果没有其他强引用指向这个对象，垃圾回收器可以回收它
        System.gc(); // 请求垃圾回收
        
        // 检查对象是否已被回收
        if (softRef.get() == null) {
            System.out.println("对象已被垃圾回收");
        } else {
            System.out.println("对象还未被垃圾回收");
        }
    }
}
```

应用场景：

适用于实现缓存，特别是当缓存对象较大时，可以使用软引用来自动释放内存，避免 OutOfMemoryError。

例如，java.util.WeakHashMap 使用软引用作为键。

#### 弱引用（Weak Reference）

特点：

弱引用用于描述那些非必需的对象。

当垃圾回收器运行时，无论系统内存是否充足，都会回收弱引用指向的对象。

弱引用比软引用更容易被回收。

```java
import java.lang.ref.WeakReference;

public class WeakReferenceExample {
    public static void main(String[] args) {
        Object obj = new Object();
        WeakReference<Object> weakRef = new WeakReference<>(obj);
        obj = null; // 断开强引用
        
        // 如果没有其他强引用指向这个对象，垃圾回收器可以回收它
        System.gc(); // 请求垃圾回收
        
        // 检查对象是否已被回收
        if (weakRef.get() == null) {
            System.out.println("对象已被垃圾回收");
        } else {
            System.out.println("对象还未被垃圾回收");
        }
    }
}
```

应用场景：

适用于实现缓存，特别是当缓存对象较小且不需要长期保存时。

例如，java.lang.ref.WeakHashMap 使用弱引用作为键。

#### 虚引用（Phantom Reference）

特点：

虚引用是最弱的一种引用关系。

虚引用并不会决定对象的生命周期。

虚引用主要用于跟踪对象的垃圾回收状态。

虚引用必须与引用队列（ReferenceQueue）关联使用。

```java
import java.lang.ref.PhantomReference;
import java.lang.ref.ReferenceQueue;

public class PhantomReferenceExample {
    public static void main(String[] args) {
        Object obj = new Object();
        ReferenceQueue<Object> queue = new ReferenceQueue<>();
        PhantomReference<Object> phantomRef = new PhantomReference<>(obj, queue);
        obj = null; // 断开强引用
        
        // 如果没有其他强引用指向这个对象，垃圾回收器可以回收它
        System.gc(); // 请求垃圾回收
        
        // 检查对象是否已被回收
        if (queue.poll() != null) {
            System.out.println("对象已被垃圾回收");
        } else {
            System.out.println("对象还未被垃圾回收");
        }
    }
}
```

应用场景：

适用于跟踪对象的垃圾回收状态，通常用于实现对象的最终化处理。

例如，可以用来实现对象的清理逻辑，确保对象被垃圾回收后执行某些清理操作。

### 21.ThreadLocal内存泄漏是怎么回事？

通常情况下，随着线程 Thread 的结束，其内部的 ThreadLocalMap 也会被回收，从而避免了内存泄漏。

但如果一个线程一直在运行，并且其 ThreadLocalMap 中的 Entry.value 一直指向某个强引用对象，那么这个对象就不会被回收，从而导致内存泄漏。当 Entry 非常多时，可能就会引发更严重的内存溢出问题。

**如何解决内存泄漏问题？**  

使用完 ThreadLocal 后，及时调用 remove() 方法释放内存空间。

```java
try {
    threadLocal.set(value);
    // 执行业务操作
} finally {
    threadLocal.remove(); // 确保能够执行清理
}
```

`remove()` 方法会将当前线程的 ThreadLocalMap 中的所有 key 为 null 的 Entry 全部清除，这样就能避免内存泄漏问题。

```java
private void remove(ThreadLocal<?> key) {
    Entry[] tab = table;
    int len = tab.length;
    int i = key.threadLocalHashCode & (len-1);
    for (Entry e = tab[i];
            e != null;
            e = tab[i = nextIndex(i, len)]) {
        if (e.get() == key) {
            e.clear();
            expungeStaleEntry(i);
            return;
        }
    }
}

public void clear() {
    this.referent = null;
}
```

### 22.ThreadLocal结合线程池使用导致的复用问题？

当 ThreadLocal 与线程池结合使用时，特别容易出现复用问题，主要原因如下：

线程复用：线程池的一个主要特性就是它可以重用已经创建好的线程来执行新任务。这意味着同一个线程可能会被执行多个不同的任务。

数据残留：如果前一个任务在使用 ThreadLocal 变量后没有清理，那么当线程被复用执行下一个任务时，可能会读取到前一个任务留下的 ThreadLocal 变量的值。这对于需要独立上下文的新任务来说是不正确的，可能导致数据混乱或错误的行为。

避免复用问题：为了避免出现复用问题，可以在使用 ThreadLocal 后调用 ThreadLocal 的 remove() 方法来清除 ThreadLocal 变量的值。这样，当线程被复用时，ThreadLocal 变量中的值会被重置，确保每个任务都有自己的独立上下文。

### 23.ThreadLocal的删除过程？

当一个 ThreadLocal 对象不再被任何强引用持有时，它的生命周期就结束了。此时，ThreadLocalMap 中对应条目的键变成了 null。当 ThreadLocal 的 get() 或 set() 方法被调用时，ThreadLocalMap 会清理掉所有键为 null 的条目，这些条目即为那些已经没有强引用的 ThreadLocal 对象。

此外，如果希望在 ThreadLocal 对象还存在时就清除某个线程上的绑定值，可以调用 ThreadLocal 的 remove() 方法。这会从当前线程的 ThreadLocalMap 中移除该 ThreadLocal 对象的条目。

### 24.ThreadLocalMap的源码分析？

**元素数组**  

一个 table 数组，存储 Entry 类型的元素，Entry 是 ThreaLocal 弱引用作为 key，Object 作为 value 的结构。

```java
 private Entry[] table;
```

**散列方法**  

散列方法就是怎么把对应的 key 映射到 table 数组的相应下标，ThreadLocalMap 用的是哈希取余法，取出 key 的 threadLocalHashCode，然后和 table 数组长度减一&运算（相当于取余）。

```java
int i = key.threadLocalHashCode & (table.length - 1);
```

这里的 threadLocalHashCode 计算有点东西，每创建一个 ThreadLocal 对象，它就会新增0x61c88647，这个值很特殊，它是斐波那契数 也叫 黄金分割数。hash增量为 这个数字，带来的好处就是 hash 分布非常均匀。

```java
    private static final int HASH_INCREMENT = 0x61c88647;

    private static int nextHashCode() {
        return nextHashCode.getAndAdd(HASH_INCREMENT);
    }
```

### 25.ThreadLocalMap如何解决Hash冲突？

使用**开放地址法**解决哈希冲突。若果某个位置被占用，则继续在当前位置的下一个位置查找，直到找到空位置为止。

### 26.ThreadLocalMap的扩容？

**扩容条件**：

当向 ThreadLocalMap 添加一个新的 ThreadLocal 变量时，如果当前 ThreadLocalMap 的大小达到了某个阈值（通常是当前容量的三分之二），那么就会触发扩容操作。

**扩容过程**：

扩容操作首先会检查当前的 ThreadLocalMap 是否为空，以及是否大于当前容量的三分之二。如果满足条件，则会进行扩容。
扩容的具体操作是创建一个新的数组，其大小通常是原数组大小的两倍。
接着，旧数组中的所有元素会被重新散列，并放入新的数组中。
在此过程中，如果发现某些 ThreadLocal 对象已经被垃圾回收（即它们的引用变为 null），那么这些条目会被清理掉。

**重新散列**：

重新散列的过程涉及到计算每个 ThreadLocal 对象的哈希值，并确定其在新数组中的位置。
这个过程确保了即使在扩容后，ThreadLocal 对象也能正确地映射到 ThreadLocalMap 中的位置。

**更新引用**：

完成重新散列后，ThreadLocalMap 内部的指针会被更新以指向新的数组。

**垃圾回收**：

在扩容过程中，还会检查是否有已经被垃圾回收的 ThreadLocal 对象，并进行相应的清理工作。这是为了防止内存泄漏的发生。

### 27.父子线程怎么共享数据？

使用 InheritableThreadLocal

InheritableThreadLocal 是 ThreadLocal 的一个子类，它允许子线程继承父线程中的 ThreadLocal 变量。当创建子线程时，如果父线程中有 InheritableThreadLocal 变量，那么这些变量会被复制到子线程中。

```java
// 创建一个可继承的线程局部变量
InheritableThreadLocal<String> inheritableThreadLocal = new InheritableThreadLocal<>();
inheritableThreadLocal.set("Parent Value");

// 创建一个子线程
Thread childThread = new Thread(() -> {
    System.out.println("Child Thread Value: " + inheritableThreadLocal.get());
});

childThread.start();
```

在这个例子中，子线程启动时能够访问到父线程中设置的 InheritableThreadLocal 变量的值。

### 28.为什么线程要使用自己的内存？

第一，在多线程环境中，如果所有线程都直接操作主内存中的共享变量，会引发更多的内存访问竞争，这不仅影响性能，还增加了线程安全问题的复杂度。*通过让每个线程使用本地内存，可以减少对主内存的直接访问和竞争，从而提高程序的并发性能。*

第二，现代 CPU 为了优化执行效率，可能会对指令进行乱序执行（指令重排序）。*使用本地内存（CPU 缓存和寄存器）可以在不影响最终执行结果的前提下，使得 CPU 有更大的自由度来乱序执行指令，从而提高执行效率。*

### 29.对原子性、可见性、有序性的理解？

**原子性**：原子性指的是一个操作是不可分割、不可中断的，要么全部执行并且执行的过程不会被任何因素打断，要么就全不执行。

**可见性**：可见性指的是一个线程修改了共享变量的值，其他线程能够立即看到这个修改。

**有序性**：有序性指的是对于一个线程的执行代码，从前往后依次执行，单线程下可以认为程序是有序的，但是并发时有可能会发生指令重排。

如何确保原子性、可见性、有序性？

**原子性**：JMM 只能保证基本的原子性，如果要保证一个代码块的原子性，需要使用synchronized 。

**可见性**：Java 是利用volatile关键字来保证可见性的，除此之外，final和synchronized也能保证可见性。

**有序性**：synchronized或者volatile都可以保证多线程之间操作的有序性。

### 30.什么是指令重排？

指令重排是指编译器或处理器为了优化性能而改变程序中指令执行顺序的行为。虽然重排后的指令在逻辑上仍然遵循程序的语义，但在实际执行时可能会导致一些意想不到的问题，特别是在多线程环境中。

#### 指令重排的原因  

指令重排主要有以下几种原因：

**编译器优化**：

提前计算：编译器可能会提前计算一些表达式的值，以减少运行时的计算开销。

延迟加载：编译器可能会延迟加载一些变量的值，直到真正需要使用时才加载，以减少不必要的内存访问。

**处理器优化**：

乱序执行：现代处理器采用乱序执行技术，可以在不影响最终结果的情况下调整指令的执行顺序，以充分利用硬件资源。

流水线执行：处理器的流水线技术可以将指令分解成多个阶段并行执行，从而提高执行效率。

**内存访问优化**：

预取：处理器可能会预先加载一些数据到缓存中，以减少未来的内存访问延迟。

写后置：处理器可能会将写操作推迟到适当的时机，以减少内存访问次数。

#### 指令重排的类型

指令重排可以分为以下几种类型：

**编译器优化的重排序**。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。

**指令级并行的重排序**。现代处理器采用了指令级并行技术（Instruction-Level Parallelism，ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应 机器指令的执行顺序。

**内存系统的重排序**。由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。

#### 指令重排对多线程程序的影响

指令重排在多线程环境中可能会导致以下问题：

**数据不一致**：

如果两个线程同时访问和修改同一个变量，指令重排可能会导致数据不一致的问题。

例如，线程 A 先写入变量 x，然后写入变量 y；线程 B 可能会先读取到变量 y 的新值，然后再读取到变量 x 的旧值，导致数据不一致。

**内存可见性问题**：

指令重排可能会导致内存可见性问题，即一个线程修改的变量值在另一个线程中不可见。

例如，线程 A 修改了变量 x，但由于指令重排，线程 B 可能会读取到变量 x 的旧值。

**死锁和活锁**：

指令重排可能会导致死锁和活锁问题，特别是在使用锁和其他同步机制时。

例如，线程 A 和线程 B 同时尝试获取两个锁，但由于指令重排，可能会导致死锁。

#### 避免指令重排的方法

**使用 volatile 关键字**：

volatile 变量的读写操作会插入内存屏障，禁止编译器和处理器对相关指令进行重排序。

```java
volatile int x = 0;

public void writeX() {
    x = 1;
}

public void readX() {
    if (x == 1) {
        // do something
    }
}
```

**使用 synchronized 关键字**：

synchronized 修饰的方法或代码块会插入内存屏障，禁止编译器和处理器对相关指令进行重排序。

```java
public synchronized void increment() {
    count++;
}
```

**使用 final 关键字**：

final 变量一旦初始化就不能再改变，确保了线程之间的可见性和有序性。

```java
final int x = 0;
```

#### 指令重排的限制

两个规则happens-before和as-if-serial来约束。

**happens-before规则**：

如果一个操作 happens-before 另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前。

两个操作之间存在 happens-before 关系，并不意味着 Java 平台的具体实现必须要按照 happens-before 关系指定的顺序来执行。如果重排序之后的执行结果，与按 happens-before 关系来执行的结果一致，那么这种重排序并不非法

**程序顺序规则**：一个线程中的每个操作，happens-before 于该线程中的任意后续操作。

**监视器锁规则**：对一个锁的解锁，happens-before 于随后对这个锁的加锁。

**volatile 变量规则**：对一个 volatile 域的写，happens-before 于任意后续对这个 volatile 域的读。

**传递性**：如果 A happens-before B，且 B happens-before C，那么 A happens-before C。

**start()规则**：如果线程 A 执行操作 ThreadB.start()（启动线程 B），那么 A 线程的 ThreadB.start()操作 happens-before 于线程 B 中的任意操作。

**join()规则**：如果线程 A 执行操作 ThreadB.join()并成功返回，那么线程 B 中的任意操作 happens-before 于线程 A 从 ThreadB.join()操作成功返回。

**as-if-serial规则**：

不管怎么重排序（编译器和处理器为了提高并行度），单线程程序的执行结果不能被改变。编译器、runtime 和处理器都必须遵守 as-if-serial 语义。

为了遵守 as-if-serial 语义，编译器和处理器不会对存在数据依赖关系的操作做重排序，因为这种重排序会改变执行结果。但是，如果操作之间不存在数据依赖关系，这些操作就可能被编译器和处理器重排序。为了具体说明，请看下面计算圆面积的代码示例。

```java
double pi = 3.14;   // A
double r = 1.0;   // B
double area = pi * r * r;   // C
```

A 和 C 之间存在数据依赖关系，同时 B 和 C 之间也存在数据依赖关系。因此在最终执行的指令序列中，C 不能被重排序到 A 和 B 的前面（C 排到 A 和 B 的前面，程序的结果将会被改变）。但 A 和 B 之间没有数据依赖关系，编译器和处理器可以重排序 A 和 B 之间的执行顺序。

### 31.volatile关键字的实现原理？

**可见性**  

volatile 变量的主要作用之一是确保变量的可见性。具体来说：

写操作：当一个线程修改了一个 volatile 变量的值时，这个新的值会被立即写回到主内存中。

读操作：当一个线程读取一个 volatile 变量的值时，它会从主内存中读取最新的值，而不是从本地缓存中读取。

**有序性**  

volatile 变量还确保了操作的有序性。具体来说：

内存屏障：volatile 变量的读写操作会插入内存屏障（memory fence），禁止相关的指令重排。

写屏障：在 volatile 变量的写操作前后插入写屏障，确保写操作的有序性。

读屏障：在 volatile 变量的读操作前后插入读屏障，确保读操作的有序性。

**写操作**  

当一个线程修改了一个 volatile 变量的值时：

写操作前插入写屏障：确保之前的写操作已经完成。

写入主内存：将新的值写入主内存。

写操作后插入写屏障：确保后续的写操作不会重排到这个写操作之前。

**读操作**  

当一个线程读取一个 volatile 变量的值时：

读操作前插入读屏障：确保之前的读操作已经完成。

从主内存读取：从主内存中读取最新的值。

读操作后插入读屏障：确保后续的读操作不会重排到这个读操作之前。

### 32.volatile加在基本类型和对象上的区别？

在 Java 中，volatile 关键字可以用于修饰基本类型和对象。

当 volatile 用于基本数据类型时，能*确保该变量的读写操作是直接从主内存中读取或写入的。*

当 volatile 用于引用类型时，它确保引用本身的可见性，即*确保引用指向的对象地址是最新的。*

但是，volatile 并不能保证引用对象内部状态的线程安全性。

### 33.synchronized 用过吗？怎么使用？

synchronized 是 Java 中用于实现线程同步的关键字，它可以确保共享资源被多个线程安全访问，防止数据不一致的情况发生。synchronized 主要有以下三种用法：

**修饰实例方法**： 当一个方法被 synchronized 修饰时，该方法被称为同步方法。当一个线程访问某个对象的同步方法时，它首先必须获得该对象的锁，其他试图访问该对象其他同步方法的线程将会阻塞，直到第一个线程执行完毕并释放对象锁。

```java
public class MyClass {
    public synchronized void myMethod() {
        // 方法体
    }
}
```

**修饰静态方法**： 当 synchronized 修饰静态方法时，它锁定的是类的 Class 对象，而不是实例对象。这意味着对于所有实例来说，静态同步方法在同一时刻只能被一个线程访问。

```java
public class MyClass {
    public static synchronized void myStaticMethod() {
        // 方法体
    }
}
```

**修饰代码块**： synchronized 还可以用来修饰代码块，允许开发者指定一个对象作为锁对象，这样只有获得了该对象锁的线程才能执行这段代码块。

```java
public class MyClass {
    private final Object myLock = new Object();
    
    public void myMethod() {
        synchronized (myLock) {
            // 同步代码块
        }
    }
}
```

#### synchronized 的实现原理？

synchronized 在 Java 中是一个关键字，用于实现线程间的同步。其底层实现原理依赖于 JVM（Java 虚拟机）提供的 Monitor（监视器）机制，并且在不同的 Java 版本中有所优化。以下是 synchronized 的实现原理概览：

#### Monitor 监视器

每个对象都有一个与之关联的监视器锁，也称为 Monitor。当一个线程进入一个 synchronized 代码块或方法时，它必须先获取对象的 Monitor。

如果该 Monitor 已经被另一个线程持有，请求锁的线程将被阻塞，直到当前持有锁的线程释放锁。

当线程退出 synchronized 块或方法时，它会释放该对象的 Monitor，使得其他线程有机会获取锁。

#### 可重入锁

synchronized 支持可重入性，这意味着同一个线程可以多次获取同一个对象的锁而不会导致死锁。*每次进入 synchronized 区域都会增加锁的计数，相应地，每次退出都会减少计数，直到计数归零才真正释放锁。*

synchronized 之所以支持可重入，是因为 Java 的对象头包含了一个 Mark Word，用于存储对象的状态，包括锁信息。

当一个线程获取对象锁时，JVM 会将该线程的 ID 写入 Mark Word，并将锁计数器设为 1。

如果一个线程尝试再次获取已经持有的锁，JVM 会检查 Mark Word 中的线程 ID。如果 ID 匹配，表示的是同一个线程，锁计数器递增。

当线程退出同步块时，锁计数器递减。如果计数器值为零，JVM 将锁标记为未持有状态，并清除线程 ID 信息。

#### 锁的优化

从 Java 1.6 开始，为了减少锁的开销，引入了多种锁的状态，包括偏向锁（Biased Locking）、轻量级锁（Lightweight Locking）和重量级锁（Heavyweight Locking）。

**偏向锁**：当一个线程访问同步代码前，会先检查是否有线程已经获取了锁，如果没有，虚拟机会尝试将对象头的所有者设置为当前线程，同时将状态改为偏向模式。这样后续该线程再次访问时就不需要额外的同步操作。

**轻量级锁**：当有第二个线程尝试获取锁时，会使用 [CAS](#38cas-了解多少) 操作来尝试获取锁。如果 CAS 失败，则会尝试自旋（Spinning），即循环尝试获取锁。

**重量级锁**：如果自旋一定次数仍然没有获取到锁，则会放弃自旋，线程进入阻塞状态，等待锁的持有线程释放锁后再通过操作系统内核调度唤醒。

#### 锁的升级

①、**从无锁到偏向锁**：

当一个线程首次访问同步块时，如果此对象无锁状态且偏向锁未被禁用，JVM 会将该对象头的锁标记改为偏向锁状态，并记录下当前线程的 ID。此时，对象头中的 Mark Word 中存储了持有偏向锁的线程 ID。

如果另一个线程尝试获取这个已被偏向的锁，JVM 会检查当前持有偏向锁的线程是否活跃。如果持有偏向锁的线程不活跃，则可以将锁重偏向至新的线程；如果持有偏向锁的线程还活跃，则需要撤销偏向锁，升级为轻量级锁。

②、**偏向锁的轻量级锁**：

进行偏向锁撤销时，会遍历堆栈的所有锁记录，暂停拥有偏向锁的线程，并检查锁对象。如果这个过程中发现有其他线程试图获取这个锁，JVM 会撤销偏向锁，并将锁升级为轻量级锁。

当有两个或以上线程竞争同一个偏向锁时，偏向锁模式不再有效，此时偏向锁会被撤销，对象的锁状态会升级为轻量级锁。

③、**轻量级锁到重量级锁**：

轻量级锁通过线程自旋来等待锁释放。如果自旋超过预定次数（自旋次数是可调的，并且自适应的），表明锁竞争激烈，轻量级锁的自旋已经不再高效。

当自旋等待失败，或者有线程在等待队列中等待相同的轻量级锁时，轻量级锁会升级为重量级锁。在这种情况下，JVM 会在操作系统层面创建一个互斥锁（Mutex），所有进一步尝试获取该锁的线程将会被阻塞，直到锁被释放。

**锁的获取与释放**：

synchronized 的实现依赖于 JVM 的内部指令 monitorenter 和 monitorexit。当线程执行到 synchronized 代码块之前，会执行 monitorenter 指令获取锁；当执行完 synchronized 代码块之后，会执行 monitorexit 指令释放锁。

### 34.synchronized和ReentrantLock区别和场景？

synchronized 和 ReentrantLock 都是 Java 中用于实现线程同步的重要工具，但它们之间存在一些关键的区别，这些区别决定了它们在不同场景下的适用性。以下是两者的主要区别及适用场景：

**使用方式**：

synchronized 是 Java 关键字，直接在代码级别声明同步区域或方法。

ReentrantLock 是一个类，实现了 Lock 接口，需要显式地调用 lock() 方法获取锁，以及 unlock() 方法释放锁。

```java
// synchronized 修饰方法
public synchronized void method() {
    // 业务代码
}

// synchronized 修饰代码块
synchronized (this) {
    // 业务代码
}

// ReentrantLock 加锁
ReentrantLock lock = new ReentrantLock();
lock.lock();
try {
    // 业务代码
} finally {
    lock.unlock();
}
```

**锁的释放**：

synchronized 在线程抛出异常时能够自动释放锁，因此不需要担心由于异常而导致的死锁。

ReentrantLock 必须显式地调用 unlock() 方法释放锁，如果在 try 块中获取锁而在 finally 块中释放锁，则可以保证即使抛出异常也能释放锁，否则可能导致死锁。

**响应中断**：

synchronized 不支持响应中断，如果一个线程在等待锁时被中断，它仍然会等待锁。

ReentrantLock 支持响应中断，可以通过 lockInterruptibly() 方法来允许等待锁的线程响应中断。

**锁的公平性**：

synchronized 总是非公平锁，即新来的线程可能会优先于已经在等待的线程获取锁。

ReentrantLock 可以选择是公平锁还是非公平锁，通过构造函数传入 true 或 false 参数来决定。

**扩展性**：

synchronized 提供的功能较为简单，主要用于基本的同步需求。

ReentrantLock 提供了更丰富的功能，如尝试锁（tryLock）、可中断锁（lockInterruptibly）、定时锁（tryLock(long time, TimeUnit unit)）等高级功能。

**适用场景**:

synchronized 更适合于简单的同步需求，尤其是在代码简洁性和安全性更为重要的情况下。它的使用更加简单，不需要额外的代码来管理锁的获取和释放。

ReentrantLock 适用于需要更精细控制锁行为的场景，比如需要支持中断或者希望实现公平锁，以及需要在等待锁时进行超时处理等。它提供了更多的灵活性和控制力

**性能考量**：

在性能方面，早期 synchronized 的性能较差，但在 Java 6 之后，随着 JVM 对 synchronized 的优化（如引入偏向锁、轻量级锁等），在某些低竞争场景下，synchronized 的性能可能优于 ReentrantLock。然而，在高竞争场景下，ReentrantLock 可能表现出更好的性能，因为它的实现可以更好地利用现代多核处理器的优势。

**并发量大的情况下，使用 synchronized 还是 ReentrantLock**？

在并发量特别高的情况下，ReentrantLock 的性能可能会优于 synchronized，原因包括：

ReentrantLock 提供了超时和公平锁等特性，可以更好地应对复杂的并发场景 。

ReentrantLock 允许更细粒度的锁控制，可以有效减少锁竞争。

ReentrantLock 支持条件变量 Condition，可以实现比 synchronized 更复杂的线程间通信机制。

### 35.AQS 了解多少？

AQS，全称是 AbstractQueuedSynchronizer，中文意思是抽象队列同步器，由 Doug Lea 设计，是 Java 并发包java.util.concurrent的核心框架类，许多同步类的实现都依赖于它，如 ReentrantLock、Semaphore、CountDownLatch 等。

AQS 的思想是，如果被请求的共享资源空闲，则当前线程能够成功获取资源；否则，它将进入一个等待队列，当有其他线程释放资源时，系统会挑选等待队列中的一个线程，赋予其资源。

整个过程通过维护一个 int 类型的状态和一个先进先出（FIFO）的队列，来实现对共享资源的管理。

①、同步状态 state 由 volatile 修饰，保证了多线程之间的可见性；

```java
private volatile int state;
```

②、同步队列是通过内部定义的 Node 类来实现的，每个 Node 包含了等待状态、前后节点、线程的引用等。

```java
static final class Node {
    static final int CANCELLED =  1;
    static final int SIGNAL    = -1;
    static final int CONDITION = -2;
    static final int PROPAGATE = -3;

    volatile Node prev;

    volatile Node next;

    volatile Thread thread;
}
```

AQS 支持两种同步方式：

独占模式：这种方式下，每次只能有一个线程持有锁，例如 ReentrantLock。

共享模式：这种方式下，多个线程可以同时获取锁，例如 Semaphore 和 CountDownLatch。

子类可以通过继承 AQS 并实现它的方法来管理同步状态，这些方法包括：

tryAcquire：独占方式尝试获取资源，成功则返回 true，失败则返回 false；

tryRelease：独占方式尝试释放资源；

tryAcquireShared(int arg)：共享方式尝试获取资源；

tryReleaseShared(int arg)：共享方式尝试释放资源；

isHeldExclusively()：该线程是否正在独占资源。

如果共享资源被占用，需要一种特定的阻塞等待唤醒机制来保证锁的分配，AQS 会将竞争共享资源失败的线程添加到一个 CLH 队列中。

在 CLH 锁中，当一个线程尝试获取锁并失败时，它会将自己添加到队列的尾部并自旋，等待前一个节点的线程释放锁。

### 36.ReentrantLock 实现原理？

ReentrantLock 是可重入的独占锁，只能有一个线程可以获取该锁，其它获取该锁的线程会被阻塞。

可重入表示当前线程获取该锁后再次获取不会被阻塞，也就意味着同一个线程可以多次获得同一个锁而不会发生死锁。

new ReentrantLock() 默认创建的是非公平锁 NonfairSync。

**公平锁 FairSync**  

在公平锁模式下，锁会授予等待时间最长的线程。

**非公平锁 NonfairSync**  

在非公平锁模式下，锁可能会授予刚刚请求它的线程，而不考虑等待时间。

ReentrantLock 内部通过一个计数器来跟踪锁的持有次数。

当线程调用lock()方法获取锁时，ReentrantLock 会检查当前状态，判断锁是否已经被其他线程持有。如果没有被持有，则当前线程将获得锁；如果锁已被其他线程持有，则当前线程将根据锁的公平性策略，可能会被加入到等待队列中。

线程首次获取锁时，计数器值变为 1；如果同一线程再次获取锁，计数器增加；每释放一次锁，计数器减 1。

当线程调用unlock()方法时，ReentrantLock 会将持有锁的计数减 1，如果计数到达 0，则释放锁，并唤醒等待队列中的线程来竞争锁。

### 37.ReentrantLock 怎么实现公平锁的？

在 ReentrantLock 中，公平锁的实现主要通过 FairSync 类来完成，它是 ReentrantLock.Sync 的子类，继承自 AbstractQueuedSynchronizer（AQS）。公平锁的核心在于确保线程获取锁的顺序符合它们在队列中的位置。

公平锁意味着在多个线程竞争锁时，获取锁的顺序与线程请求锁的顺序相同，即先来先服务（FIFO）。

虽然能保证锁的顺序，但实现起来比较复杂，因为需要额外维护一个有序队列。

非公平锁不保证线程获取锁的顺序，当锁被释放时，任何请求锁的线程都有机会获取锁，而不是按照请求的顺序。

### 38.CAS 了解多少？

CAS（Compare-and-Swap）是一种乐观锁的实现方式，全称为“比较并交换”，是一种无锁的原子操作。

在 Java 中，我们可以使用 synchronized关键字和 CAS 来实现加锁效果。

synchronized 是悲观锁，尽管随着 JDK 版本的升级，synchronized 关键字已经“轻量级”了很多，但依然是悲观锁，线程开始执行第一步就要获取锁，一旦获得锁，其他的线程进入后就会阻塞并等待锁。

CAS 是乐观锁，线程执行的时候不会加锁，它会假设此时没有冲突，然后完成某项操作；如果因为冲突失败了就重试，直到成功为止。

在 CAS 中，有这样三个值：

V：要更新的变量(var)

E：预期值(expected)

N：新值(new)

**比较并交换的过程如下**：

判断 V 是否等于 E，如果等于，将 V 的值设置为 N；如果不等，说明已经有其它线程更新了 V，于是当前线程放弃更新，什么都不做。

这里的预期值 E 本质上指的是“旧值”。

这个比较和替换的操作是原子的，即不可中断，确保了数据的一致性。

举个例子，变量当前的值为 0，需要将其更新为 1，可以借助 AtomicInteger 类的 compareAndSet 方法来实现。

```java
AtomicInteger atomicInteger = new AtomicInteger(0);
int expect = 0;
int update = 1;
atomicInteger.compareAndSet(expect, update);
```

compareAndSet 就是一个 CAS 方法，它调用的是 Unsafe 的 compareAndSwapInt。

Unsafe 对 CAS 的实现是通过 C++ 实现的，它的具体实现和操作系统、CPU 都有关系。

Linux 的 X86 下主要是通过 cmpxchgl 这个指令在 CPU 上完成 CAS 操作的，但在多处理器情况下，必须使用 lock 指令加锁来完成。当然，不同的操作系统和处理器在实现方式上肯定会有所不同。

### 39.CAS 有什么问题？如何解决？

#### ABA 问题

**描述**：即使 CAS 操作成功，也不能保证在这段时间内没有发生过其他变化。例如，一个值从 A 变成 B 再变回 A，此时 CAS 操作仍然会成功，但实际上已经发生了改变。

**解决方案**：

使用带有版本号或时间戳的原子引用类型（如 AtomicStampedReference），每次更新时都带上版本号，从而避免 ABA 问题。

```java
public class OptimisticLockExample {
    private int version;
    private int value;

    public synchronized boolean updateValue(int newValue, int currentVersion) {
        if (this.version == currentVersion) {
            this.value = newValue;
            this.version++;
            return true;
        }
        return false;
    }
}
```

#### 忙等待问题

**描述**：当 CAS 操作失败时，通常会进行自旋重试，这可能导致 CPU 资源浪费。

**解决方案**：

引入延时重试机制，增加重试间隔时间。

结合其他同步机制，如锁，来避免长时间的忙等待。

在 Java 中，很多使用自旋 CAS 的地方，会有一个自旋次数的限制，超过一定次数，就停止自旋。

#### 只能保证单个变量的原子性

**描述**：CAS 操作只能保证单个变量更新的原子性，对于多个变量同时更新无法保证原子性。

**解决方案**：

对于多个变量的操作，可以考虑使用锁或其他更复杂的同步机制。

将多个变量封装成一个对象，然后对整个对象进行 CAS 操作。

### 40.原子操作类了解多少？

Atomic 包里的类基本都是使用 Unsafe 实现的包装类。

使用原子的方式更新基本类型，Atomic 包提供了以下 3 个类：

AtomicBoolean：原子更新布尔类型。

AtomicInteger：原子更新整型。

AtomicLong：原子更新长整型。

通过原子的方式更新数组里的某个元素，Atomic 包提供了以下 4 个类：

AtomicIntegerArray：原子更新整型数组里的元素。

AtomicLongArray：原子更新长整型数组里的元素。

AtomicReferenceArray：原子更新引用类型数组里的元素。

AtomicIntegerArray 类主要是提供原子的方式更新数组里的整型

原子更新基本类型的 AtomicInteger，只能更新一个变量，如果要原子更新多个变量，就需要使用这个原子更新引用类型提供的类。Atomic 包提供了以下 3 个类：

AtomicReference：原子更新引用类型。

AtomicReferenceFieldUpdater：原子更新引用类型里的字段。

AtomicMarkableReference：原子更新带有标记位的引用类型。可以原子更新一个布尔类型的标记位和引用类型。构造方法是 AtomicMarkableReference（V initialRef，boolean initialMark）。

如果需原子地更新某个类里的某个字段时，就需要使用原子更新字段类，Atomic 包提供了以下 3 个类进行原子字段更新：

AtomicIntegerFieldUpdater：原子更新整型的字段的更新器。

AtomicLongFieldUpdater：原子更新长整型字段的更新器。

AtomicStampedReference：原子更新带有版本号的引用类型。该类将整数值与引用关联起来，可用于原子的更新数据和数据的版本号，可以解决使用 CAS 进行原子更新时可能出现的 ABA 问题。

以 **AtomicInteger** 的添加方法为例：

```java
    public final int getAndIncrement() {
        return unsafe.getAndAddInt(this, valueOffset, 1);
    }
```

通过Unsafe类的实例来进行添加操作，来看看具体的 CAS 操作：

```java
public final int getAndAddInt(Object var1, long var2, int var4) {
    int var5;
    do {
        var5 = this.getIntVolatile(var1, var2);
    } while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4));

    return var5;
}
```

compareAndSwapInt 是一个 native 方法，基于 CAS 来操作 int 类型变量。其它的原子操作类基本都是大同小异。

### 41.线程死锁了解吗？该如何避免？

线程死锁是指两个或多个线程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象。在这种情况下，每个线程都在等待另一个线程释放它所需要的资源，结果导致所有相关线程都无法继续执行下去。

#### 死锁的必要条件

**互斥条件**：至少有一个资源必须处于非共享模式，即一次只能有一个线程使用。如果另一个线程想要使用该资源，那么它必须等待，直到拥有该资源的线程释放它。

**请求与保持条件**：一个线程已经持有了至少一个资源，但又提出了新的资源请求，而该资源已被其它线程占有，因此请求线程被阻塞。

**不可抢占条件**：线程已经获得的资源，在结束前不能被其他线程强行抢占，只能主动释放。

**循环等待条件**：存在一种涉及两个或多个线程的循环等待链，每个线程都在等待下一个线程持有的资源。

#### 避免死锁的方法

**打破循环等待条件**：

给资源分配一个全局唯一的顺序，所有线程按照相同的顺序请求资源。例如，如果系统中有多个锁，则按照锁对象的地址排序，线程总是按照从小到大的顺序获取锁。

使用超时机制，当线程请求资源时设置一个超时时间，超时后放弃资源请求。

**打破不可抢占条件**：

允许持有较少资源的线程释放资源，让持有更多资源的线程先完成任务。

**打破请求与保持条件**：

要求线程一次性请求所有需要的资源，而不是在持有部分资源的情况下再请求其他资源。

**打破互斥条件**：

虽然完全避免互斥条件不太现实，但是可以通过减少互斥资源的数量或使用替代方案来降低死锁的可能性。

### 42.死锁问题怎么排查呢？

**使用 jstack 命令**  

jstack 是一个 Java 工具，它可以打印出 Java 进程中的所有线程的堆栈跟踪信息。

命令示例：

```bash
jstack <pid>
```

在输出的信息中，你可以看到每个线程的状态，包括 BLOCKED 状态，这可能是死锁的迹象。

**使用 jconsole 工具**  

jconsole 是一个图形化的监控工具，可以显示 JVM 的详细信息，包括线程状态。

使用方法：通过 jconsole 连接到目标 JVM，然后查看线程监视器图表，可以发现死锁的线程。

**使用 VisualVM**  

VisualVM 是一个集成的工具，它提供了类似 jconsole 的功能，但还包含了更多的分析工具。

使用方法：打开 VisualVM，连接到目标 JVM，然后查看线程视图，查找死锁情况。

### 43.乐观锁和悲观锁？

对于悲观锁来说，它总是认为每次访问共享资源时会发生冲突，所以必须对每次数据操作加上锁，以保证临界区的程序同一时间只能有一个线程在执行。

悲观锁的代表有 synchronized 关键字和 Lock 接口。

乐观锁，顾名思义，它是乐观派。乐观锁总是假设对共享资源的访问没有冲突，线程可以不停地执行，无需加锁也无需等待。一旦多个线程发生冲突，乐观锁通常使用一种称为 CAS 的技术来保证线程执行的安全性。

由于乐观锁假想操作中没有锁的存在，因此不太可能出现死锁的情况，换句话说，乐观锁天生免疫死锁。

乐观锁多用于“读多写少“的环境，避免频繁加锁影响性能；

悲观锁多用于”写多读少“的环境，避免频繁失败和重试影响性能。

### 44.CountDownLatch（倒计数器）了解吗？

`CountDownLatch` 是 Java 并发包（java.util.concurrent）中的一个同步辅助类，用于协调多个线程之间的同步。它允许一个或多个线程等待，直到在其他线程中执行的一组操作完成。

**工作原理**：

CountDownLatch 通过一个计数器来实现，该计数器初始化为一个正整数。每当一个线程完成了它的工作后，计数器就会减一。当计数器的值变为零时，所有等待的线程都会被唤醒，继续执行。

**主要方法**：

`CountDownLatch(int count)`：构造一个用给定计数初始化的 CountDownLatch。

`void await()`：使当前线程等待，直到计数器的值变为零，除非线程被中断。

`boolean await(long timeout, TimeUnit unit)`：使当前线程等待，直到计数器的值变为零，或者等待超时，或者线程被中断。

`void countDown()`：递减计数器的值。如果计数器的值变为零，则所有等待的线程都会被唤醒。

**示例代码**:

```java
import java.util.concurrent.CountDownLatch;

public class CountDownLatchExample {
    public static void main(String[] args) {
        int threadCount = 3;
        CountDownLatch latch = new CountDownLatch(threadCount);

        for (int i = 0; i < threadCount; i++) {
            new Thread(new Worker(latch)).start();
        }

        try {
            // 主线程等待，直到计数器变为零
            latch.await();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        System.out.println("所有工作线程已完成，主线程继续执行。");
    }
}

class Worker implements Runnable {
    private final CountDownLatch latch;

    public Worker(CountDownLatch latch) {
        this.latch = latch;
    }

    @Override
    public void run() {
        try {
            // 模拟工作
            Thread.sleep((long) (Math.random() * 1000));
            System.out.println(Thread.currentThread().getName() + " 完成工作");
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            // 递减计数器
            latch.countDown();
        }
    }
}
```

在这个示例中，主线程创建了三个工作线程，并使用 CountDownLatch 来等待所有工作线程完成工作。每个工作线程在完成工作后都会调用 countDown() 方法递减计数器。当计数器的值变为零时，主线程会被唤醒，继续执行后续操作。

### 45.CyclicBarrier（同步屏障）了解吗？

`CyclicBarrier` 是 Java 并发包（java.util.concurrent）中的一个同步辅助类，用于协调多个线程在某个点上相互等待，直到所有线程都到达这个点后再继续执行。它类似于 CountDownLatch，但 CyclicBarrier 可以被重用

**工作原理**：

CyclicBarrier 通过一个计数器来实现，该计数器初始化为一个正整数，表示需要等待的线程数。每当一个线程到达屏障点时，计数器减一。当计数器的值变为零时，所有等待的线程都会被唤醒，继续执行。如果需要，CyclicBarrier 可以在所有线程被唤醒之前执行一个可选的屏障操作。

**主要方法**：

`CyclicBarrier(int parties)`：构造一个新的 CyclicBarrier，它将在指定数量的线程（parties）都调用 await 方法时触发。

`CyclicBarrier(int parties, Runnable barrierAction)`：构造一个新的 CyclicBarrier，它将在指定数量的线程（parties）都调用 await 方法时触发，并在所有线程被唤醒之前执行给定的屏障操作。

`int await()`：使当前线程在屏障点等待，直到所有线程都到达屏障点。

`int await(long timeout, TimeUnit unit)`：使当前线程在屏障点等待，直到所有线程都到达屏障点，或者等待超时，或者线程被中断。

**示例代码**：

```java
import java.util.concurrent.BrokenBarrierException;
import java.util.concurrent.CyclicBarrier;

public class CyclicBarrierExample {
    public static void main(String[] args) {
        int threadCount = 3;
        CyclicBarrier barrier = new CyclicBarrier(threadCount, new Runnable() {
            @Override
            public void run() {
                System.out.println("所有线程都到达屏障点，继续执行...");
            }
        });

        for (int i = 0; i < threadCount; i++) {
            new Thread(new Worker(barrier)).start();
        }
    }
}

class Worker implements Runnable {
    private final CyclicBarrier barrier;

    public Worker(CyclicBarrier barrier) {
        this.barrier = barrier;
    }

    @Override
    public void run() {
        try {
            // 模拟工作
            Thread.sleep((long) (Math.random() * 1000));
            System.out.println(Thread.currentThread().getName() + " 到达屏障点");
            barrier.await();
            System.out.println(Thread.currentThread().getName() + " 继续执行");
        } catch (InterruptedException | BrokenBarrierException e) {
            e.printStackTrace();
        }
    }
}
```

在这个示例中，主线程创建了三个工作线程，并使用 CyclicBarrier 来让所有线程在某个点上相互等待。每个工作线程在到达屏障点后都会调用 await() 方法。当所有线程都到达屏障点时，屏障操作会被执行，然后所有线程继续执行后续操作。

### 46.CyclicBarrier 和 CountDownLatch 有什么区别？

两者最核心的区别：

CountDownLatch 是一次性的，而 CyclicBarrier 则可以多次设置屏障，实现重复利用；

CountDownLatch 中的各个子线程不可以等待其他线程，只能完成自己的任务；而 CyclicBarrier 中的各个线程可以等待其他线程

| CyclicBarrier | CountDownLatch |
| --- | --- |
| CyclicBarrier 是可重用的，其中的线程会等待所有的线程完成任务。届时，屏障将被拆除，并可以选择性地做一些特定的动作。 | CountDownLatch 是一次性的，不同的线程在同一个计数器上工作，直到计数器为 0. |
| CyclicBarrier 面向的是线程数 | CountDownLatch 面向的是任务数 |
| 在使用 CyclicBarrier 时，你必须在构造中指定参与协作的线程数，这些线程必须调用 await()方法 | 使用 CountDownLatch 时，则必须要指定任务数，至于这些任务由哪些线程完成无关紧要 |
| CyclicBarrier 可以在所有的线程释放后重新使用 | CountDownLatch 在计数器为 0 时不能再使用 |
| 在 CyclicBarrier 中，如果某个线程遇到了中断、超时等问题时，则处于 await 的线程都会出现问题 | 在 CountDownLatch 中，如果某个线程出现问题，其他线程不受影响 |

### 47.Semaphore（信号量）了解吗？

Semaphore 是 Java 并发包（java.util.concurrent）中的一个同步辅助类，用于控制对某个资源的访问数量。它可以用来限制同时访问某些资源的线程数量。

**工作原理**：

Semaphore 维护了一个许可计数器，表示可以同时访问资源的最大线程数。线程在访问资源前需要获取许可，访问结束后需要释放许可。如果没有可用的许可，线程将被阻塞，直到有可用的许可为止。

**主要方法**：

`Semaphore(int permits)`：构造一个具有给定许可数量的 Semaphore。

`Semaphore(int permits, boolean fair)`：构造一个具有给定许可数量和公平性设置的 Semaphore。公平性设置为 true 时，Semaphore 会按照线程请求许可的顺序分配许可。

`void acquire()`：获取一个许可，如果没有可用的许可，线程将被阻塞，直到有可用的许可。

`void acquire(int permits)`：获取指定数量的许可。

`void release()`：释放一个许可。

`void release(int permits)`：释放指定数量的许可。

`int availablePermits()`：返回当前可用的许可数量。

**示例代码**：

```java
import java.util.concurrent.Semaphore;

public class SemaphoreExample {
    public static void main(String[] args) {
        int threadCount = 5;
        Semaphore semaphore = new Semaphore(2); // 允许同时访问的线程数为2

        for (int i = 0; i < threadCount; i++) {
            new Thread(new Worker(semaphore)).start();
        }
    }
}

class Worker implements Runnable {
    private final Semaphore semaphore;

    public Worker(Semaphore semaphore) {
        this.semaphore = semaphore;
    }

    @Override
    public void run() {
        try {
            // 获取许可
            semaphore.acquire();
            System.out.println(Thread.currentThread().getName() + " 获取许可，开始工作");
            // 模拟工作
            Thread.sleep((long) (Math.random() * 1000));
            System.out.println(Thread.currentThread().getName() + " 释放许可，结束工作");
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            // 释放许可
            semaphore.release();
        }
    }
}
```

在这个示例中，主线程创建了五个工作线程，并使用 Semaphore 来限制同时访问资源的线程数量为两个。每个工作线程在获取许可后开始工作，工作结束后释放许可。这样，最多只有两个线程可以同时访问资源。

Semaphore 用于控制对某个资源的访问数量，限制同时访问资源的线程数量。

主要方法 包括 acquire() 和 release()，分别用于获取和释放许可。

应用场景 包括*限制同时访问某个资源的线程数量、实现资源池*等。

### 48.Exchanger 了解吗？

Exchanger 是 Java 并发包（java.util.concurrent）中的一个同步点类，用于在两个线程之间交换数据。它提供了一个同步点，两个线程可以在这个同步点上交换数据。

**工作原理**:
Exchanger 允许两个线程在同步点上交换数据。每个线程在到达同步点时，都会将自己的数据传递给对方，并接收对方的数据。这个交换操作是同步的，即两个线程必须都到达同步点，交换才会发生。

**主要方法**:

`Exchanger()`：构造一个新的 Exchanger。

`V exchange(V x)`：在同步点上与另一个线程交换数据。如果另一个线程还没有到达同步点，则当前线程将等待。

`V exchange(V x, long timeout, TimeUnit unit)`：在同步点上与另一个线程交换数据，带有超时设置。如果在指定的时间内没有另一个线程到达同步点，则抛出 TimeoutException。

**示例代码**:

```java

import java.util.concurrent.Exchanger;

public class ExchangerExample {
    public static void main(String[] args) {
        Exchanger<String> exchanger = new Exchanger<>();

        Thread thread1 = new Thread(new Worker(exchanger, "数据来自线程1"));
        Thread thread2 = new Thread(new Worker(exchanger, "数据来自线程2"));

        thread1.start();
        thread2.start();
    }
}

class Worker implements Runnable {
    private final Exchanger<String> exchanger;
    private final String data;

    public Worker(Exchanger<String> exchanger, String data) {
        this.exchanger = exchanger;
        this.data = data;
    }

    @Override
    public void run() {
        try {
            System.out.println(Thread.currentThread().getName() + " 交换前的数据: " + data);
            String exchangedData = exchanger.exchange(data);
            System.out.println(Thread.currentThread().getName() + " 交换后的数据: " + exchangedData);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
```

在这个示例中，两个线程分别创建了自己的数据，并使用 Exchanger 在同步点上交换数据。每个线程在交换前打印自己的数据，然后在交换后打印接收到的数据。

Exchanger 用于在两个线程之间交换数据

主要方法 包括 exchange()，用于在同步点上交换数据。

应用场景 包括需要在两个线程之间交换数据的场景，例如，生产者和消费者之间的数据交换。

### 49.ConcurrentHashMap 对 HashMap 的优化？ConcurrentHashMap 1.8 比 1.7 的优化在哪里？

ConcurrentHashMap 是 Java 并发包中的一个线程安全的哈希表实现，它对 HashMap 进行了多方面的优化，以支持高并发环境下的高效操作。

**取消分段锁**：

在 Java 1.7 中，ConcurrentHashMap 使用分段锁，每个段有一个独立的锁。虽然这种方式提高了并发性能，但仍然存在锁竞争的问题。

在 Java 1.8 中，ConcurrentHashMap 取消了分段锁，转而使用更细粒度的锁(桶锁)和 CAS 操作。这种方式减少了锁的粒度，提高了并发性能。

**引入红黑树**：

在 Java 1.7 中，ConcurrentHashMap 使用链表来处理哈希冲突。当链表长度较长时，查找和插入的性能会下降。

在 Java 1.8 中，当链表长度超过一定阈值时，链表会转换为红黑树，从而提高查找和插入的性能。

**更高效的扩容机制**：

在 Java 1.8 中，ConcurrentHashMap 的扩容机制也进行了优化。扩容时，多个线程可以并发地进行数据迁移，从而提高扩容的效率。

### 50.为什么 ConcurrentHashMap 在 JDK 1.7 中要用 ReentrantLock，而在 JDK 1.8 要用 synchronized？

**性能优化**：

在 JDK 1.6 之后，synchronized 的性能得到了显著优化，特别是在偏向锁和轻量级锁的情况下，synchronized 的开销非常小。

synchronized 是 JVM 内置的锁机制，能够更好地与 JVM 的其他优化机制配合。

**代码简化**：

使用 synchronized 可以简化代码结构，使代码更易于维护和理解。

synchronized 是一种内置的锁机制，不需要显式地管理锁对象，减少了代码的复杂性。

**更细粒度的锁**：

JDK 1.7 中的 ConcurrentHashMap 使用了分段锁机制，即 Segment 锁，每个 Segment 都是一个 ReentrantLock，这样可以保证每个 Segment 都可以独立地加锁，从而实现更高级别的并发访问。

JDK 1.8 中的 ConcurrentHashMap 使用更细粒度的锁，只对特定的桶（bucket）进行加锁，而不是整个段。这种方式减少了锁的粒度，提高了并发性能。

### 51.为什么 ConcurrentHashMap 比 Hashtable 效率高

`ConcurrentHashMap` 比 `Hashtable` 效率高的原因主要在于它们的锁机制和并发控制方式的不同。

#### Hashtable 的锁机制

`Hashtable` 是一个线程安全的哈希表实现，但它的线程安全是通过对整个哈希表进行同步来实现的。每次对 `Hashtable` 的读写操作都会锁住整个哈希表，这意味着在高并发环境下，多个线程不能同时访问 `Hashtable`，从而导致性能瓶颈。

```java
public synchronized V get(Object key) {
    // 获取操作
}

public synchronized V put(K key, V value) {
    // 插入操作
}
```

#### ConcurrentHashMap 的锁机制

`ConcurrentHashMap`通过更细粒度的锁机制来实现线程安全，从而提高了并发性能。

#### JDK 1.7 中的 ConcurrentHashMap

在 JDK 1.7 中，`ConcurrentHashMap` 使用了分段锁（Segmented Locking）机制。整个哈希表被分成多个段（Segment），每个段是一个独立的哈希表，并且有自己的锁。这样，多个线程可以并发地访问不同段的数据，从而提高并发性能。

```java
final Segment<K,V>[] segments;

static final class Segment<K,V> extends ReentrantLock implements Serializable {
    // Segment 内部实现
}
```

#### JDK 1.8 中的 ConcurrentHashMap

在 JDK 1.8 中，`ConcurrentHashMap`摒弃了分段锁机制，转而使用更细粒度的锁和 CAS（Compare-And-Swap）操作。具体来说，JDK 1.8 中的 `ConcurrentHashMap`主要使用 `synchronized`和 CAS 操作来保证线程安全。

- **CAS 操作**：CAS 是一种无锁的并发编程技术，通过比较和交换操作来保证数据的一致性。在大多数情况下，CAS 操作比锁机制更高效，因为它避免了线程的阻塞和上下文切换。
- **细粒度锁**：在插入新节点时，只对特定的桶（bucket）进行加锁，而不是整个哈希表。这种方式减少了锁的粒度，提高了并发性能。

```java
static final class Node<K,V> implements Map.Entry<K,V> {
    final int hash;
    final K key;
    volatile V val;
    volatile Node<K,V> next;
}

private final void transfer(Node<K,V>[] tab, Node<K,V>[] nextTab) {
    // 使用 synchronized 和 CAS 操作进行数据迁移
    synchronized (f) {
        // 迁移逻辑
    }
}
```

- **锁粒度**：`Hashtable` 对整个哈希表进行同步，而 `ConcurrentHashMap`使用更细粒度的锁（分段锁或桶锁），从而允许更高的并发访问。
- **性能优化**：`ConcurrentHashMap` 在 JDK 1.8 中使用了 CAS 操作和更细粒度的锁，进一步提高了并发性能。
- **代码简化**：`ConcurrentHashMap` 在 JDK 1.8 中使用 `synchronized` 和 CAS 操作，简化了代码结构，并利用 JVM 的优化机制提高性能。

因此，`ConcurrentHashMap`比 `Hashtable` 在高并发环境下具有更高的效率和更好的性能表现。

## JVM

### 1.什么是JVM？

JVM，也就是 Java 虚拟机，它是 Java 实现跨平台的基石。

Java 程序运行的时候，编译器会将 Java 源代码（.java）编译成平台无关的 Java 字节码文件（.class），接下来对应平台的 JVM 会对字节码文件进行解释，翻译成对应平台的机器指令并运行。

任何可以通过 Java 编译的语言，比如说 Groovy、Kotlin、Scala 等，都可以在 JVM 上运行。

### 2.JVM的组织架构？

JVM（Java 虚拟机）的组织架构可以分为以下几个主要部分：

1. **类加载器子系统（Class Loader Subsystem）**
2. **运行时数据区（Runtime Data Area）**
3. **执行引擎（Execution Engine）**
4. **本地方法接口（JNI - Java Native Interface）**

#### 1. 类加载器子系统（Class Loader Subsystem）

类加载器子系统负责加载 `.class` 文件，并将其转换为 JVM 可以执行的字节码。类加载器子系统包括以下几个部分：

- **Bootstrap ClassLoader**：引导类加载器，负责加载核心 Java 类库（如 `rt.jar`）。
- **Extension ClassLoader**：扩展类加载器，负责加载扩展类库（如 `ext` 目录下的类库）。
- **Application ClassLoader**：应用类加载器，负责加载应用程序的类路径（classpath）下的类。

#### 2. 运行时数据区（Runtime Data Area）

运行时数据区是 JVM 在执行 Java 程序时使用的内存区域，包括以下几个部分：

- **方法区（Method Area）**：存储类信息、常量、静态变量和即时编译器编译后的代码。
- **堆（Heap）**：存储所有对象实例和数组。堆是垃圾回收的主要区域。
- **Java 栈（Java Stack）**：存储每个线程的局部变量、操作数栈和帧数据。每个线程都有自己的 Java 栈。
- **本地方法栈（Native Method Stack）**：存储本地方法调用的信息。
- **程序计数器（Program Counter Register）**：存储当前线程执行的字节码指令的地址。

#### 3. 执行引擎（Execution Engine）

执行引擎负责解释和执行字节码指令。现代 JVM 通常包含即时编译器（JIT），将热点代码编译为本地机器码，以提高执行效率。执行引擎包括以下几个部分：

- **解释器（Interpreter）**：逐条解释执行字节码指令。
- **即时编译器（JIT Compiler）**：将热点代码编译为本地机器码，提高执行效率。
- **垃圾回收器（Garbage Collector）**：自动管理内存，通过垃圾回收机制回收不再使用的对象，防止内存泄漏。

#### 4. 本地方法接口（JNI - Java Native Interface）

本地方法接口允许 Java 程序调用本地（非 Java）代码，如 C 或 C++ 编写的库。JNI 提供了一组 API，用于在 Java 和本地代码之间进行交互。

### 3.JVM内存结构

JVM 内存结构定义了 Java 程序在运行时使用的内存区域。主要包括以下几个部分：

1. **方法区（Method Area）**
2. **堆（Heap）**
3. **Java 栈（Java Stack）**
4. **本地方法栈（Native Method Stack）**
5. **程序计数器（Program Counter Register）**

#### 1. 方法区（Method Area）

- **存储内容**：方法区存储类信息、常量、静态变量和即时编译器编译后的代码。
- **特点**：*方法区是线程共享的区域*，所有线程都可以访问其中的数据。
- **用途**：主要用于存储类的结构信息（如字段、方法、接口等）、常量池、方法数据和方法代码。

#### 2. 堆（Heap）

- **存储内容**：堆存储所有对象实例和数组。
- **特点**：*堆是线程共享的区域*，所有线程都可以访问其中的数据。
- **用途**：堆是垃圾回收的主要区域，JVM 使用垃圾回收机制来管理堆内存，回收不再使用的对象。

#### 3. Java 栈（Java Stack）

- **存储内容**：Java 栈存储每个线程的局部变量、操作数栈和帧数据。
- **特点**：*每个线程都有自己的 Java 栈*，*栈中的数据对其他线程不可见*。
- **用途**：每次方法调用都会创建一个新的栈帧，栈帧中包含了方法的局部变量表、操作数栈、动态链接和方法返回地址。

#### 4. 本地方法栈（Native Method Stack）

- **存储内容**：本地方法栈存储本地方法调用的信息。
- **特点**：*每个线程都有自己的本地方法栈*，*栈中的数据对其他线程不可见*。
- **用途**：用于支持本地方法的执行，存储本地方法调用的状态。

#### 5. 程序计数器（Program Counter Register）

- **存储内容**：程序计数器存储当前线程执行的字节码指令的地址。
- **特点**：*每个线程都有自己的程序计数器*，*计数器中的数据对其他线程不可见*。
- **用途**：用于记录当前线程执行的字节码指令地址，当线程切换时，可以通过程序计数器恢复到正确的执行位置。

#### 6.内存结构图示

```bash
+------------------+
|    方法区        |
| (Method Area)    |
+------------------+
|       堆         |
|     (Heap)       |
+------------------+
|   Java 栈        |
| (Java Stack)     |
+------------------+
| 本地方法栈       |
| (Native Method   |
|    Stack)        |
+------------------+
| 程序计数器       |
| (Program Counter |
|   Register)      |
+------------------+
```

#### 6.总结-3

- **方法区**：存储类信息、常量、静态变量和即时编译器编译后的代码，是线程共享的区域。
- **堆**：存储所有对象实例和数组，是线程共享的区域，垃圾回收的主要区域。
- **Java 栈**：存储每个线程的局部变量、操作数栈和帧数据，每个线程都有自己的 Java 栈。
- **本地方法栈**：存储本地方法调用的信息，每个线程都有自己的本地方法栈。
- **程序计数器**：存储当前线程执行的字节码指令的地址，每个线程都有自己的程序计数器。

JVM 内存结构确保了 Java 程序的高效执行和内存管理，通过垃圾回收机制自动管理内存，防止内存泄漏。

### 4.说一下 JDK1.6、1.7、1.8 内存区域的变化？

在不同版本的 JDK 中，JVM 内存区域的实现和管理方式有所变化，特别是在方法区和永久代（PermGen）方面。

#### JDK 1.6

- **方法区（Method Area）**：方法区在 JDK 1.6 中被实现为永久代（PermGen）。
- **永久代（PermGen）**：永久代用于存储类信息、常量、静态变量和即时编译器编译后的代码。永久代的大小是固定的，可以通过 `-XX:PermSize` 和 `-XX:MaxPermSize` 参数进行配置。
- **堆（Heap）**：堆用于存储所有对象实例和数组，是垃圾回收的主要区域。
- **Java 栈（Java Stack）**：每个线程都有自己的 Java 栈，存储局部变量、操作数栈和帧数据。
- **本地方法栈（Native Method Stack）**：存储本地方法调用的信息。
- **程序计数器（Program Counter Register）**：存储当前线程执行的字节码指令的地址。

#### JDK 1.7

- **方法区（Method Area）**：方法区仍然被实现为永久代（PermGen），但 JDK 1.7 开始逐步移除永久代中的一些内容。
- **永久代（PermGen）**：JDK 1.7 中，字符串常量池从永久代移到了堆中。这是为了减少永久代的内存压力，因为永久代的大小是固定的。
- **堆（Heap）**：堆用于存储所有对象实例和数组，是垃圾回收的主要区域。
- **Java 栈（Java Stack）**：每个线程都有自己的 Java 栈，存储局部变量、操作数栈和帧数据。
- **本地方法栈（Native Method Stack）**：存储本地方法调用的信息。
- **程序计数器（Program Counter Register）**：存储当前线程执行的字节码指令的地址。

#### JDK 1.8

- **方法区（Method Area）**：方法区在 JDK 1.8 中被实现为元空间（Metaspace）。
- **元空间（Metaspace）**：元空间取代了永久代，用于存储类信息、常量、静态变量和即时编译器编译后的代码。元空间使用本地内存（Native Memory），其大小可以通过 `-XX:MetaspaceSize` 和 `-XX:MaxMetaspaceSize` 参数进行配置。
- **堆（Heap）**：堆用于存储所有对象实例和数组，是垃圾回收的主要区域。
- **Java 栈（Java Stack）**：每个线程都有自己的 Java 栈，存储局部变量、操作数栈和帧数据。
- **本地方法栈（Native Method Stack）**：存储本地方法调用的信息。
- **程序计数器（Program Counter Register）**：存储当前线程执行的字节码指令的地址。

#### 主要变化

1. **永久代（PermGen）到元空间（Metaspace）**：
   - **JDK 1.6 和 JDK 1.7**：方法区被实现为永久代（PermGen），用于存储类信息、常量、静态变量和即时编译器编译后的代码。JDK 1.7 中，字符串常量池从永久代移到了堆中。
   - **JDK 1.8**：永久代被移除，取而代之的是元空间（Metaspace）。元空间使用本地内存（Native Memory），其大小可以动态调整，减少了内存溢出的风险。

2. **字符串常量池**：
   - **JDK 1.6**：字符串常量池位于永久代中。
   - **JDK 1.7 和 JDK 1.8**：字符串常量池被移到了堆中。

#### 配置参数变化

- **JDK 1.6 和 JDK 1.7**：
  - `-XX:PermSize`：设置永久代的初始大小。
  - `-XX:MaxPermSize`：设置永久代的最大大小。

- **JDK 1.8**：
  - `-XX:MetaspaceSize`：设置元空间的初始大小。
  - `-XX:MaxMetaspaceSize`：设置元空间的最大大小。

#### 总结-4

- **JDK 1.6**：方法区被实现为永久代，字符串常量池位于永久代中。
- **JDK 1.7**：开始逐步移除永久代中的一些内容，字符串常量池被移到了堆中。
- **JDK 1.8**：永久代被移除，取而代之的是元空间，元空间使用本地内存，字符串常量池位于堆中。

这些变化主要是为了改进内存管理，减少内存溢出的风险，并提高 JVM 的性能和稳定性。

### 5.JDK 1.8 中的元空间（Metaspace）相对于永久代（PermGen）的优势？

在 JDK 1.8 中，元空间（Metaspace）取代了永久代（PermGen），用于存储类信息、常量、静态变量和即时编译器编译后的代码。元空间相对于永久代有以下几个主要优势：

#### 1. 使用本地内存

- **永久代（PermGen）**：使用的是 JVM 堆内存，大小是固定的，可以通过 `-XX:PermSize` 和 `-XX:MaxPermSize` 参数进行配置。
- **元空间（Metaspace）**：使用的是本地内存（Native Memory），其大小可以动态调整。默认情况下，元空间的大小是无限制的，可以通过 `-XX:MetaspaceSize` 和 `-XX:MaxMetaspaceSize` 参数进行配置。

**优势**：使用本地内存可以避免永久代内存不足的问题，减少了 `OutOfMemoryError: PermGen space` 错误的发生。

#### 2. 动态调整大小

- **永久代（PermGen）**：大小是固定的，必须在启动时配置，运行时无法调整。
- **元空间（Metaspace）**：大小可以动态调整，JVM 会根据需要自动扩展或收缩元空间的大小。

**优势**：动态调整大小使得内存管理更加灵活，能够更好地适应不同应用的需求，减少内存浪费。

#### 3. 更好的垃圾回收性能

- **永久代（PermGen）**：由于永久代是堆的一部分，垃圾回收器在进行垃圾回收时需要扫描永久代，增加了垃圾回收的开销。
- **元空间（Metaspace）**：元空间使用本地内存，垃圾回收器不需要扫描元空间，从而减少了垃圾回收的开销，提高了垃圾回收的性能。

**优势**：减少了垃圾回收的开销，提高了垃圾回收的效率，从而提高了应用程序的性能。

#### 4. 减少内存泄漏风险

- **永久代（PermGen）**：由于永久代的大小是固定的，如果应用程序加载了大量的类或生成了大量的字符串常量，可能会导致永久代内存不足，从而引发内存泄漏。
- **元空间（Metaspace）**：由于元空间的大小可以动态调整，能够更好地适应不同应用的需求，减少了内存泄漏的风险。

**优势**：减少了内存泄漏的风险，提高了应用程序的稳定性。

#### 5.总结-5

- **使用本地内存**：元空间使用本地内存，避免了永久代内存不足的问题。
- **动态调整大小**：元空间的大小可以动态调整，内存管理更加灵活。
- **更好的垃圾回收性能**：元空间减少了垃圾回收的开销，提高了垃圾回收的效率。
- **减少内存泄漏风险**：元空间减少了内存泄漏的风险，提高了应用程序的稳定性。

元空间相对于永久代具有显著的优势，使得 JVM 的内存管理更加高效和灵活，提高了应用程序的性能和稳定性。

### 6.对象的创建销毁的过程？

#### 对象创建

**类加载检查**：

JVM 首先检查类是否已经加载、链接和初始化。如果类没有加载，JVM 会通过类加载器加载类文件，并进行链接和初始化。

**分配内存**：

JVM 在堆中为新对象分配内存。分配内存的方式有两种：指针碰撞（Bump-the-pointer）和空闲列表（Free-list）。具体使用哪种方式取决于堆是否规整。

①、指针碰撞（Bump the Pointer）

假设堆内存是一个连续的空间，分为两个部分，一部分是已经被使用的内存，另一部分是未被使用的内存。

在分配内存时，Java 虚拟机维护一个指针，指向下一个可用的内存地址，每次分配内存时，只需要将指针向后移动（碰撞）一段距离，然后将这段内存分配给对象实例即可。

②、空闲列表（Free List）

JVM 维护一个列表，记录堆中所有未占用的内存块，每个空间块都记录了大小和地址信息。

当有新的对象请求内存时，JVM 会遍历空闲列表，寻找足够大的空间来存放新对象。

分配后，如果选中的空闲块未被完全利用，剩余的部分会作为一个新的空闲块加入到空闲列表中。

指针碰撞适用于管理简单、碎片化较少的内存区域（如年轻代），而空闲列表适用于内存碎片化较严重或对象大小差异较大的场景（如老年代）。

**初始化默认值**：

JVM 将分配的内存区域初始化为默认值（零值），确保对象的实例字段在初始状态下是确定的。

**设置对象头**：

JVM 设置对象头，包括对象的元数据（如类信息）和哈希码等。

**执行构造方法**：

JVM 调用对象的构造方法（`<init>` 方法），执行对象的初始化代码。

#### 对象销毁

**对象变为不可达**：

当对象不再被任何活动线程引用时，对象变为不可达。不可达的对象会被标记为垃圾回收的候选对象。

**垃圾回收**（Garbage Collection）：

JVM 的垃圾回收器会定期扫描堆，标记和回收不可达的对象。垃圾回收的具体算法有多种，如标记-清除（Mark-Sweep）、标记-整理（Mark-Compact）和复制算法（Copying）。

调用 finalize 方法（已废弃）：

在 JDK 9 之前，JVM 会在对象被回收前调用其 finalize 方法。finalize 方法允许对象在被回收前执行一些清理操作。然而，finalize 方法存在很多问题，如不确定性和性能开销，因此在 JDK 9 之后被废弃。

**释放内存**：

垃圾回收器回收对象的内存，将其返回给堆，以便分配给新的对象。

### 7.JVM 里 new 对象时，堆会发生抢占吗？JVM 是怎么设计来保证线程安全的？

会，假设 JVM 虚拟机上，每一次 new 对象时，指针就会向右移动一个对象 size 的距离，一个线程正在给 A 对象分配内存，指针还没有来的及修改，另一个为 B 对象分配内存的线程，又引用了这个指针来分配内存，这就发生了抢占。

#### 对象创建的线程安全机制

**线程本地分配缓冲区**（TLAB - Thread Local Allocation Buffer）：

JVM 为每个线程分配一个私有的内存区域，称为线程本地分配缓冲区（TLAB）。当一个线程需要分配内存时，首先尝试在自己的 TLAB 中分配。如果 TLAB 中有足够的空间，内存分配可以在没有锁竞争的情况下完成。

当 TLAB 中的空间不足时，线程会请求 JVM 在堆中分配新的 TLAB。如果堆中没有足够的空间，JVM 会进行垃圾回收以释放内存。

**同步机制**：

当多个线程需要在堆中分配内存时，JVM 使用同步机制来确保线程安全。具体来说，JVM 使用 CAS（Compare-And-Swap）操作和锁来保证内存分配的原子性。

CAS 操作是一种无锁的并发编程技术，通过比较和交换操作来保证数据的一致性。在大多数情况下，CAS 操作比锁机制更高效，因为它避免了线程的阻塞和上下文切换。

### 8.对象的内存布局，对象的底层数据结构？

在 JVM 中，Java 对象的底层数据结构主要包括以下几个部分：

1. **对象头（Header）**
2. **实例数据（Instance Data）**
3. **对齐填充（Padding）**

#### 1. 对象头（Header）

对象头是每个对象在内存中的开销部分，包含了对象的元数据。对象头通常包括以下两个部分：

- **标记字(Mark Word)**：
  - 存储对象的运行时数据，如哈希码（HashCode）、GC 分代年龄、锁状态标志、线程持有的锁、偏向线程 ID 等。
  - Mark Word 的长度在 32 位和 64 位 JVM 中是不同的。在 32 位 JVM 中，Mark Word 通常是 32 位；在 64 位 JVM 中，Mark Word 通常是 64 位。在 64 位操作系统下占 8 个字节，32 位操作系统下占 4 个字节。

- **类型指针(Class Pointer)**：
  - 指向对象的类元数据（Class Metadata），JVM 通过这个指针找到对象的类信息。
  - 在 32 位和 64 位 JVM 中，Class Pointer 的长度分别是 32 位和 64 位。
  - 在开启了压缩指针的情况下，这个指针可以被压缩。在开启指针压缩的情况下占 4 个字节，否则占 8 个字节。
  
- **数组长度(ArrayLength)**  :
  - 如果对象是数组类型，还会有一个额外的数组长度字段。占 4 个字节。

#### 2. 实例数据（Instance Data）

实例数据部分存储对象的实际字段值，包括所有的实例变量（包括从父类继承的变量）。实例数据的布局和顺序通常由编译器决定，具体顺序可能会根据字段的类型和访问权限进行优化。

- **基本类型字段**：如 `int`、`long`、`char` 等。
- **引用类型字段**：如对象引用、数组引用等。

#### 3. 对齐填充（Padding）

为了提高内存访问的效率，JVM 要求对象的大小是某个特定字节数的倍数（通常是 8 字节）。如果对象的实例数据部分没有对齐，JVM 会在对象的末尾添加填充字节（Padding），以确保对象的大小满足对齐要求。

以下是一个简单的 Java 类，展示了对象的内存布局：

```java
public class MyObject {
    int a;       // 4 bytes
    long b;      // 8 bytes
    char c;      // 2 bytes
    Object ref;  // 4 bytes (32-bit JVM) or 8 bytes (64-bit JVM)
}
```

#### 内存布局示意图

假设在 32 位 JVM 中，`MyObject` 的内存布局如下：

```bash
+-----------------+-----------------+
|     对象头      |     Mark Word   |  4 bytes
+-----------------+-----------------+
|   Class Pointer |                 |  4 bytes
+-----------------+-----------------+
|       a         |                 |  4 bytes
+-----------------+-----------------+
|       b         |                 |  8 bytes
+-----------------+-----------------+
|       c         |                 |  2 bytes
+-----------------+-----------------+
|      ref        |                 |  4 bytes
+-----------------+-----------------+
|    Padding      |                 |  2 bytes (to align to 8 bytes)
+-----------------+-----------------+
```

#### 总结-8

- **对象头（Header）**：包含 Mark Word 和 Class Pointer，用于存储对象的元数据和类信息。
- **实例数据（Instance Data）**：存储对象的实际字段值，包括基本类型字段和引用类型字段。
- **对齐填充（Padding）**：用于确保对象的大小满足对齐要求，提高内存访问的效率。

对象的内存布局是 JVM 内存管理的重要组成部分，通过合理的内存布局和对齐策略，JVM 能够提高内存访问的效率和程序的性能。

### 9.对象如何访问定位？

在 JVM 中，对象的访问定位主要依赖于对象引用和对象在内存中的布局。JVM 使用两种主要的方式来访问和定位对象：

1. **句柄访问（Handle Access）**
2. **直接指针访问（Direct Pointer Access）**

#### 1. 句柄访问（Handle Access）

在句柄访问方式中，JVM 会为每个对象分配一个句柄。句柄是一个固定大小的内存块，包含了对象实例数据和对象类型数据的指针。对象引用指向句柄，而不是直接指向对象实例数据。

- **句柄结构**：
  - **句柄指针**：对象引用指向句柄。
  - **句柄内容**：句柄包含两个指针，一个指向对象实例数据，一个指向对象类型数据（类元数据）。

- **优点**：
  - 对象在内存中的移动不会影响对象引用，因为引用指向的是句柄，句柄中的指针可以更新。
  - 适用于需要频繁移动对象的垃圾回收算法。

- **缺点**：
  - 访问对象时需要两次内存间接访问（一次访问句柄，一次访问对象实例数据），性能略低。

#### 2. 直接指针访问（Direct Pointer Access）

在直接指针访问方式中，对象引用直接指向对象实例数据。对象实例数据包含对象头和实例字段。

- **直接指针结构**：
  - **对象引用**：直接指向对象实例数据。
  - **对象实例数据**：包含对象头和实例字段。

- **优点**：
  - 访问对象时只需要一次内存间接访问，性能较高。
  - 适用于对象较少移动的垃圾回收算法。

- **缺点**：
  - 对象在内存中的移动需要更新所有引用该对象的指针，增加了垃圾回收的复杂性。

HotSpot 虚拟机主要使用直接指针来进行对象访问。

### 10.说说内存溢出（OOM）和内存泄漏（Leak Memory）的原因？

#### 内存溢出是什么

在 Java 中，OOM（OutOfMemoryError）错误表示 JVM 无法再为应用程序分配所需的内存。OOM 错误可能发生在以下几个内存区域：

1. **堆内存（Heap Memory）**
2. **方法区（Method Area）/元空间（Metaspace）**
3. **栈内存（Stack Memory）**
4. **直接内存（Direct Memory）**

##### 1. 堆内存（Heap Memory）

**描述**：

- 堆内存用于存储所有对象实例和数组，是垃圾回收的主要区域。

**OOM 发生原因**：

- **对象过多**：应用程序创建了过多的对象，导致堆内存耗尽。
- **内存泄漏**：对象不再被使用，但仍然被引用，导致垃圾回收器无法回收这些对象。
- **大对象分配**：尝试分配一个非常大的对象，超过了堆内存的最大限制。

**示例**：

```java
public class HeapOOM {
    public static void main(String[] args) {
        List<Object> list = new ArrayList<>();
        while (true) {
            list.add(new Object());
        }
    }
}
```

##### 2. 方法区（Method Area）/元空间（Metaspace）

**描述**：

- 方法区在 JDK 1.8 之前被实现为永久代（PermGen），在 JDK 1.8 之后被实现为元空间（Metaspace）。方法区用于存储类信息、常量、静态变量和即时编译器编译后的代码。

**OOM 发生原因**：

- **类加载过多**：动态生成大量类，导致方法区或元空间耗尽。
- **常量池过大**：大量字符串常量或其他常量，导致常量池耗尽。

**示例**：

```java
public class MetaspaceOOM {
    public static void main(String[] args) {
        while (true) {
            Enhancer enhancer = new Enhancer();
            enhancer.setSuperclass(OOMObject.class);
            enhancer.setUseCache(false);
            enhancer.setCallback(new MethodInterceptor() {
                @Override
                public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {
                    return proxy.invokeSuper(obj, args);
                }
            });
            enhancer.create();
        }
    }
}
```

##### 3. 栈内存（Stack Memory）

**描述**：

- 栈内存用于存储每个线程的局部变量、操作数栈和帧数据。每个线程都有自己的栈内存。

**OOM 发生原因**：

- **栈帧过多**：递归调用过深或方法调用层次过多，导致栈内存耗尽。
- **线程过多**：创建了过多的线程，每个线程都需要分配栈内存，导致栈内存耗尽。

**示例**：

```java
public class StackOverflow {
    public static void main(String[] args) {
        recursiveCall();
    }

    public static void recursiveCall() {
        recursiveCall();
    }
}
```

##### 4. 直接内存（Direct Memory）

**描述**：

- 直接内存是 JVM 之外的内存区域，通过 `java.nio` 包中的 `ByteBuffer` 类进行分配和管理。

**OOM 发生原因**：

- **直接内存分配过多**：分配了过多的直接内存，超过了系统的限制。

**示例**：

```java
public class DirectMemoryOOM {
    private static final int _1MB = 1024 * 1024;

    public static void main(String[] args) throws Exception {
        List<ByteBuffer> buffers = new ArrayList<>();
        while (true) {
            buffers.add(ByteBuffer.allocateDirect(_1MB));
        }
    }
}
```

##### 总结-10-1

- **堆内存（Heap Memory）**：对象过多、内存泄漏、大对象分配。
- **方法区（Method Area）/元空间（Metaspace）**：类加载过多、常量池过大。
- **栈内存（Stack Memory）**：栈帧过多、线程过多。
- **直接内存（Direct Memory）**：直接内存分配过多。

OOM 错误通常是由于内存分配超过了 JVM 或系统的限制，了解这些内存区域及其可能的 OOM 原因，有助于在开发和调试过程中更好地管理和优化内存使用。

#### 内存泄漏可能由哪些原因导致呢？

内存泄漏可能的原因有很多种，比如说静态集合类引起内存泄漏、单例模式、数据连接、IO、Socket 等连接、变量不合理的作用域、hash 值发生变化、ThreadLocal 使用不当等。

①、**静态集合类引起内存泄漏**:

静态集合的生命周期和 JVM 一致，所以静态集合引用的对象不能被释放。

```java
public class OOM {
 static List list = new ArrayList();

 public void oomTests(){
   Object obj = new Object();

   list.add(obj);
  }
}
```

②、**单例模式**:

和上面的例子原理类似，*单例对象在初始化后会以静态变量的方式在 JVM 的整个生命周期中存在*。如果单例对象持有外部的引用，那么这个外部对象将不能被 GC 回收，导致内存泄漏。

③、**数据连接、IO、Socket 等连接**:

创建的连接不再使用时，需要调用 close 方法关闭连接，只有连接被关闭后，GC 才会回收对应的对象（Connection，Statement，ResultSet，Session）。忘记关闭这些资源会导致持续占有内存，无法被 GC 回收。

```java
try {
    Connection conn = null;
    Class.forName("com.mysql.jdbc.Driver");
    conn = DriverManager.getConnection("url", "", "");
    Statement stmt = conn.createStatement();
    ResultSet rs = stmt.executeQuery("....");
  } catch (Exception e) {

  }finally {
    //不关闭连接
  }
```

④、**变量不合理的作用域**:

一个变量的定义作用域大于其使用范围，很可能存在内存泄漏；或不再使用对象没有及时将对象设置为 null，很可能导致内存泄漏的发生。

```java
public class Simple {
    Object object;
    public void method1(){
        object = new Object();
        //...其他代码
        //由于作用域原因，method1执行完成之后，object 对象所分配的内存不会马上释放
        object = null;
    }
}
```

⑤、**hash 值发生变化**:

对象 Hash 值改变，使用 HashMap、HashSet 等容器中时候，由于对象修改之后的 Hah 值和存储进容器时的 Hash 值不同，所以无法找到存入的对象，自然也无法单独删除了，这也会造成内存泄漏。说句题外话，这也是为什么 String 类型被设置成了不可变类型。

⑥、**ThreadLocal 使用不当**:

ThreadLocal 的弱引用导致内存泄漏也是个老生常谈的话题了(键是弱引用会回收，但是值是强引用)，使用完 ThreadLocal 一定要记得使用 remove 方法来进行清除。

### 11.Java 堆的内存分区了解吗？

Java 堆是 JVM 内存管理的重要组成部分，用于存储所有对象实例和数组。为了提高垃圾回收的效率，Java 堆通常被划分为几个不同的区域，每个区域有不同的用途和垃圾回收策略。主要的内存分区包括：

1. **新生代（Young Generation）**
2. **老年代（Old Generation）**
3. **永久代（PermGen）/元空间（Metaspace）**

#### 1. 新生代（Young Generation）

新生代用于存储新创建的对象。新生代进一步划分为三个区域：

- **Eden 区**：大部分新对象在 Eden 区分配。当 Eden 区满时，会触发一次 Minor GC，将存活的对象移动到 Survivor 区。
- **Survivor 区**：新生代包含两个 Survivor 区，分别称为 S0（From）和 S1（To）。每次 Minor GC 后，存活的对象会在两个 Survivor 区之间复制和交换。一个 Survivor 区是空的，另一个 Survivor 区存储存活的对象。

**垃圾回收**：

- **Minor GC**：新生代的垃圾回收称为 Minor GC，频率较高，但速度较快。Minor GC 主要回收 Eden 区和一个 Survivor 区的对象。

#### 2. 老年代（Old Generation）

老年代用于存储生命周期较长的对象。经过多次 Minor GC 仍然存活的对象会被移动到老年代。老年代的空间通常比新生代大，垃圾回收的频率较低，但回收时间较长。

**垃圾回收**：

- **Major GC / Full GC**：老年代的垃圾回收称为 Major GC 或 Full GC，频率较低，但速度较慢。Full GC 会回收整个堆，包括新生代和老年代。

#### 3. 永久代（PermGen）/元空间（Metaspace）

永久代和元空间用于存储类信息、常量、静态变量和即时编译器编译后的代码。

- **永久代（PermGen）**：在 JDK 1.8 之前，永久代用于存储类元数据。永久代的大小是固定的，可以通过 `-XX:PermSize` 和 `-XX:MaxPermSize` 参数进行配置。
- **元空间（Metaspace）**：在 JDK 1.8 之后，永久代被移除，取而代之的是元空间。元空间使用本地内存（Native Memory），其大小可以动态调整，可以通过 `-XX:MetaspaceSize` 和 `-XX:MaxMetaspaceSize` 参数进行配置。

#### 内存分区示意图

```bash
+------------------+
|      堆          |
| +--------------+ |
| |   新生代      | |
| | +----------+ | |
| | |  Eden    | | |
| | +----------+ | |
| | | Survivor | | |
| | |    S0    | | |
| | +----------+ | |
| | | Survivor | | |
| | |    S1    | | |
| | +----------+ | |
| +--------------+ |
| +--------------+ |
| |   老年代      | |
| +--------------+ |
+------------------+
+------------------+
|  永久代/元空间   |
+------------------+
```

#### 总结-11

- **新生代（Young Generation）**：用于存储新创建的对象，进一步划分为 Eden 区和两个 Survivor 区。主要通过 Minor GC 进行垃圾回收。
- **老年代（Old Generation）**：用于存储生命周期较长的对象。主要通过 Major GC 或 Full GC 进行垃圾回收。
- **永久代（PermGen）/元空间（Metaspace）**：用于存储类信息、常量、静态变量和即时编译器编译后的代码。在 JDK 1.8 之前为永久代，之后为元空间。

通过合理的内存分区和垃圾回收策略，JVM 能够高效地管理内存，确保应用程序的性能和稳定性。

### 12.对象什么时候会进入老年代？

在 Java 的垃圾回收机制中，对象从新生代（Young Generation）移动到老年代（Old Generation）的过程称为对象晋升（Promotion）。对象进入老年代的主要情况如下：

#### 1. 对象年龄达到阈值

- **对象年龄**：每个对象在新生代中存活的时间被称为对象年龄。每次 Minor GC 后，存活的对象会在 Eden 区和 Survivor 区之间复制和交换，对象的年龄会增加。
- **年龄阈值**：当对象的年龄达到某个阈值（默认是 15，可以通过 `-XX:MaxTenuringThreshold` 参数配置）时，对象会被晋升到老年代。

#### 2. Survivor 区空间不足

- **Survivor 区空间不足**：如果在进行 Minor GC 时，Survivor 区没有足够的空间来存放存活的对象，这些对象会直接晋升到老年代。
- **动态年龄判定**：JVM 可能会根据 Survivor 区的使用情况动态调整对象晋升的年龄阈值，以优化内存使用。

#### 3. 大对象直接进入老年代

- **大对象**：一些大对象（如大数组、大字符串等）可能会直接分配到老年代，以避免在新生代中频繁复制和移动。
- **大对象阈值**：可以通过 `-XX:PretenureSizeThreshold` 参数配置大对象的阈值，超过该阈值的对象会直接分配到老年代。

#### 4. 新生代空间不足

- **新生代空间不足**：如果新生代的空间不足以容纳新创建的对象，JVM 会触发 Minor GC。如果在 Minor GC 后，新生代仍然没有足够的空间，部分存活的对象会被晋升到老年代。

以下是一个简单的 Java 示例，展示了对象晋升到老年代的过程：

```java
public class ObjectPromotionExample {
    private static final int _1MB = 1024 * 1024;

    public static void main(String[] args) {
        byte[] allocation1, allocation2, allocation3;
        allocation1 = new byte[2 * _1MB];
        allocation2 = new byte[2 * _1MB];
        allocation3 = new byte[4 * _1MB]; // 触发 Minor GC
    }
}
```

在上述代码中，`allocation3` 的分配会触发一次 Minor GC，如果 `allocation1` 和 `allocation2` 存活且 Survivor 区空间不足，它们可能会被晋升到老年代。

#### 总结-12

- **对象年龄达到阈值**：对象在新生代中存活的时间达到某个阈值时，会被晋升到老年代。
- **Survivor 区空间不足**：在进行 Minor GC 时，如果 Survivor 区没有足够的空间存放存活的对象，这些对象会被晋升到老年代。
- **大对象直接进入老年代**：一些大对象可能会直接分配到老年代，以避免在新生代中频繁复制和移动。
- **新生代空间不足**：如果新生代空间不足以容纳新创建的对象，部分存活的对象会被晋升到老年代。

通过合理的内存管理和垃圾回收策略，JVM 能够高效地管理对象的生命周期，确保应用程序的性能和稳定性。

### 13.什么是 Stop The World ? 什么是 OopMap ？什么是安全点？

#### Stop The World (STW)

**Stop The World (STW)** 是指在垃圾回收过程中，JVM 会暂停所有应用程序线程的执行，以便进行垃圾回收操作。这种暂停是全局性的，所有的应用程序线程都会被挂起，直到垃圾回收完成。

**特点**：

- **全局暂停**：所有应用程序线程都会被暂停，只有垃圾回收线程在运行。
- **暂停时间**：暂停时间取决于垃圾回收算法和堆的大小。对于一些垃圾回收算法（如 Full GC），暂停时间可能会较长。
- **影响**：STW 会影响应用程序的响应时间和性能，特别是在大堆内存和长时间暂停的情况下。

#### OopMap

**OopMap** 是 JVM 中的一种数据结构，用于记录对象引用的位置。OopMap 在垃圾回收过程中起到了关键作用，帮助垃圾回收器快速找到对象引用，以便进行标记和回收。

**特点**：

- **记录引用位置**：OopMap 记录了每个栈帧和寄存器中对象引用的位置。
- **生成时机**：JVM 在编译字节码时生成 OopMap，并在方法调用和返回、异常处理等关键点更新 OopMap。
- **作用**：在垃圾回收过程中，OopMap 帮助垃圾回收器快速找到对象引用，避免全堆扫描，提高垃圾回收效率。

#### 安全点（Safepoint）

**安全点（Safepoint）** 是指 JVM 在执行过程中，能够安全地暂停所有应用程序线程的特定位置。垃圾回收器需要在安全点暂停线程，以确保线程在一致的状态下进行垃圾回收。

**特点**：

- **特定位置**：安全点通常设置在方法调用、循环回边和异常处理等位置。
- **线程一致性**：在安全点暂停线程，确保线程在一致的状态下进行垃圾回收。
- **触发机制**：当垃圾回收器需要进行 STW 操作时，会触发安全点，暂停所有应用程序线程。

以下是一个简单的 Java 示例，展示了垃圾回收过程中可能涉及的 STW、OopMap 和安全点：

```java
public class StopTheWorldExample {
    public static void main(String[] args) {
        for (int i = 0; i < 100000; i++) {
            allocateMemory();
        }
    }

    private static void allocateMemory() {
        byte[] array = new byte[1024 * 1024]; // 分配 1MB 内存
    }
}
```

在上述代码中，`allocateMemory` 方法会频繁分配内存，可能会触发垃圾回收。在垃圾回收过程中，JVM 会暂停所有应用程序线程（STW），使用 OopMap 记录对象引用的位置，并在安全点暂停线程。

#### 总结-13

- **Stop The World (STW)**：在垃圾回收过程中，JVM 会暂停所有应用程序线程的执行，以便进行垃圾回收操作。
- **OopMap**：一种数据结构，用于记录对象引用的位置，帮助垃圾回收器快速找到对象引用，提高垃圾回收效率。
- **安全点（Safepoint）**：JVM 在执行过程中能够安全地暂停所有应用程序线程的特定位置，确保线程在一致的状态下进行垃圾回收。

通过合理的垃圾回收策略和机制，JVM 能够高效地管理内存，确保应用程序的性能和稳定性。

### 14.对象一定分配在堆中吗？有没有了解逃逸分析技术？

#### 对象一定分配在堆中吗？

在 Java 中，通常情况下，对象是分配在堆内存中的。然而，通过一些优化技术，特别是逃逸分析（Escape Analysis），对象也可以在栈上分配，从而减少堆内存的使用和垃圾回收的开销。

#### 逃逸分析（Escape Analysis）

逃逸分析是一种编译时优化技术，用于确定对象的动态作用域。通过逃逸分析，JVM 可以判断对象是否会逃逸出方法或线程的作用域，从而决定对象的分配位置。

##### 逃逸分析的类型

1. **方法逃逸（Method Escape）**：
   - 如果对象在方法外部被引用，则认为对象发生了方法逃逸。
   - 例如，将对象作为参数传递给其他方法，或者将对象赋值给类的成员变量。

2. **线程逃逸（Thread Escape）**：
   - 如果对象在方法外部被其他线程引用，则认为对象发生了线程逃逸。
   - 例如，将对象作为参数传递给其他线程，或者将对象存储在共享数据结构中。

##### 逃逸分析的优化

1. **栈上分配（Stack Allocation）**：
   - 如果对象没有发生逃逸，JVM 可以将对象分配在栈上，而不是堆中。这样，当方法执行完毕时，对象会自动销毁，无需垃圾回收。
   - 优点：减少堆内存的使用，降低垃圾回收的频率和开销。

2. **标量替换（Scalar Replacement）**：
   - 如果对象没有发生逃逸，且对象的字段可以被拆分为标量变量，JVM 可以将对象的字段直接分配在栈上，而不是创建对象。
   - 优点：进一步减少内存分配和垃圾回收的开销。

3. **同步消除（Synchronization Elimination）**：
   - 如果对象没有发生线程逃逸，JVM 可以消除对象上的同步操作，从而提高并发性能。
   - 优点：减少不必要的同步开销，提高程序的并发性能。

以下是一个简单的 Java 示例，展示了逃逸分析的应用：

```java
public class EscapeAnalysisExample {
    public static void main(String[] args) {
        for (int i = 0; i < 1000000; i++) {
            allocateMemory();
        }
    }

    private static void allocateMemory() {
        Point p = new Point(1, 2); // 可能在栈上分配
        System.out.println(p);
    }
}

class Point {
    int x, y;

    Point(int x, int y) {
        this.x = x;
        this.y = y;
    }

    @Override
    public String toString() {
        return "Point{" + "x=" + x + ", y=" + y + '}';
    }
}
```

在上述代码中，`Point` 对象在 `allocateMemory`方法中创建。如果 JVM 通过逃逸分析确定 `Point` 对象没有发生逃逸，则可以将其分配在栈上，而不是堆中。

#### 总结-14

- **对象分配位置**：通常情况下，对象分配在堆中。然而，通过逃逸分析，JVM 可以将未逃逸的对象分配在栈上，从而减少堆内存的使用和垃圾回收的开销。
- **逃逸分析**：一种编译时优化技术，用于确定对象的动态作用域，判断对象是否会逃逸出方法或线程的作用域。
- **优化技术**：
  - **栈上分配**：将未逃逸的对象分配在栈上。
  - **标量替换**：将未逃逸对象的字段拆分为标量变量，直接分配在栈上。
  - **同步消除**：消除未发生线程逃逸对象上的同步操作。

通过逃逸分析和相关优化技术，JVM 能够提高内存管理的效率，减少垃圾回收的开销，从而提高应用程序的性能。

### 15.JVM垃圾回收机制？

垃圾回收（Garbage Collection, GC）是 JVM 自动管理内存的一种机制，用于回收不再使用的对象所占用的内存空间。GC 的主要目标是释放无用对象的内存，防止内存泄漏和内存溢出，从而提高应用程序的性能和稳定性。

#### 对象回收判定

在 JVM 中，判断对象是否存活是垃圾回收的核心任务。主要有两种方法来判断对象是否存活：

1. **引用计数法（Reference Counting）**
2. **可达性分析法（Reachability Analysis）**

##### 1. 引用计数法（Reference Counting）

**描述**：

- 每个对象维护一个引用计数器，记录有多少引用指向该对象。
- 当一个新的引用指向该对象时，引用计数器加一；当一个引用不再指向该对象时，引用计数器减一。
- 当引用计数器为零时，表示该对象不再被引用，可以被回收。

**优点**：

- 实现简单，判断对象是否存活的时间复杂度为 O(1)。

**缺点**：

- 无法处理循环引用的问题。例如，两个对象互相引用，但它们不再被其他对象引用，引用计数器永远不会为零，导致内存泄漏。

##### 2. 可达性分析法（Reachability Analysis）

**描述**：

- 从根对象（GC Roots）开始，沿着引用链遍历对象，标记所有可达的对象。
- 未被标记的对象即为不可达，可以被回收。

**GC Roots**：

- 栈中的引用（如局部变量、方法参数等）
- 静态字段引用
- 常量池中的引用
- JNI（Java Native Interface）引用

**优点**：

- 能够正确处理循环引用的问题。

**缺点**：

- 实现复杂，遍历对象图的时间复杂度较高。

以下是一个简单的 Java 示例，展示了对象的可达性分析：

```java
public class GCRootsExample {
    private static GCRootsExample staticField;
    private GCRootsExample instanceField;

    public static void main(String[] args) {
        GCRootsExample obj1 = new GCRootsExample();
        staticField = obj1; // 静态字段作为 GC Roots
        GCRootsExample obj2 = new GCRootsExample();
        obj1.instanceField = obj2; // 实例字段引用
        obj2 = null; // obj2 不再引用 GCRootsExample 对象
        System.gc(); // 触发垃圾回收
    }
}
```

在上述代码中，`staticField` 和 `instanceField` 作为 GC Roots，`obj1` 和 `obj2` 的可达性由 GC Roots 判断。

##### 总结-15-1

- **引用计数法（Reference Counting）**：每个对象维护一个引用计数器，记录有多少引用指向该对象。当引用计数器为零时，表示对象不再被引用，可以被回收。缺点是无法处理循环引用的问题。
- **可达性分析法（Reachability Analysis）**：从根对象（GC Roots）开始，沿着引用链遍历对象，标记所有可达的对象。未被标记的对象即为不可达，可以被回收。优点是能够正确处理循环引用的问题。

#### 垃圾回收算法

垃圾收集算法是 JVM 内存管理的重要组成部分，用于自动回收不再使用的对象所占用的内存空间。常见的垃圾收集算法包括：

1. **标记-清除算法（Mark-Sweep）**
2. **复制算法（Copying）**
3. **标记-整理算法（Mark-Compact）**
4. **分代收集算法（Generational Collection）**

##### 1. 标记-清除算法（Mark-Sweep）

**描述**：

- **标记阶段**：从根对象（GC Roots）开始，标记所有可达的对象。
- **清除阶段**：遍历堆，回收未被标记的对象。

**优点**：

- 实现简单，能够处理大多数场景。

**缺点**：

- 清除阶段会产生内存碎片，影响内存分配效率。

##### 2. 复制算法（Copying）

**描述**：

- 将内存划分为两个相等的区域（From 和 To）。
- 每次垃圾回收时，将存活的对象从 From 区复制到 To 区，未被复制的对象即为垃圾。
- 复制完成后，交换 From 和 To 的角色。

**优点**：

- 没有内存碎片，内存分配效率高。

**缺点**：

- 需要两倍的内存空间，内存利用率较低。

##### 3. 标记-整理算法（Mark-Compact）

**描述**：

- **标记阶段**：从根对象（GC Roots）开始，标记所有可达的对象。
- **整理阶段**：将所有存活的对象压缩到堆的一端，清理掉边界以外的内存。

**优点**：

- 没有内存碎片，内存利用率高。

**缺点**：

- 整理阶段需要移动对象，开销较大。

##### 4. 分代收集算法（Generational Collection）

**描述**：

- 将堆内存划分为新生代（Young Generation）和老年代（Old Generation）。
- 新生代使用复制算法，老年代使用标记-整理算法。

**优点**：

- 结合了复制算法和标记-整理算法的优点，能够高效地管理内存。

**缺点**：

- 实现复杂，需要调优。

##### 总结-15-2

- **标记-清除算法（Mark-Sweep）**：标记所有可达的对象，清除未被标记的对象。缺点是会产生内存碎片。
- **复制算法（Copying）**：将存活的对象从一个区域复制到另一个区域，没有内存碎片，但内存利用率较低。
- **标记-整理算法（Mark-Compact）**：标记所有可达的对象，将存活的对象压缩到堆的一端，没有内存碎片，但需要移动对象。
- **分代收集算法（Generational Collection）**：将堆内存划分为新生代和老年代，结合了复制算法和标记-整理算法的优点，能够高效地管理内存。

#### 垃圾回收类型

在 JVM 中，垃圾回收（GC）可以根据回收的内存区域和回收策略分为不同的类型。主要的垃圾回收类型包括：

1. **Minor GC / Young GC**
2. **Major GC / Old GC**
3. **Mixed GC**
4. **Full GC**

##### 1. Minor GC / Young GC

**描述**：

- Minor GC 也称为 Young GC，主要针对新生代（Young Generation）进行垃圾回收。
- 新生代通常使用复制算法（Copying），将存活的对象从 Eden 区和一个 Survivor 区复制到另一个 Survivor 区。

**触发条件**：

- 当 Eden 区满时，会触发 Minor GC。

**特点**：

- 频率较高，但回收速度较快。
- 只回收新生代，不涉及老年代。

##### 2. Major GC / Old GC

**描述**：

- Major GC 也称为 Old GC，主要针对老年代（Old Generation）进行垃圾回收。
- 老年代通常使用标记-整理算法（Mark-Compact），标记所有可达的对象，并将存活的对象压缩到堆的一端。

**触发条件**：

- 当老年代满时，会触发 Major GC。

**特点**：

- 频率较低，但回收速度较慢。
- 只回收老年代，不涉及新生代。

##### 3. Mixed GC

**描述**：

- Mixed GC 是 G1 垃圾回收器的一种回收策略，回收新生代和部分老年代。
- G1 垃圾回收器将堆划分为多个区域（Region），Mixed GC 会同时回收新生代和一些老年代的区域。

**触发条件**：

- 当新生代满时，或者根据 G1 的回收策略触发。

**特点**：

- 结合了 Minor GC 和 Major GC 的优点，能够高效地管理内存。
- 回收范围更广，能够减少 Full GC 的频率。

##### 4. Full GC

**描述**：

- Full GC 是一次全堆的垃圾回收，回收新生代、老年代和元空间（Metaspace）。
- Full GC 通常使用标记-整理算法（Mark-Compact）或标记-清除算法（Mark-Sweep）。

**触发条件**：

- 当堆内存不足，或者显式调用 `System.gc()` 时，会触发 Full GC。

**特点**：

- 频率最低，但回收速度最慢。
- 暂停时间最长，对应用程序的性能影响最大。

##### 总结-15-3

- **Minor GC / Young GC**：主要针对新生代进行垃圾回收，频率较高，但回收速度较快。
- **Major GC / Old GC**：主要针对老年代进行垃圾回收，频率较低，但回收速度较慢。
- **Mixed GC**：G1 垃圾回收器的一种回收策略，回收新生代和部分老年代，结合了 Minor GC 和 Major GC 的优点。
- **Full GC**：一次全堆的垃圾回收，回收新生代、老年代和元空间，频率最低，但回收速度最慢，对应用程序的性能影响最大。

#### 垃圾收集器

JVM 提供了多种垃圾收集器，每种垃圾收集器都有其独特的特点和适用场景。以下是一些常见的垃圾收集器：

##### 1. Serial 收集器

**描述**：

- Serial 收集器是最基本的垃圾收集器，使用单线程进行垃圾回收。
- 适用于单线程环境或小型应用。

**特点**：

- 简单高效，适用于单核 CPU。
- 在进行垃圾回收时，会暂停所有应用程序线程（Stop The World）。

**适用场景**：

- 单线程环境或小型应用。

##### 2. ParNew 收集器

**描述**：

- ParNew 收集器是 Serial 收集器的多线程版本，使用多线程进行垃圾回收。
- 主要用于新生代的垃圾回收。

**特点**：

- 多线程并行回收，适用于多核 CPU。
- 与 CMS 收集器配合使用。

**适用场景**：

- 多线程环境，适用于新生代的垃圾回收。

##### 3. Parallel 收集器

**描述**：

- Parallel 收集器也称为吞吐量收集器，使用多线程进行垃圾回收，主要关注吞吐量。
- 适用于新生代和老年代的垃圾回收。
- 吞吐量 = 运行用户代码的时间/（运行垃圾收集的时间+运行用户代码的时间）
**特点**：

- 多线程并行回收，适用于多核 CPU。
- 关注吞吐量，适用于后台计算等对响应时间要求不高的场景。

**适用场景**：

- 需要高吞吐量的应用，如后台计算、批处理等。

##### 4. CMS 收集器

**描述**：

- CMS（Concurrent Mark-Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。
- 主要用于老年代的垃圾回收。

**特点**：

- 并发回收，减少停顿时间。
- 适用于对响应时间要求高的应用，如 Web 服务器。
- CMS（Concurrent Mark Sweep）主要使用了标记-清除算法进行垃圾收集，分 4 大步：
  - 初始标记（Initial Mark）：标记所有从 GC Roots 直接可达的对象，这个阶段需要 STW，但速度很快。
  - 并发标记（Concurrent Mark）：从初始标记的对象出发，遍历所有对象，标记所有可达的对象。这个阶段是并发进行的，STW。
  - 重新标记（Remark）：完成剩余的标记工作，包括处理并发阶段遗留下来的少量变动，这个阶段通常需要短暂的 STW 停顿。
  - 并发清除（Concurrent Sweep）：清除未被标记的对象，回收它们占用的内存空间。
  
**remark的过程**:

remark 阶段通常会结合三色标记法来执行，确保在并发标记期间所有存活对象都被正确标记。目的是修正并发标记阶段中可能遗漏的对象引用变化。

在 remark 阶段，垃圾收集器会停止应用线程（STW），以确保在这个阶段不会有引用关系的进一步变化。这种暂停通常很短暂。remark 阶段主要包括以下操作：

- 1.处理写屏障记录的引用变化：在并发标记阶段，应用程序可能会更新对象的引用（比如一个黑色对象新增了对一个白色对象的引用），这些变化通过写屏障记录下来。在 remark 阶段，GC 会处理这些记录，确保所有可达对象都正确地标记为灰色或黑色。
- 2.扫描灰色对象：再次遍历灰色对象，处理它们的所有引用，确保引用的对象正确标记为灰色或黑色。
- 3.清理：确保所有引用关系正确处理后，灰色对象标记为黑色，白色对象保持不变。这一步完成后，所有存活对象都应当是黑色的。

**三色标记法**：

白色（White）：尚未访问的对象。垃圾回收结束后，仍然为白色的对象会被认为是不可达的对象，可以回收。

灰色（Gray）：已经访问到但未标记完其引用的对象。灰色对象是需要进一步处理的。

黑色（Black）：已经访问到并且其所有引用对象都已经标记过。黑色对象是完全处理过的，不需要再处理。
三色标记法的工作流程：

①、初始标记（Initial Marking）：从 GC Roots 开始，标记所有直接可达的对象为灰色。

②、并发标记（Concurrent Marking）：在此阶段，标记所有灰色对象引用的对象为灰色，然后将灰色对象自身标记为黑色。这个过程是并发的，和应用线程同时进行。

此阶段的一个问题是，应用线程可能在并发标记期间修改对象的引用关系，导致一些对象的标记状态不准确。

③、重新标记（Remarking）：重新标记阶段的目标是处理并发标记阶段遗漏的引用变化。为了确保所有存活对象都被正确标记，remark 需要在 STW 暂停期间执行。

④、使用写屏障（Write Barrier）来捕捉并发标记阶段应用线程对对象引用的更新。通过遍历这些更新的引用来修正标记状态，确保遗漏的对象不会被错误地回收。

**适用场景**：

- 对响应时间要求高的应用，如 Web 服务器。

##### 5. G1 收集器

**描述**：

- G1（Garbage First）收集器是一种面向服务端应用的垃圾收集器，适用于多核 CPU 和大内存环境。
- 将堆划分为多个区域（Region），使用并行和并发的方式进行垃圾回收。这种区域化管理使得 G1 可以更灵活地进行垃圾收集，只回收部分区域而不是整个新生代或老年代。
- G1（Garbage-First Garbage Collector）*在 JDK 1.7 时引入，在 JDK 9 时取代 CMS 成为了默认的垃圾收集器*。

**运行过程**：

①、并发标记，G1 通过并发标记的方式找出堆中的垃圾对象。并发标记阶段与应用线程同时执行，不会导致应用线程暂停。

②、混合收集，在并发标记完成后，G1 会计算出哪些区域的回收价值最高（也就是包含最多垃圾的区域），然后优先回收这些区域。这种回收方式包括了部分新生代区域和老年代区域。

选择回收成本低而收益高的区域进行回收，可以提高回收效率和减少停顿时间。

③、可预测的停顿，G1 在垃圾回收期间仍然需要「Stop the World」。不过，G1 在停顿时间上添加了预测机制，用户可以 JVM 启动时指定期望停顿时间，G1 会尽可能地在这个时间内完成垃圾回收。

**特点**：

- 并行和并发回收，减少停顿时间。
- 适用于大内存和多核 CPU 环境。
- 支持预测停顿时间。

**适用场景**：

- 大内存和多核 CPU 环境，适用于对响应时间和吞吐量都有要求的应用。

##### 6. ZGC 收集器

**描述**：

- ZGC（Z Garbage Collector）是一种低延迟垃圾收集器，适用于大内存和低延迟要求的应用。
- 使用并发标记和并发压缩技术，减少停顿时间。

**特点**：

- 低延迟，停顿时间通常在 10 毫秒以内。
- 适用于大内存和低延迟要求的应用。

**适用场景**：

- 大内存和低延迟要求的应用，如金融交易系统。

##### 7. Shenandoah 收集器

**描述**：

- Shenandoah 收集器是一种低延迟垃圾收集器，适用于大内存和低延迟要求的应用。
- 使用并发标记和并发压缩技术，减少停顿时间。

**特点**：

- 低延迟，停顿时间通常在 10 毫秒以内。
- 适用于大内存和低延迟要求的应用。

**适用场景**：

- 大内存和低延迟要求的应用，如金融交易系统。

##### 总结-15-4

- **Serial 收集器**：单线程垃圾收集器，适用于单线程环境或小型应用。
- **ParNew 收集器**：多线程版本的 Serial 收集器，适用于多线程环境，主要用于新生代的垃圾回收。
- **Parallel 收集器**：关注吞吐量的多线程垃圾收集器，适用于需要高吞吐量的应用。
- **CMS 收集器**：并发标记-清除垃圾收集器，适用于对响应时间要求高的应用。
- **G1 收集器**：面向服务端应用的垃圾收集器，适用于大内存和多核 CPU 环境。
- **ZGC 收集器**：低延迟垃圾收集器，适用于大内存和低延迟要求的应用。
- **Shenandoah 收集器**：低延迟垃圾收集器，适用于大内存和低延迟要求的应用。

### 16.有了 CMS，为什么还要引入 G1？

| 特性 | CMS | G1 |
| --- | --- | --- |
| 设计目标 | 低停顿时间 | 可预测的停顿时间 |
| 并发性 | 是 | 是 |
| 内存碎片 | 是，容易产生碎片 | 否，通过区域划分和压缩减少碎片 |
| 收集代数 | 年轻代和老年代 | 整个堆，但区分年轻代和老年代 |
| 并发阶段 | 并发标记、并发清理 | 并发标记、并发清理、并发回收 |
| 停顿时间预测 | 较难预测 | 可配置停顿时间目标 |
| 容易出现的问题 | 内存碎片、Concurrent Mode Failure | 较少出现长时间停顿 |

CMS 适用于对延迟敏感的应用场景，主要目标是减少停顿时间，但容易产生内存碎片。G1 则提供了更好的停顿时间预测和内存压缩能力，适用于大内存和多核处理器环境。

### 16.有哪些常用的命令行性能监控和故障处理工具？

**操作系统工具**：

- top：显示系统整体资源使用情况
- vmstat：监控内存和 CPU
- iostat：监控 IO 使用
- netstat：监控网络使用

**JDK 性能监控工具**：

- jps：虚拟机进程查看
- jstat：虚拟机运行时信息查看
- jinfo：虚拟机配置查看
- jmap：内存映像（导出）
- jhat：堆转储快照分析
- jstack：Java 堆栈跟踪
- jcmd：实现上面除了 jstat 外所有命令的功能

### 17.了解哪些可视化的性能监控和故障处理工具？

除了命令行工具，Java 生态系统中还有许多强大的可视化工具，用于性能监控和故障处理。这些工具提供了图形化界面，使得监控和诊断更加直观和便捷。以下是一些常用的可视化工具：

#### 1. VisualVM

**描述**：

- VisualVM 是一个集成的性能监控和故障处理工具，提供了对 Java 应用程序的实时监控和分析功能。
- 它可以监控 CPU、内存、线程、垃圾回收等信息，并支持生成和分析堆转储、线程转储等。

**特点**：

- 实时监控和分析 Java 应用程序。
- 支持生成和分析堆转储、线程转储。
- 提供插件扩展功能。

**使用方法**：

- VisualVM 通常随 JDK 一起提供，可以在 JDK 的 `bin` 目录下找到 `jvisualvm` 可执行文件。

#### 2. JConsole

**描述**：

- JConsole 是 JDK 提供的一个基于 JMX（Java Management Extensions）的监控工具，用于监控和管理 Java 应用程序。
- 它可以监控内存使用、线程活动、类加载、垃圾回收等信息。

**特点**：

- 基于 JMX，支持远程监控。
- 提供实时监控和管理功能。
- 界面简单直观。

**使用方法**：

- JConsole 通常随 JDK 一起提供，可以在 JDK 的 `bin` 目录下找到 `jconsole` 可执行文件。

#### 3. Java Mission Control (JMC)

**描述**：

- Java Mission Control 是 Oracle 提供的一个高级监控和分析工具，集成了 JFR（Java Flight Recorder）功能。
- 它可以对 Java 应用程序进行低开销的监控和分析，适用于生产环境。

**特点**：

- 集成 JFR，提供低开销的监控和分析。
- 支持生成和分析飞行记录（Flight Recording）。
- 提供详细的性能分析和故障诊断功能。

**使用方法**：

- Java Mission Control 通常随 JDK 一起提供，可以在 JDK 的 `bin` 目录下找到 `jmc` 可执行文件。

#### 4. Eclipse Memory Analyzer (MAT)

**描述**：

- Eclipse Memory Analyzer 是一个强大的堆转储分析工具，用于查找内存泄漏和分析内存使用情况。
- 它可以生成详细的内存报告，帮助开发人员定位内存问题。

**特点**：

- 强大的堆转储分析功能。
- 支持生成详细的内存报告。
- 提供内存泄漏检测和分析功能。

**使用方法**：

- Eclipse Memory Analyzer 可以从 Eclipse 官方网站下载，并作为独立应用程序运行。

#### 5. Grafana + Prometheus

**描述**：

- Grafana 和 Prometheus 是开源的监控和告警工具，常用于监控分布式系统和微服务架构。
- Prometheus 负责数据采集和存储，Grafana 负责数据可视化。

**特点**：

- 强大的数据采集和存储功能。
- 灵活的可视化和告警配置。
- 支持多种数据源和插件扩展。

**使用方法**：

- 需要安装和配置 Prometheus 和 Grafana，可以从各自的官方网站下载并按照文档进行配置。

#### 总结-17

- **VisualVM**：集成的性能监控和故障处理工具，提供实时监控和分析功能。
- **JConsole**：基于 JMX 的监控工具，支持远程监控和管理。
- **Java Mission Control (JMC)**：高级监控和分析工具，集成 JFR 功能，适用于生产环境。
- **Eclipse Memory Analyzer (MAT)**：强大的堆转储分析工具，用于查找内存泄漏和分析内存使用情况。
- **Grafana + Prometheus**：开源的监控和告警工具，常用于监控分布式系统和微服务架构。

通过这些可视化工具，开发人员和运维人员可以更加直观和便捷地监控和诊断 Java 应用程序的性能和故障，确保应用程序的稳定运行。

### 18.JVM 的常见参数配置知道哪些？

JVM 提供了许多参数配置选项，用于调整内存管理、垃圾回收、性能优化等方面。以下是一些常见的 JVM 参数配置：

#### 1. 内存设置参数

- **`-Xms`**：设置 JVM 初始堆内存大小。

  ```sh
  -Xms512m
  ```

- **`-Xmx`**：设置 JVM 最大堆内存大小。

  ```sh
  -Xmx1024m
  ```

- **`-Xmn`**：设置新生代内存大小。

  ```sh
  -Xmn256m
  ```

- **`-XX:PermSize`**：设置永久代初始大小（适用于 JDK 1.8 之前）。

  ```sh
  -XX:PermSize=128m
  ```

- **`-XX:MaxPermSize`**：设置永久代最大大小（适用于 JDK 1.8 之前）。

  ```sh
  -XX:MaxPermSize=256m
  ```

- **`-XX:MetaspaceSize`**：设置元空间初始大小（适用于 JDK 1.8 及之后）。

  ```sh
  -XX:MetaspaceSize=128m
  ```

- **`-XX:MaxMetaspaceSize`**：设置元空间最大大小（适用于 JDK 1.8 及之后）。

  ```sh
  -XX:MaxMetaspaceSize=256m
  ```

#### 2. 垃圾回收参数

- **`-XX:+UseSerialGC`**：使用 Serial 垃圾收集器。

  ```sh
  -XX:+UseSerialGC
  ```

- **`-XX:+UseParallelGC`**：使用 Parallel 垃圾收集器（新生代）。

  ```sh
  -XX:+UseParallelGC
  ```

- **`-XX:+UseParallelOldGC`**：使用 Parallel Old 垃圾收集器（老年代）。

  ```sh
  -XX:+UseParallelOldGC
  ```

- **`-XX:+UseConcMarkSweepGC`**：使用 CMS 垃圾收集器。

  ```sh
  -XX:+UseConcMarkSweepGC
  ```

- **`-XX:+UseG1GC`**：使用 G1 垃圾收集器。

  ```sh
  -XX:+UseG1GC
  ```

- **`-XX:+UseZGC`**：使用 ZGC 垃圾收集器（适用于 JDK 11 及之后）。

  ```sh
  -XX:+UseZGC
  ```

- **`-XX:+UseShenandoahGC`**：使用 Shenandoah 垃圾收集器（适用于 JDK 12 及之后）。

  ```sh
  -XX:+UseShenandoahGC
  ```

#### 3. 性能调优参数

- **`-XX:+AggressiveOpts`**：启用 JVM 的性能优化选项。

  ```sh
  -XX:+AggressiveOpts
  ```

- **`-XX:+UseCompressedOops`**：启用指针压缩（适用于 64 位 JVM）。

  ```sh
  -XX:+UseCompressedOops
  ```

- **`-XX:ParallelGCThreads`**：设置并行垃圾收集器的线程数。

  ```sh
  -XX:ParallelGCThreads=4
  ```

- **`-XX:ConcGCThreads`**：设置 CMS 垃圾收集器的并发线程数。

  ```sh
  -XX:ConcGCThreads=4
  ```

- **`-XX:InitiatingHeapOccupancyPercent`**：设置 G1 垃圾收集器的堆占用触发百分比。

  ```sh
  -XX:InitiatingHeapOccupancyPercent=45
  ```

#### 4. 调试和诊断参数

- **`-XX:+PrintGC`**：打印垃圾回收日志。

  ```sh
  -XX:+PrintGC
  ```

- **`-XX:+PrintGCDetails`**：打印详细的垃圾回收日志。

  ```sh
  -XX:+PrintGCDetails
  ```

- **`-XX:+PrintGCTimeStamps`**：打印垃圾回收时间戳。

  ```sh
  -XX:+PrintGCTimeStamps
  ```

- **`-XX:+PrintHeapAtGC`**：在每次垃圾回收前后打印堆信息。

  ```sh
  -XX:+PrintHeapAtGC
  ```

- **`-Xloggc`**：将垃圾回收日志输出到指定文件。

  ```sh
  -Xloggc:gc.log
  ```

- **`-XX:+HeapDumpOnOutOfMemoryError`**：在发生 `OutOfMemoryError` 时生成堆转储文件。

  ```sh
  -XX:+HeapDumpOnOutOfMemoryError
  ```

- **`-XX:HeapDumpPath`**：指定堆转储文件的路径。

  ```sh
  -XX:HeapDumpPath=/path/to/dump
  ```

以下是一个示例，展示了如何配置 JVM 参数来优化性能和调试垃圾回收：

```sh
java -Xms512m -Xmx1024m -XX:+UseG1GC -XX:InitiatingHeapOccupancyPercent=45 -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -Xloggc:gc.log -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/path/to/dump MyApplication
```

#### 总结-18

- **内存设置参数**：用于配置堆内存、新生代、永久代/元空间的大小。
- **垃圾回收参数**：用于选择和配置不同的垃圾收集器。
- **性能调优参数**：用于启用性能优化选项和配置垃圾收集器的线程数。
- **调试和诊断参数**：用于打印垃圾回收日志、生成堆转储文件等。

通过合理配置 JVM 参数，可以优化 Java 应用程序的性能和稳定性，并在出现问题时进行有效的诊断和调试。

### 19.线上服务 CPU 占用过高怎么排查？

当线上服务出现 CPU 占用过高的问题时，可能会影响系统的性能和响应时间。以下是一些常见的排查步骤和方法：

#### 1. 使用操作系统工具查看 CPU 使用情况

首先，可以使用操作系统提供的工具查看系统的整体 CPU 使用情况和各个进程的 CPU 使用情况。

- **Linux**：
  - `top`：实时显示系统的 CPU 使用情况和各个进程的资源使用情况。
  - `htop`：`top` 的增强版，提供更友好的界面和更多功能。
  - `pidstat`：显示指定进程的 CPU 使用情况。
  - `mpstat`：显示每个 CPU 的使用情况。

  ```sh
  top
  htop
  pidstat -p <pid> 1
  mpstat -P ALL 1
  ```

- **Windows**：
  - 任务管理器：按 `Ctrl + Shift + Esc` 打开任务管理器，查看 CPU 使用情况。
  - 资源监视器：在任务管理器中选择“性能”选项卡，然后点击“打开资源监视器”。

#### 2. 使用 `jps` 和 `jstack` 查看 Java 线程的 CPU 使用情况

使用 `jps` 工具查看正在运行的 Java 进程的 PID，然后使用 `jstack` 工具生成线程堆栈信息。

```sh
jps
jstack <pid> > thread_dump.txt
```

生成的线程堆栈信息可以帮助确定哪些线程占用了大量的 CPU 资源。

#### 3. 使用 `top` 和 `jstack` 结合分析

在 Linux 系统中，可以使用 `top` 命令查看哪个线程占用了大量的 CPU 资源，然后将线程 ID 转换为十六进制格式，并在 `jstack` 输出中查找对应的线程堆栈信息。

```sh
top -H -p <pid>  # 查看指定 Java 进程的线程 CPU 使用情况
```

找到占用 CPU 资源较高的线程 ID（`tid`），将其转换为十六进制格式（`printf "%x\n" <tid>`），然后在 `jstack` 输出中查找对应的线程堆栈信息。

#### 4. 使用 `jstat` 查看垃圾回收情况

使用 `jstat` 工具查看 JVM 的垃圾回收情况，判断是否是频繁的垃圾回收导致了 CPU 占用过高。

```sh
jstat -gc <pid> 1000 10  # 每秒显示一次垃圾回收信息，共显示10次
```

#### 5. 使用 `jmap` 查看内存使用情况

使用 `jmap` 工具查看 JVM 的内存使用情况，判断是否是内存问题导致了 CPU 占用过高。

```sh
jmap -heap <pid>
```

#### 6. 使用 `Java Mission Control` 和 `VisualVM` 进行深入分析

使用 Java Mission Control（JMC）和 VisualVM 等可视化工具进行深入分析，查看 CPU 使用情况、线程活动、垃圾回收等信息。

- **Java Mission Control**：
  - 启动 JMC，连接到目标 JVM，查看 CPU 使用情况、线程活动、垃圾回收等信息。

- **VisualVM**：
  - 启动 VisualVM，连接到目标 JVM，查看 CPU 使用情况、线程活动、垃圾回收等信息。

以下是一个示例，展示了如何使用 `top` 和 `jstack` 结合分析 Java 线程的 CPU 使用情况：

1. 使用 `top` 查看指定 Java 进程的线程 CPU 使用情况：

   ```sh
   top -H -p <pid>
   ```

2. 找到占用 CPU 资源较高的线程 ID（`tid`），将其转换为十六进制格式：

   ```sh
   printf "%x\n" <tid>
   ```

3. 使用 `jstack` 生成线程堆栈信息，并在输出中查找对应的线程堆栈信息：

   ```sh
   jstack <pid> > thread_dump.txt
   ```

#### 总结-19

- **使用操作系统工具查看 CPU 使用情况**：如 `top`、`htop`、`pidstat`、任务管理器等。
- **使用 `jps` 和 `jstack` 查看 Java 线程的 CPU 使用情况**：生成线程堆栈信息，确定占用 CPU 资源的线程。
- **使用 `top` 和 `jstack` 结合分析**：查看线程 CPU 使用情况，并在堆栈信息中查找对应的线程。
- **使用 `jstat` 查看垃圾回收情况**：判断是否是频繁的垃圾回收导致了 CPU 占用过高。
- **使用 `jmap` 查看内存使用情况**：判断是否是内存问题导致了 CPU 占用过高。
- **使用 Java Mission Control 和 VisualVM 进行深入分析**：查看 CPU 使用情况、线程活动、垃圾回收等信息。

通过这些步骤和工具，可以有效地排查和解决线上服务 CPU 占用过高的问题，确保系统的性能和稳定性。

### 20.内存飙高问题怎么排查？

内存飚高一般是因为创建了大量的 Java 对象所导致的，如果持续飙高则说明垃圾回收跟不上对象创建的速度，或者内存泄漏导致对象无法回收。

排查的方法主要分为以下几步：

第一，先观察垃圾回收的情况，可以通过 jstat -gc PID 1000 查看 GC 次数和时间。

或者 jmap -histo PID | head -20 查看堆内存占用空间最大的前 20 个对象类型。

第二步，通过 jmap 命令 dump 出堆内存信息。

第三步，使用可视化工具分析 dump 文件，比如说 VisualVM，找到占用内存高的对象，再找到创建该对象的业务代码位置，从代码和业务场景中定位具体问题。

### 21.频繁 minor gc 怎么办？

频繁的 Minor GC（也称为 Young GC）通常表示新生代中的对象频繁地被垃圾回收，可能是因为新生代空间设置过小，或者是因为程序中存在大量的短生命周期对象（如临时变量、方法调用中创建的对象等）。

可以使用 GC 日志进行分析，查看 GC 的频率和耗时，找到频繁 GC 的原因。

```shell
-XX:+PrintGCDetails -Xloggc:gc.log
```

或者使用监控工具（如 VisualVM、jstat、jconsole 等）查看堆内存的使用情况，特别是新生代（Eden 和 Survivor 区）的使用情况。

如果是因为新生代空间不足，可以通过 -Xmn 增加新生代的大小，减少新生代的填满速度。

```shell
java -Xmn256m your-app.jar
```

如果对象未能在 Survivor 区足够长时间存活，就会被晋升到老年代，可以通过 -XX:SurvivorRatio 参数调整 Eden 和 Survivor 的比例。默认比例是 8:1，表示 8 个空间用于 Eden，1 个空间用于 Survivor 区。

```shell
-XX:SurvivorRatio=6
```

这将减少 Eden 区的大小，增加 Survivor 区的大小，以确保对象在 Survivor 区中存活的时间足够长，避免过早晋升到老年代。

### 22.频繁 Full GC 怎么办？

Full GC 是指对整个堆内存（包括新生代和老年代）进行垃圾回收操作。Full GC 频繁会导致应用程序的暂停时间增加，从而影响性能。

常见的原因有：

- 大对象（如大数组、大集合）直接分配到老年代，导致老年代空间快速被占用。
- 程序中存在内存泄漏，导致老年代的内存不断增加，无法被回收。比如 IO 资源未关闭。
- 一些长生命周期的对象进入到了老年代，导致老年代空间不足。
- 不合理的 GC 参数配置也导致 GC 频率过高。比如说新生代的空间设置过小。

#### 该怎么排查 Full GC 频繁问题？

假如是因为大对象直接分配到老年代导致的 Full GC 频繁，可以通过` -XX:PretenureSizeThreshold `参数设置大对象直接进入老年代的阈值。

或者能不能将大对象拆分成小对象，减少大对象的创建。比如说分页。

假如是因为内存泄漏导致的 Full GC 频繁，可以通过分析堆内存 dump 文件找到内存泄漏的对象，再找到内存泄漏的代码位置。

假如是因为长生命周期的对象进入到了老年代，要及时释放资源，比如说 ThreadLocal、数据库连接、IO 资源等。

假如是因为 GC 参数配置不合理导致的 Full GC 频繁，可以通过调整 GC 参数来优化 GC 行为。或者直接更换更适合的 GC 收集器，如 G1、ZGC 等。

### 23.有没有处理过内存泄漏问题？是如何定位的？

内存泄漏是指程序在运行过程中由于未能正确释放已分配的内存，导致内存无法被重用，从而引发内存耗尽等问题。

常用的可视化监控工具有 JConsole、VisualVM、JProfiler、Eclipse Memory Analyzer (MAT)等。

也可以使用 JDK 自带的 jmap、jstack、jstat 等命令行工具来配合内存泄露问题的排查。

**严重的内存泄漏往往伴随频繁的 Full GC，所以排查内存泄漏问题时，可以从 Full GC 入手**。

第一步，使用` jps -l `查看运行的 Java 进程 ID。

第二步，使用`top -p [pid]`查看进程使用 CPU 和内存占用情况。

第三步，使用` top -Hp [pid] `查看进程下的所有线程占用 CPU 和内存情况。

第四步，抓取线程栈：`jstack -F 29452 > 29452.txt`，可以多抓几次做个对比。

29452 为 pid，顺带作为文件名

看看有没有线程死锁、死循环或长时间等待这些问题。

第五步，可以使用`jstat -gcutil [pid] 5000 10`每隔 5 秒输出 GC 信息，输出 10 次，查看 YGC 和 Full GC 次数。

通常会出现 YGC 不增加或增加缓慢，而 Full GC 增加很快。

或使用` jstat -gccause [pid] 5000 `输出 GC 摘要信息。

或使用` jmap -heap [pid] `查看堆的摘要信息，关注老年代内存使用是否达到阀值，若达到阀值就会执行 Full GC。

如果发现 Full GC 次数太多，就很大概率存在内存泄漏了。

第六步，生成 dump 文件，然后借助可视化工具分析哪个对象非常多，基本就能定位到问题根源了。

执行命令` jmap -dump:format=b,file=heap.hprof 10025 `会输出进程 10025 的堆快照信息，保存到文件 heap.hprof 中。

第七步，可以使用图形化工具分析，如 JDK 自带的 VisualVM，从菜单 > 文件 > 装入 dump 文件。

然后在结果观察内存占用最多的对象，找到内存泄漏的源头。

### 24.有没有处理过 OOM 问题？

OOM，也就是内存溢出，Out of Memory，是指当程序请求分配内存时，由于没有足够的内存空间满足其需求，从而触发的错误。

当发生 OOM 时，可以导出堆转储（Heap Dump）文件进行分析。如果 JVM 还在运行，可以使用 jmap 命令手动生成 Heap Dump 文件：

```java
jmap -dump:format=b,file=heap.hprof <pid>
```

生成 Heap Dump 文件后，可以使用 MAT、JProfiler 等工具进行分析，查看内存中的对象占用情况，找到内存泄漏的原因。

如果生产环境的内存还有很多空余，可以适当增大堆内存大小，例如 -Xmx4g 参数。

或者检查代码中是否存在内存泄漏，如未关闭的资源、长生命周期的对象等。

之后，在本地进行压力测试，模拟高负载情况下的内存表现，确保修改有效，且没有引入新的问题。

### 25.了解类的加载机制吗？

JVM 的操作对象是 Class 文件，JVM 把 Class 文件中描述类的数据结构加载到内存中，并对数据进行校验、解析和初始化，最终形成可以被 JVM 直接使用的类型，这个过程被称为类加载机制。

其中最重要的三个概念就是：类加载器、类加载过程和类加载器的双亲委派模型。

- **类加载器**：负责加载类文件，将类文件加载到内存中，生成 Class 对象。
- **类加载过程**：加载、验证、准备、解析和初始化。
- **双亲委派模型**：当一个类加载器收到类加载请求时，它首先不会自己去尝试加载这个类，而是把请求委派给父类加载器去完成，依次递归，直到最顶层的类加载器，如果父类加载器无法完成加载请求，子类加载器才会尝试自己去加载。

### 26.类加载器有哪些？

Java 中的类加载器（ClassLoader）负责将类文件加载到 JVM 中，并生成对应的 Class 对象。类加载器主要分为以下几种：

#### 1. 启动类加载器（Bootstrap ClassLoader）

- **描述**：启动类加载器是 JVM 自带的类加载器，用于加载核心类库。
- **加载范围**：负责加载 `JAVA_HOME/lib` 目录下的核心类库，如 `rt.jar`。
- **实现**：启动类加载器是用本地代码实现的，并不是一个 Java 类。

#### 2. 扩展类加载器（Extension ClassLoader）

- **描述**：扩展类加载器是由 `sun.misc.Launcher$ExtClassLoader` 实现的，用于加载扩展类库。
- **加载范围**：负责加载 `JAVA_HOME/lib/ext` 目录下的类库，或者通过 `java.ext.dirs` 系统属性指定的类库。
- **实现**：扩展类加载器是一个 Java 类，继承自 `ClassLoader`。

#### 3. 应用程序类加载器（Application ClassLoader）

- **描述**：应用程序类加载器是由 `sun.misc.Launcher$AppClassLoader` 实现的，用于加载应用程序的类路径（classpath）下的类。
- **加载范围**：负责加载用户类路径（classpath）下的类库。
- **实现**：应用程序类加载器是一个 Java 类，继承自 `ClassLoader`。

#### 4. 自定义类加载器（Custom ClassLoader）

- **描述**：用户可以通过继承 `ClassLoader` 类来创建自定义类加载器，以实现特殊的类加载需求。
- **加载范围**：由用户定义，可以加载特定路径或特定来源的类库。这种类加载器通常用于加载网络上的类、执行热部署（动态加载和替换应用程序的组件）或为了安全目的自定义类的加载方式。
- **实现**：自定义类加载器需要继承 `ClassLoader` 类，并重写 `findClass` 方法。

#### 总结-26

- **启动类加载器（Bootstrap ClassLoader）**：加载核心类库，如 `rt.jar`。
- **扩展类加载器（Extension ClassLoader）**：加载扩展类库，如 `JAVA_HOME/lib/ext` 目录下的类库。
- **应用程序类加载器（Application ClassLoader）**：加载用户类路径（classpath）下的类库。
- **自定义类加载器（Custom ClassLoader）**：用户可以通过继承 `ClassLoader` 类来创建自定义类加载器，以实现特殊的类加载需求。

### 27.能说一下类的生命周期吗？

Java 类的生命周期包括以下几个阶段：加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）和卸载（Unloading）。每个阶段都有特定的任务和作用。

#### 1. 加载（Loading）

**加载**是指将类的字节码从不同的来源（如文件系统、网络等）加载到内存中，并创建一个 Class 对象来表示这个类。

- **类加载器（ClassLoader）**：负责加载类的字节码。Java 提供了几种默认的类加载器，如启动类加载器、扩展类加载器和应用程序类加载器。

#### 2. 验证（Verification）

**验证**是指确保类的字节码符合 JVM 规范，保证代码的安全性和正确性。

- **字节码验证**：检查字节码的格式和结构是否正确。
- **符号引用验证**：检查符号引用是否能被正确解析。
- **数据类型验证**：检查数据类型是否匹配。

#### 3. 准备（Preparation）

**准备**是指为类的静态变量分配内存，并将其初始化为默认值。

- **静态变量初始化**：将静态变量初始化为默认值（如 `0`、`null` 等）。

#### 4. 解析（Resolution）

**解析**是指将类的符号引用转换为直接引用。

- **符号引用**：在类的字节码中使用的符号名称。
- **直接引用**：在内存中指向实际对象的引用。

#### 5. 初始化（Initialization）

**初始化**是指对类的静态变量赋予正确的初始值，并执行类的静态代码块。

- **静态变量赋值**：将静态变量赋予正确的初始值。
- **静态代码块执行**：执行类中的静态代码块。

#### 6. 使用（Using）

**使用**是指类在程序中被实际使用的阶段。

- **实例化对象**：创建类的实例对象。
- **调用方法**：调用类的方法。

#### 7. 卸载（Unloading）

**卸载**是指类在 JVM 中被卸载，释放其占用的内存。

- **类卸载条件**：类的所有实例都被回收，且没有任何对该类的引用。
- **类卸载过程**：JVM 的垃圾回收器负责类的卸载。

以下是一个简单的类生命周期示例：

```java
public class Test {
    static {
        System.out.println("Static block executed");
    }

    public static int value = 42;

    public static void main(String[] args) {
        System.out.println("Value: " + Test.value);
    }
}
```

在这个示例中，类的生命周期如下：

1. **加载**：ClassLoader加载 `Test` 类的字节码，并创建一个 Class 对象。
2. **验证**：验证 `Test` 类的字节码是否符合 JVM 规范。
3. **准备**：为 `Test` 类的静态变量 `value` 分配内存，并将其初始化为默认值 `0`。
4. **解析**：将 `Test` 类的符号引用转换为直接引用。
5. **初始化**：
   - **静态变量赋值**：将静态变量 `value` 赋值为 `42`。
   - **静态代码块执行**：执行静态代码块，输出 "Static block executed"。
6. **使用**：在 `main` 方法中使用 `Test` 类，输出 "Value: 42"。
7. **卸载**：当 `Test` 类的所有实例都被回收，且没有任何对该类的引用时，JVM 的垃圾回收器会卸载 `Test` 类。

#### 总结-27

- **加载（Loading）**：将类的字节码加载到内存中，并创建 Class 对象。
- **验证（Verification）**：确保类的字节码符合 JVM 规范，保证代码的安全性和正确性。
- **准备（Preparation）**：为类的静态变量分配内存，并将其初始化为默认值。
- **解析（Resolution）**：将类的符号引用转换为直接引用。
- **初始化（Initialization）**：对类的静态变量赋予正确的初始值，并执行静态代码块。
- **使用（Using）**：类在程序中被实际使用的阶段。
- **卸载（Unloading）**：类在 JVM 中被卸载，释放其占用的内存。

### 28.什么是双亲委派模型？

双亲委派模型（Parent Delegation Model）是 Java 类加载机制中的一个重要概念。这种模型指的是一个类加载器在尝试加载某个类时，首先会将加载任务委托给其父类加载器去完成。

只有当父类加载器无法完成这个加载请求（即它找不到指定的类）时，子类加载器才会尝试自己去加载这个类。

- 当一个类加载器需要加载某个类时，它首先会请求其父类加载器加载这个类。
- 这个过程会一直向上递归，也就是说，从子加载器到父加载器，再到更上层的加载器，一直到最顶层的启动类加载器（Bootstrap ClassLoader）。
- 启动类加载器会尝试加载这个类。如果它能够加载这个类，就直接返回；如果它不能加载这个类（因为这个类不在它的搜索范围内），就会将加载任务返回给委托它的子加载器。
- 子加载器接着尝试加载这个类。如果子加载器也无法加载这个类，它就会继续向下传递这个加载任务，依此类推。
- 这个过程会继续，直到某个加载器能够加载这个类，或者所有加载器都无法加载这个类，最终抛出 ClassNotFoundException。

### 29.为什么要用双亲委派模型？

可以为 Java 应用程序的运行提供一致性和安全性的保障。

①、保证 Java 核心类库的类型安全

如果自定义类加载器优先加载一个类，比如说自定义的 Object，那在 Java 运行时环境中就存在多个版本的 java.lang.Object，双亲委派模型确保了 Java 核心类库的类加载工作由启动类加载器统一完成，从而保证了 Java 应用程序都是使用的同一份核心类库。

②、避免类的重复加载

在双亲委派模型中，类加载器会先委托给父加载器尝试加载类，这样同一个类不会被加载多次。如果没有这种模型，可能会导致同一个类被不同的类加载器重复加载到内存中，造成浪费和冲突。

### 30.如何破坏双亲委派机制？

在某些情况下，可能需要破坏双亲委派机制来实现特定的功能，例如加载不同版本的类或实现插件系统。破坏双亲委派机制的常见方法是自定义类加载器，并重写 `loadClass` 方法，使其不再委托给父类加载器。

#### 示例：自定义类加载器

以下是一个自定义类加载器的示例，通过重写 `loadClass` 方法来破坏双亲委派机制：

```java
public class CustomClassLoader extends ClassLoader {
    @Override
    public Class<?> loadClass(String name) throws ClassNotFoundException {
        // 如果类名以 "java." 开头，仍然使用父类加载器加载
        if (name.startsWith("java.")) {
            return super.loadClass(name);
        }

        // 尝试查找已经加载的类
        Class<?> loadedClass = findLoadedClass(name);
        if (loadedClass != null) {
            return loadedClass;
        }

        try {
            // 自定义加载类的逻辑，例如从文件系统或网络加载类的字节码
            byte[] classData = loadClassData(name);
            if (classData != null) {
                return defineClass(name, classData, 0, classData.length);
            }
        } catch (Exception e) {
            e.printStackTrace();
        }

        // 如果自定义加载失败，仍然使用父类加载器加载
        return super.loadClass(name);
    }

    private byte[] loadClassData(String name) {
        // 自定义类加载逻辑，例如从文件系统或网络加载类的字节码
        // 这里仅作为示例，实际实现需要根据需求编写
        return null;
    }

    public static void main(String[] args) throws ClassNotFoundException {
        CustomClassLoader customClassLoader = new CustomClassLoader();
        Class<?> clazz = customClassLoader.loadClass("Test");
        System.out.println("Class loaded: " + clazz.getName());
    }
}
```

#### 解释

1. **重写 `loadClass` 方法**：在自定义类加载器中重写 `loadClass` 方法，控制类加载的逻辑。
2. **条件判断**：如果类名以 "java." 开头，仍然使用父类加载器加载，以确保核心类库的安全性。
3. **查找已加载的类**：首先尝试查找已经加载的类，避免重复加载。
4. **自定义加载逻辑**：实现自定义的类加载逻辑，例如从文件系统或网络加载类的字节码。
5. **定义类**：使用 `defineClass` 方法将字节码转换为 Class 对象。
6. **回退机制**：如果自定义加载失败，仍然使用父类加载器加载。

#### 总结-30

通过自定义类加载器并重写 `loadClass` 方法，可以破坏双亲委派机制，实现特定的类加载需求。然而，破坏双亲委派机制可能会带来类型安全性和类冲突等问题，因此在实际应用中应谨慎使用。

### 31.Tomcat 的类加载机制了解吗？

Tomcat 是一个流行的 Java Servlet 容器，它的类加载机制在标准的 Java 类加载机制基础上进行了扩展，以支持多应用程序的隔离和热部署。Tomcat 的类加载机制主要包括以下几个类加载器：

#### 1. 启动类加载器（Bootstrap  ClassLoader）

- **描述**：负责加载 JDK 核心类库（如 `rt.jar`）。
- **加载范围**：`$JAVA_HOME/lib` 目录下的类库。

#### 2. 系统类加载器（System ClassLoader）

- **描述**：负责加载 Tomcat 自身的类库。
- **加载范围**：`$CATALINA_HOME/lib` 目录下的类库。

#### 3. 公共类加载器（Common ClassLoader）

- **描述**：负责加载所有 Web 应用程序共享的类库。
- **加载范围**：`$CATALINA_HOME/lib` 目录下的类库。

#### 4. Web 应用程序类加载器（WebappClassLoader）

- **描述**：负责加载特定 Web 应用程序的类库。
- **加载范围**：`WEB-INF/classes` 和 `WEB-INF/lib` 目录下的类库。

#### 5. 自定义类加载器（Custom ClassLoader）

- **描述**：用户可以通过配置自定义类加载器，以实现特定的类加载需求。

#### 类加载器的层次结构

Tomcat 的类加载器层次结构如下：

1. **启动类加载器（Bootstrap ClassLoader）**
2. **系统类加载器（System ClassLoader）**
3. **公共类加载器（Common ClassLoader）**
4. **Web 应用程序类加载器（WebappClassLoader）**

#### 类加载顺序

1. **启动类加载器**：首先由启动类加载器加载 JDK 核心类库。
2. **系统类加载器**：然后由系统类加载器加载 Tomcat 自身的类库。
3. **公共类加载器**：接着由公共类加载器加载所有 Web 应用程序共享的类库。
4. **Web 应用程序类加载器**：最后由 Web 应用程序类加载器加载特定 Web 应用程序的类库。

Tomcat 实际上也是破坏了双亲委派模型的。

Tomact 是 web 容器，可能需要部署多个应用程序。不同的应用程序可能会依赖同一个第三方类库的不同版本，但是不同版本的类库中某一个类的全路径名可能是一样的。如多个应用都要依赖 hollis.jar，但是 A 应用需要依赖 1.0.0 版本，但是 B 应用需要依赖 1.0.1 版本。这两个版本中都有一个类是 com.hollis.Test.class。如果采用默认的双亲委派类加载机制，那么无法加载多个相同的类。

所以，Tomcat 破坏了双亲委派原则，提供隔离的机制，为每个 web 容器单独提供一个 WebAppClassLoader 加载器。每一个 WebAppClassLoader 负责加载本身的目录下的 class 文件，加载不到时再交 CommonClassLoader 加载，这和双亲委派刚好相反。

### 32.你觉得应该怎么实现一个热部署功能？

实现热部署功能通常涉及以下几个步骤：

1. **监控文件变化**：监控应用程序的文件系统，检测到文件变化时触发相应的操作。
2. **卸载旧类**：卸载旧的类和资源，释放内存。
3. **加载新类**：加载新的类和资源，替换旧的类。
4. **重启应用**：在不重启整个服务器的情况下，重启应用程序。

#### 1. 监控文件变化

可以使用 Java 的 `WatchService` API 来监控文件系统的变化。

```java
import java.nio.file.*;

public class FileWatcher implements Runnable {
    private final Path path;

    public FileWatcher(Path path) {
        this.path = path;
    }

    @Override
    public void run() {
        try (WatchService watchService = FileSystems.getDefault().newWatchService()) {
            path.register(watchService, StandardWatchEventKinds.ENTRY_MODIFY);

            while (true) {
                WatchKey key = watchService.take();
                for (WatchEvent<?> event : key.pollEvents()) {
                    if (event.kind() == StandardWatchEventKinds.ENTRY_MODIFY) {
                        System.out.println("File modified: " + event.context());
                        // 触发热部署操作
                        reloadApplication();
                    }
                }
                key.reset();
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    private void reloadApplication() {
        // 实现热部署逻辑
    }

    public static void main(String[] args) {
        Path path = Paths.get("/path/to/your/application");
        FileWatcher fileWatcher = new FileWatcher(path);
        new Thread(fileWatcher).start();
    }
}
```

#### 2. 卸载旧类

使用自定义类加载器来加载和卸载类。可以通过将类加载器设置为 `null` 并调用垃圾回收器来卸载旧的类。

```java
public class CustomClassLoader extends ClassLoader {
    // 自定义类加载逻辑
}

public class ApplicationReloader {
    private CustomClassLoader classLoader;

    public void reload() {
        // 卸载旧类
        if (classLoader != null) {
            classLoader = null;
            System.gc();
        }

        // 加载新类
        classLoader = new CustomClassLoader();
        // 重新初始化应用程序
        initializeApplication();
    }

    private void initializeApplication() {
        // 初始化应用程序逻辑
    }
}
```

#### 3. 加载新类

使用自定义类加载器加载新的类和资源。

```java
public class CustomClassLoader extends ClassLoader {
    @Override
    public Class<?> loadClass(String name) throws ClassNotFoundException {
        // 自定义加载类的逻辑
        return super.loadClass(name);
    }
}
```

#### 4. 重启应用

在不重启整个服务器的情况下，重启应用程序。

```java
public class ApplicationReloader {
    private CustomClassLoader classLoader;

    public void reload() {
        // 卸载旧类
        if (classLoader != null) {
            classLoader = null;
            System.gc();
        }

        // 加载新类
        classLoader = new CustomClassLoader();
        // 重新初始化应用程序
        initializeApplication();
    }

    private void initializeApplication() {
        // 初始化应用程序逻辑
    }
}
```

#### 总结-32

1. **监控文件变化**：使用 `WatchService` API 监控文件系统的变化。
2. **卸载旧类**：使用自定义类加载器并通过垃圾回收器卸载旧的类。
3. **加载新类**：使用自定义类加载器加载新的类和资源。
4. **重启应用**：在不重启整个服务器的情况下，重启应用程序。

通过这些步骤，可以实现一个基本的热部署功能。需要注意的是，热部署可能会带来一些复杂性和潜在的问题，如类冲突和内存泄漏等，因此在实际应用中应谨慎使用。

### 33.解释执行和编译执行的区别?

解释执行和编译执行是两种不同的程序执行方式，它们在执行流程、性能和适用场景等方面存在显著差异。

#### 解释执行

**解释执行**是指程序在运行时由解释器逐行读取源代码，并将其转换为机器码执行。

- **执行流程**：
  1. **逐行读取**：解释器逐行读取源代码。
  2. **逐行翻译**：每读取一行代码，立即将其翻译为机器码并执行。
  3. **即时执行**：翻译后的机器码立即执行，不生成独立的可执行文件。

- **优点**：
  - **跨平台**：源代码可以在不同平台上运行，只需提供相应平台的解释器。
  - **调试方便**：可以逐行执行代码，便于调试和测试。

- **缺点**：
  - **性能较低**：每次执行都需要重新翻译代码，执行速度较慢。
  - **依赖解释器**：需要解释器的支持，不能生成独立的可执行文件。

- **适用场景**：
  - **脚本语言**：如 Python、JavaScript、Ruby 等。
  - **开发和调试**：需要频繁修改和测试代码的场景。

#### 编译执行

**编译执行**是指程序在运行前由编译器将源代码一次性翻译为机器码，生成独立的可执行文件，然后由操作系统加载执行。

- **执行流程**：
  1. **编译**：编译器将源代码一次性翻译为机器码，生成可执行文件。
  2. **链接**：将生成的机器码与库文件链接，生成最终的可执行文件。
  3. **执行**：操作系统加载并执行生成的可执行文件。

- **优点**：
  - **性能较高**：编译后的机器码直接执行，执行速度较快。
  - **独立性强**：生成独立的可执行文件，不依赖编译器或解释器。

- **缺点**：
  - **跨平台性差**：编译后的可执行文件只能在特定平台上运行。
  - **调试不便**：需要重新编译整个程序，调试和测试较为繁琐。

- **适用场景**：
  - **系统编程**：如 C、C++ 等语言，用于开发操作系统、驱动程序等。
  - **性能要求高**：需要高性能执行的场景，如游戏开发、科学计算等。

#### Java 的混合模式

Java 采用了一种混合模式，结合了解释执行和编译执行的优点。

- **解释执行**：Java 源代码首先被编译为字节码（`.class` 文件），由 JVM 的解释器逐行解释执行。
- **即时编译（JIT）**：JVM 在运行时将热点代码（执行频繁的代码）编译为机器码，提高执行效率。

#### 总结-33

- **解释执行**：
  - **逐行读取和翻译**：逐行读取源代码并翻译为机器码执行。
  - **优点**：跨平台、调试方便。
  - **缺点**：性能较低、依赖解释器。
  - **适用场景**：脚本语言、开发和调试。

- **编译执行**：
  - **一次性翻译**：将源代码一次性翻译为机器码，生成可执行文件。
  - **优点**：性能较高、独立性强。
  - **缺点**：跨平台性差、调试不便。
  - **适用场景**：系统编程、性能要求高的场景。

- **Java 的混合模式**：结合了解释执行和编译执行的优点，通过解释执行和即时编译（JIT）提高执行效率。

通过理解解释执行和编译执行的区别，可以更好地选择适合的编程语言和执行方式，优化程序性能和开发效率。

## Spring

### 1.Spring是什么？

Spring 是一个轻量级、非入侵式的控制反转 (IoC) 和面向切面 (AOP) 的框架。

到了现在，企业级开发的标配基本就是 Spring5 + Spring Boot 2 + JDK 8

#### Spring的特性

IoC 和 DI 的支持
Spring 的核心就是一个大的工厂容器，可以维护所有对象的创建和依赖关系，Spring 工厂用于生成 Bean，并且管理 Bean 的生命周期，实现高内聚低耦合的设计理念。

AOP 编程的支持
Spring 提供了面向切面编程，可以方便的实现对程序进行权限拦截、运行监控等切面功能。

声明式事务的支持
支持通过配置就来完成对事务的管理，而不需要通过硬编码的方式，以前重复的一些事务提交、回滚的 JDBC 代码，都可以不用自己写了。

快捷测试的支持
Spring 对 Junit 提供支持，可以通过注解快捷地测试 Spring 程序。

快速集成功能
方便集成各种优秀框架，Spring 不排斥各种优秀的开源框架，其内部提供了对各种优秀框架（如：Struts、Hibernate、MyBatis、Quartz 等）的直接支持。

复杂 API 模板封装
Spring 对 JavaEE 开发中非常难用的一些 API（JDBC、JavaMail、远程调用等）都提供了模板化的封装，这些封装 API 的提供使得应用难度大大降低。

### 2.Spring的模块

Spring 框架是一个庞大的生态系统，包含多个模块，每个模块都提供了特定的功能，以满足不同的开发需求。以下是 Spring 框架的主要模块：

#### 1. 核心容器（Core Container）

- **Spring Core**：提供框架的基本功能，包括依赖注入（DI）和控制反转（IoC）。
- **Spring Beans**：提供 Bean 的创建、配置和管理功能。
- **Spring Context**：提供框架的上下文信息，扩展了 BeanFactory，支持国际化、事件传播等功能。
- **Spring Expression Language (SpEL)**：提供强大的表达式语言，用于在运行时查询和操作对象图。

#### 2. 数据访问/集成（Data Access/Integration）

- **Spring JDBC**：简化了 JDBC 操作，提供了模板类来减少冗余代码。
- **Spring ORM**：支持集成 ORM 框架，如 Hibernate、JPA、MyBatis 等。
- **Spring OXM**：提供了对象/XML 映射的支持。
- **Spring JMS**：简化了 JMS（Java Message Service）的使用。
- **Spring Transaction**：提供声明式事务管理，简化了事务处理。

#### 3. Web 模块（Web）

- **Spring Web**：提供了基础的 Web 开发功能，包括多部分文件上传、初始化参数等。
- **Spring WebMVC**：基于模型-视图-控制器（MVC）设计模式的 Web 框架，用于构建 Web 应用程序。
- **Spring WebSocket**：提供了 WebSocket 的支持，用于构建实时通信应用。
- **Spring WebFlux**：提供了响应式编程模型，用于构建非阻塞的 Web 应用程序。

#### 4. 面向切面编程（Aspect-Oriented Programming, AOP）

- **Spring AOP**：提供了面向切面编程的支持，可以实现横切关注点（如日志记录、事务管理等）的分离。
- **Spring Aspects**：提供了与 AspectJ 的集成，增强了 AOP 的功能。

#### 5. 消息（Messaging）

- **Spring Messaging**：提供了消息传递的支持，简化了消息驱动的应用程序开发。

#### 6. 测试（Test）

- **Spring Test**：提供了对 JUnit 和 TestNG 的支持，简化了 Spring 应用程序的测试。

#### 7. 安全（Security）

- **Spring Security**：提供了强大的认证和授权功能，保护应用程序的安全。

#### 8. 云（Cloud）

- **Spring Cloud**：提供了构建分布式系统的工具和服务，如配置管理、服务发现、断路器等。

#### 9. 批处理（Batch）

- **Spring Batch**：提供了批处理应用程序的支持，简化了大规模数据处理任务的开发。

#### 10. 数据流（Data Flow）

- **Spring Data Flow**：提供了数据流处理的支持，简化了数据流应用程序的开发和管理。

#### 总结-1

Spring 框架包含多个模块，每个模块都提供了特定的功能，以满足不同的开发需求。以下是主要模块：

- **核心容器（Core Container）**：Spring Core、Spring Beans、Spring Context、SpEL。
- **数据访问/集成（Data Access/Integration）**：Spring JDBC、Spring ORM、Spring OXM、Spring JMS、Spring Transaction。
- **Web 模块（Web）**：Spring Web、Spring WebMVC、Spring WebSocket、Spring WebFlux。
- **面向切面编程（AOP）**：Spring AOP、Spring Aspects。
- **消息（Messaging）**：Spring Messaging。
- **测试（Test）**：Spring Test。
- **安全（Security）**：Spring Security。
- **云（Cloud）**：Spring Cloud。
- **批处理（Batch）**：Spring Batch。
- **数据流（Data Flow）**：Spring Data Flow。

通过理解 Spring 框架的各个模块，可以更好地利用其提供的功能，构建高效、可扩展的企业级应用程序。

### 3.Spring有哪些常用注解？

Web 开发方面有哪些注解呢？

①、@Controller：用于标注控制层组件。

②、@RestController：是@Controller 和 @ResponseBody 的结合体，返回 JSON 数据时使用。

③、@RequestMapping：用于映射请求 URL 到具体的方法上，还可以细分为：

- @GetMapping：只能用于处理 GET 请求
- @PostMapping：只能用于处理 POST 请求
- @DeleteMapping：只能用于处理 DELETE 请求

④、@ResponseBody：直接将返回的数据放入 HTTP 响应正文中，一般用于返回 JSON 数据。

⑤、@RequestBody：表示一个方法参数应该绑定到 Web 请求体。

⑥、@PathVariable：用于接收路径参数，比如 @RequestMapping(“/hello/{name}”)，这里的 name 就是路径参数。

⑦、@RequestParam：用于接收请求参数。比如 @RequestParam(name = "key") String key，这里的 key 就是请求参数。

容器类注解有哪些呢？

@Component：标识一个类为 Spring 组件，使其能够被 Spring 容器自动扫描和管理。

@Service：标识一个业务逻辑组件（服务层）。比如@Service("userService")，这里的 userService 就是 Bean 的名称。

@Repository：标识一个数据访问组件（持久层）。

@Autowired：按类型自动注入依赖。

@Configuration：用于定义配置类，可替换 XML 配置文件。

@Value：用于将 Spring Boot 中 application.properties 配置的属性值赋值给变量。

AOP 方面有哪些注解呢？

@Aspect 用于声明一个切面，可以配合其他注解一起使用，比如：

@After：在方法执行之后执行。

@Before：在方法执行之前执行。

@Around：方法前后均执行。

@PointCut：定义切点，指定需要拦截的方法。

事务注解有哪些？

主要就是 @Transactional，用于声明一个方法需要事务支持。

### 4.Spring 中应用了哪些设计模式呢？

①、工厂模式：IoC 容器本身可以看作是一个巨大的工厂，负责创建和管理 Bean 的生命周期和依赖关系。

像 BeanFactory 和 ApplicationContext 接口都提供了工厂模式的实现，负责实例化、配置和组装 Bean。

②、代理模式：AOP 的实现就是基于代理模式的，如果配置了事务管理，Spring 会使用代理模式创建一个连接数据库的代理对象，来进行事务管理。

③、单例模式：Spring 容器中的 Bean 默认都是单例的，这样可以保证 Bean 的唯一性，减少系统开销。

④、模板模式：Spring 中的 JdbcTemplate，HibernateTemplate 等以 Template 结尾的类，都使用了模板方法模式。

比如，我们使用 JdbcTemplate，只需要提供 SQL 语句和需要的参数就可以了，至于如何创建连接、执行 SQL、处理结果集等都由 JdbcTemplate 这个模板方法来完成。

④、观察者模式：Spring 事件驱动模型就是观察者模式很经典的一个应用，Spring 中的 ApplicationListener 就是观察者，当有事件（ApplicationEvent）被发布，ApplicationListener 就能接收到信息。

⑤、适配器模式：Spring MVC 中的 HandlerAdapter 就用了适配器模式。它允许 DispatcherServlet 通过统一的适配器接口与多种类型的请求处理器进行交互。

⑥、策略模式：Spring 中有一个 Resource 接口，它的不同实现类，会根据不同的策略去访问资源。

### 5.spring的容器、web容器、springmvc的容器之间的区别？

Spring 容器、Web 容器和 Spring MVC 容器是 Java 开发中常见的三种容器，它们在功能和用途上有所不同。以下是它们的区别和各自的特点：

#### 1. Spring 容器

**描述**：Spring 容器是 Spring 框架的核心部分，负责管理应用程序中的 Bean 的生命周期和依赖关系。

**主要功能**：

- **依赖注入（DI）**：通过配置文件或注解，将对象的依赖关系注入到对象中。
- **Bean 生命周期管理**：管理 Bean 的创建、初始化、销毁等生命周期。
- **AOP 支持**：提供面向切面编程的支持，允许在运行时动态地为对象添加行为。

**常见实现**：

- **BeanFactory**：最基本的容器，提供基本的 DI 功能。
- **ApplicationContext**：扩展了 BeanFactory，提供更多的企业级功能，如事件传播、国际化、应用上下文等。

**示例**：

```java
ApplicationContext context = new ClassPathXmlApplicationContext("applicationContext.xml");
MyBean myBean = context.getBean(MyBean.class);
```

#### 2. Web 容器

**描述**：Web 容器（也称为 Servlet 容器）是用于管理和执行 Java Web 应用程序的容器，负责处理 HTTP 请求和响应。

**主要功能**：

- **Servlet 管理**：加载、初始化、执行和销毁 Servlet。
- **会话管理**：管理用户会话，跟踪用户状态。
- **安全管理**：提供认证和授权机制，保护 Web 应用程序的安全。
- **请求调度**：将 HTTP 请求分发到相应的 Servlet 进行处理。

**常见实现**：

- **Apache Tomcat**：一个流行的开源 Web 容器。
- **Jetty**：一个轻量级的 Web 容器，适用于嵌入式应用。
- **WildFly（原 JBoss）**：一个功能强大的企业级应用服务器。

**示例**：

```xml
<servlet>
    <servlet-name>example</servlet-name>
    <servlet-class>com.example.ExampleServlet</servlet-class>
</servlet>
<servlet-mapping>
    <servlet-name>example</servlet-name>
    <url-pattern>/example</url-pattern>
</servlet-mapping>
```

#### 3. Spring MVC 容器

**描述**：Spring MVC 容器是 Spring 框架的一部分，专门用于处理 Web 请求和响应，基于模型-视图-控制器（MVC）设计模式。

**主要功能**：

- **请求映射**：将 HTTP 请求映射到控制器方法。
- **数据绑定**：将请求参数绑定到方法参数或模型对象。
- **视图解析**：将控制器返回的模型数据渲染到视图（如 JSP、Thymeleaf）。
- **表单处理**：处理表单提交和验证。

**常见组件**：

- **DispatcherServlet**：前端控制器，负责将请求分发到相应的处理器。
- **Controller**：处理请求并返回模型数据和视图名称。
- **ViewResolver**：解析视图名称并渲染视图。

**示例**：

```java
@Controller
@RequestMapping("/users")
public class UserController {
    @GetMapping("/{id}")
    public String getUser(@PathVariable Long id, Model model) {
        User user = userService.findById(id);
        model.addAttribute("user", user);
        return "user";
    }
}
```

#### 总结-5

- **Spring 容器**：
  - **功能**：管理 Bean 的生命周期和依赖关系，提供 AOP 支持。
  - **实现**：BeanFactory、ApplicationContext。
  - **用途**：用于管理应用程序中的对象和依赖关系。

- **Web 容器**：
  - **功能**：管理和执行 Java Web 应用程序，处理 HTTP 请求和响应。
  - **实现**：Apache Tomcat、Jetty、WildFly。
  - **用途**：用于部署和运行 Web 应用程序。

- **Spring MVC 容器**：
  - **功能**：处理 Web 请求和响应，基于 MVC 设计模式。
  - **组件**：DispatcherServlet、Controller、ViewResolver。
  - **用途**：用于构建基于 Spring 框架的 Web 应用程序。

通过理解这三种容器的区别和各自的功能，可以更好地利用它们来构建高效、可扩展的 Java 应用程序。

### 6.说一说什么是 IoC？什么是 DI？

#### 控制反转（Inversion of Control, IoC）

**描述**：控制反转是一种设计原则，用于将对象的创建和依赖关系的管理从应用程序代码中分离出来，交给外部容器（如 Spring 容器）来处理。通过 IoC，应用程序不再负责创建和管理对象，而是由容器来控制对象的生命周期和依赖关系。

**主要思想**：

- **反转控制**：传统的程序设计中，对象是由应用程序代码主动创建和管理的，而在 IoC 中，这种控制权被反转，交给了容器。
- **松耦合**：通过 IoC，可以实现对象之间的松耦合，增强代码的可维护性和可测试性。

**实现方式**：

- **依赖注入（DI）**：IoC 的一种具体实现方式，通过注入依赖对象来实现控制反转。
- **依赖查找（DL）**：另一种实现方式，通过容器提供的查找方法获取依赖对象。

#### 依赖注入（Dependency Injection, DI）

**描述**：依赖注入是实现 IoC 的一种方式，通过将对象的依赖关系注入到对象中，而不是在对象内部创建依赖对象。DI 可以通过构造器注入、Setter 注入和字段注入等方式实现。

**主要方式**：

- **构造器注入**：通过构造器参数注入依赖对象。
- **Setter 注入**：通过 Setter 方法注入依赖对象。
- **字段注入**：通过注解直接注入依赖对象。

**示例**：

**1. 构造器注入：**

```java
public class Service {
    private final Repository repository;

    @Autowired
    public Service(Repository repository) {
        this.repository = repository;
    }
}
```

**2. Setter 注入：**

```java
public class Service {
    private Repository repository;

    @Autowired
    public void setRepository(Repository repository) {
        this.repository = repository;
    }
}
```

**3. 字段注入：**

```java
public class Service {
    @Autowired
    private Repository repository;
}
```

#### IoC 和 DI 的关系

- **IoC 是一种设计原则**：控制反转是一种设计原则，用于将对象的创建和管理交给外部容器。
- **DI 是 IoC 的一种实现方式**：依赖注入是实现控制反转的一种具体方式，通过注入依赖对象来实现对象之间的松耦合。

#### Spring 中的 IoC 和 DI

Spring 框架广泛应用了 IoC 和 DI 原则，通过 Spring 容器来管理对象的创建和依赖关系，实现对象之间的松耦合。

**Spring 容器**：

- **BeanFactory**：最基本的 IoC 容器，提供基本的 DI 功能。
- **ApplicationContext**：扩展了 BeanFactory，提供更多的企业级功能，如事件传播、国际化、应用上下文等。

**Spring 中的 DI**：

- **注解**：如 `@Autowired`、`@Qualifier`、`@Resource` 等。
- **XML 配置**：通过 XML 文件配置依赖关系。
- **Java 配置**：通过 Java 配置类和 `@Bean` 注解配置依赖关系。

**示例**：

```java
@Configuration
public class AppConfig {
    @Bean
    public Repository repository() {
        return new Repository();
    }

    @Bean
    public Service service() {
        return new Service(repository());
    }
}
```

#### 总结-6

- **控制反转（IoC）**：一种设计原则，将对象的创建和管理交给外部容器，实现对象之间的松耦合。
- **依赖注入（DI）**：实现 IoC 的一种方式，通过注入依赖对象来实现控制反转。
  - **构造器注入**：通过构造器参数注入依赖对象。
  - **Setter 注入**：通过 Setter 方法注入依赖对象。
  - **字段注入**：通过注解直接注入依赖对象。

通过理解 IoC 和 DI 的概念及其在 Spring 中的应用，可以更好地利用 Spring 框架提供的功能，编写高质量的代码。

### 7.能简单说一下 Spring IoC 的实现机制吗？

Spring 的 IoC 容器通过依赖注入（DI）来管理对象的创建和依赖关系，实现对象之间的松耦合。以下是 Spring IoC 的实现机制的关键步骤：

#### 1. 配置元数据

Spring IoC 容器需要配置元数据来定义 Bean 及其依赖关系。配置元数据可以通过以下几种方式提供：

- **XML 配置**：在 XML 文件中定义 Bean 和依赖关系。
- **注解**：使用注解（如 `@Component`、`@Autowired` 等）来标记和注入 Bean。
- **Java 配置**：使用 Java 配置类和 `@Bean` 注解来定义 Bean。

#### 2. 解析配置元数据

Spring IoC 容器在启动时会解析配置元数据，构建内部的数据结构来表示 Bean 及其依赖关系。

- **XML 配置解析**：解析 XML 文件中的 `<bean>` 元素。
- **注解解析**：扫描类路径中的注解（如 `@Component`、`@Service` 等）。
- **Java 配置解析**：解析配置类中的 `@Bean` 方法。

#### 3. 创建 Bean 实例

Spring IoC 容器根据解析后的配置元数据创建 Bean 实例。创建 Bean 实例的过程包括以下几个步骤：

- **实例化**：使用*反射*机制调用构造器创建 Bean 实例。
- **依赖注入**：注入 Bean 的依赖对象，可以通过构造器注入、Setter 注入或字段注入实现。
- **初始化**：调用 Bean 的初始化方法（如 `@PostConstruct` 注解的方法或实现 `InitializingBean` 接口的 `afterPropertiesSet` 方法）。

#### 4. 管理 Bean 生命周期

Spring IoC 容器管理 Bean 的整个生命周期，包括创建、初始化、销毁等阶段。

- **单例 Bean**：默认情况下，Spring 容器中的 Bean 是单例的，即每个 Bean 只有一个实例。
- **原型 Bean**：每次请求都会创建一个新的 Bean 实例。
- **自定义 Bean 生命周期**：可以通过实现 `BeanPostProcessor` 接口来自定义 Bean 的初始化和销毁逻辑。

#### 5. 提供 Bean

Spring IoC 容器通过 `BeanFactory` 或 `ApplicationContext` 提供对 Bean 的访问。应用程序可以通过这些接口获取和使用 Bean。

- **BeanFactory**：最基本的 IoC 容器，提供基本的 DI 功能。
- **ApplicationContext**：扩展了 BeanFactory，提供更多的企业级功能，如事件传播、国际化、应用上下文等。

#### XML 配置

```xml
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
                           http://www.springframework.org/schema/beans/spring-beans.xsd">

    <bean id="repository" class="com.example.Repository"/>
    <bean id="service" class="com.example.Service">
        <constructor-arg ref="repository"/>
    </bean>
</beans>
```

#### 注解配置

```java
@Component
public class Repository {
    // Repository implementation
}

@Service
public class Service {
    private final Repository repository;

    @Autowired
    public Service(Repository repository) {
        this.repository = repository;
    }
}
```

#### Java 配置

```java
@Configuration
public class AppConfig {
    @Bean
    public Repository repository() {
        return new Repository();
    }

    @Bean
    public Service service() {
        return new Service(repository());
    }
}
```

#### 总结-7

- **配置元数据**：通过 XML 配置、注解或 Java 配置定义 Bean 和依赖关系。
- **解析配置元数据**：Spring IoC 容器解析配置元数据，构建内部数据结构。
- **创建 Bean 实例**：使用反射机制创建 Bean 实例，并注入依赖对象。
- **管理 Bean 生命周期**：管理 Bean 的创建、初始化和销毁等生命周期阶段。
- **提供 Bean**：通过 `BeanFactory` 或 `ApplicationContext` 提供对 Bean 的访问。

### 8.说说 BeanFactory 和 ApplicantContext?

`BeanFactory` 和 `ApplicationContext` 是 Spring 框架中用于管理 Bean 的两种主要容器接口。它们在功能和使用场景上有所不同。

#### 1. BeanFactory

**描述**：`BeanFactory` 是 Spring 的基础 IoC 容器，提供了基本的依赖注入功能。它是 Spring 容器的核心接口，定义了 Bean 的创建、配置和管理方式。

**主要特点**：

- **延迟加载**：`BeanFactory` 采用延迟加载（Lazy Loading）策略，只有在第一次访问 Bean 时才会创建该 Bean 实例。
- **轻量级**：`BeanFactory` 是一个轻量级容器，适用于资源受限的环境。

**常见实现**：

- **XmlBeanFactory**：从 XML 配置文件中读取 Bean 定义并创建 Bean 实例（已废弃，推荐使用 `ClassPathXmlApplicationContext` 或 `FileSystemXmlApplicationContext`）。

**示例**：

```java
BeanFactory factory = new ClassPathXmlApplicationContext("applicationContext.xml");
MyBean myBean = factory.getBean(MyBean.class);
```

#### 2. ApplicationContext

**描述**：`ApplicationContext` 是 `BeanFactory` 的子接口，扩展了 `BeanFactory` 的功能，提供了更多的企业级特性。它是 Spring 框架中最常用的容器接口。

**主要特点**：

- **立即加载**：`ApplicationContext` 采用立即加载（Eager Loading）策略，在容器启动时就会创建所有单例 Bean 实例。
- **国际化支持**：提供了国际化（i18n）支持，可以方便地处理多语言应用。
- **事件机制**：支持事件发布和监听机制，可以在应用程序中发布和监听事件。
- **AOP 支持**：集成了 Spring AOP，提供了面向切面编程的支持。
- **注解支持**：支持基于注解的配置和依赖注入。

**常见实现**：

- **ClassPathXmlApplicationContext**：从类路径下的 XML 配置文件中读取 Bean 定义并创建 Bean 实例。
- **FileSystemXmlApplicationContext**：从文件系统中的 XML 配置文件中读取 Bean 定义并创建 Bean 实例。
- **AnnotationConfigApplicationContext**：从 Java 配置类中读取 Bean 定义并创建 Bean 实例。

**示例**：

```java
ApplicationContext context = new ClassPathXmlApplicationContext("applicationContext.xml");
MyBean myBean = context.getBean(MyBean.class);
```

#### 主要区别

| 特性                     | BeanFactory                          | ApplicationContext                  |
|--------------------------|--------------------------------------|-------------------------------------|
| **加载策略**             | 延迟加载（Lazy Loading）             | 立即加载（Eager Loading）           |
| **国际化支持**           | 不支持                               | 支持                                |
| **事件机制**             | 不支持                               | 支持                                |
| **AOP 支持**             | 基本支持                             | 完整支持                            |
| **注解支持**             | 基本支持                             | 完整支持                            |
| **使用场景**             | 资源受限的环境                       | 企业级应用程序                      |

#### 总结- 8

- **BeanFactory**：
  - **描述**：Spring 的基础 IoC 容器，提供基本的依赖注入功能。
  - **特点**：延迟加载、轻量级。
  - **使用场景**：资源受限的环境。
  - **示例**：

    ```java
    BeanFactory factory = new ClassPathXmlApplicationContext("applicationContext.xml");
    MyBean myBean = factory.getBean(MyBean.class);
    ```

- **ApplicationContext**：
  - **描述**：`BeanFactory` 的子接口，扩展了更多企业级特性。
  - **特点**：立即加载、国际化支持、事件机制、AOP 支持、注解支持。
  - **使用场景**：企业级应用程序。
  - **示例**：

    ```java
    ApplicationContext context = new ClassPathXmlApplicationContext("applicationContext.xml");
    MyBean myBean = context.getBean(MyBean.class);
    ```

通过理解 `BeanFactory` 和 `ApplicationContext` 的区别和各自的特点，可以更好地选择和使用 Spring 容器来管理应用程序中的 Bean。

### 9.Spring 的 Bean 实例化方式？

Spring 框架提供了多种方式来实例化 Bean，主要包括以下几种：

#### 1. 构造器实例化

**描述**：通过调用类的构造器来创建 Bean 实例。这是最常见的实例化方式。

**配置方式**：

- **XML 配置**：使用 `<constructor-arg>` 元素指定构造器参数。
- **注解配置**：使用 `@Autowired` 注解在构造器上进行自动注入。
- **Java 配置**：在 `@Bean` 方法中直接调用构造器。

**示例**：

- **XML 配置**：

```xml
<bean id="myBean" class="com.example.MyBean">
    <constructor-arg value="constructorArgValue"/>
</bean>
```

- **注解配置**：

```java
@Component
public class MyBean {
    private final String value;

    @Autowired
    public MyBean(@Value("constructorArgValue") String value) {
        this.value = value;
    }
}
```

- **Java 配置**：

```java
@Configuration
public class AppConfig {
    @Bean
    public MyBean myBean() {
        return new MyBean("constructorArgValue");
    }
}
```

#### 2. 静态工厂方法实例化

**描述**：通过调用静态工厂方法来创建 Bean 实例。静态工厂方法是一个静态方法，它返回一个 Bean 实例。

**配置方式**：

- **XML 配置**：使用 `factory-method` 属性指定静态工厂方法。
- **Java 配置**：在 `@Bean` 方法中调用静态工厂方法。

**示例**：

- **XML 配置**：

```xml
<bean id="myBean" class="com.example.MyBeanFactory" factory-method="createInstance"/>
```

- **Java 配置**：

```java
@Configuration
public class AppConfig {
    @Bean
    public MyBean myBean() {
        return MyBeanFactory.createInstance();
    }
}
```

#### 3. 实例工厂方法实例化

**描述**：通过调用实例工厂方法来创建 Bean 实例。实例工厂方法是一个实例方法，它返回一个 Bean 实例。

**配置方式**：

- **XML 配置**：使用 `factory-bean` 和 `factory-method` 属性指定实例工厂和工厂方法。
- **Java 配置**：在 `@Bean` 方法中调用实例工厂方法。

**示例**：

- **XML 配置**：

```xml
<bean id="myBeanFactory" class="com.example.MyBeanFactory"/>
<bean id="myBean" factory-bean="myBeanFactory" factory-method="createInstance"/>
```

- **Java 配置**：

```java
@Configuration
public class AppConfig {
    @Bean
    public MyBeanFactory myBeanFactory() {
        return new MyBeanFactory();
    }

    @Bean
    public MyBean myBean() {
        return myBeanFactory().createInstance();
    }
}
```

#### 总结-9

Spring 提供了多种方式来实例化 Bean，主要包括：

1. **构造器实例化**：通过调用类的构造器来创建 Bean 实例。
   - **XML 配置**：使用 `<constructor-arg>` 元素。
   - **注解配置**：使用 `@Autowired` 注解在构造器上。
   - **Java 配置**：在 `@Bean` 方法中直接调用构造器。

2. **静态工厂方法实例化**：通过调用静态工厂方法来创建 Bean 实例。
   - **XML 配置**：使用 `factory-method` 属性。
   - **Java 配置**：在 `@Bean` 方法中调用静态工厂方法。

3. **实例工厂方法实例化**：通过调用实例工厂方法来创建 Bean 实例。
   - **XML 配置**：使用 `factory-bean` 和 `factory-method` 属性。
   - **Java 配置**：在 `@Bean` 方法中调用实例工厂方法。

### 10.能说一下 Spring Bean 生命周期吗？

Spring 中 Bean 的生命周期大致分为四个阶段：实例化（Instantiation）、属性赋值（Populate）、初始化（Initialization）、销毁（Destruction）。

实例化：Spring 容器根据 Bean 的定义创建 Bean 的实例，相当于执行构造方法，也就是 new 一个对象。

属性赋值：相当于执行 setter 方法为字段赋值。

初始化：初始化阶段允许执行自定义的逻辑，比如设置某些必要的属性值、开启资源、执行预加载操作等，以确保 Bean 在使用之前是完全配置好的。

销毁：相当于执行 = null，释放资源。

### 11.Bean 定义和依赖定义有哪些方式？

有三种方式：直接编码方式、配置文件方式、注解方式。

- 直接编码方式：我们一般接触不到直接编码的方式，但其实其它的方式最终都要通过直接编码来实现。
- 配置文件方式：通过 xml、propreties 类型的配置文件，配置相应的依赖关系，Spring 读取配置文件，完成依赖关系的注入。
- 注解方式：注解方式应该是我们用的最多的一种方式了，在相应的地方使用注解修饰，Spring 会扫描注解，完成依赖关系的注入。

### 12.Spring 有哪些自动装配的方式？

Spring IoC 容器知道所有 Bean 的配置信息，此外，通过 Java 反射机制还可以获知实现类的结构信息，如构造方法的结构、属性等信息。掌握所有 Bean 的这些信息后，Spring IoC 容器就可以按照某种规则对容器中的 Bean 进行自动装配，而无须通过显式的方式进行依赖配置。

Spring 提供的这种方式，可以按照某些规则进行 Bean 的自动装配，`<bean>`元素提供了一个指定自动装配类型的属性：`autowire="<自动装配类型>"`

- **byName**：根据名称进行自动匹配，假设 Boss 又一个名为 car 的属性，如果容器中刚好有一个名为 car 的 bean，Spring 就会自动将其装配给 Boss 的 car 属性
- **byType**：根据类型进行自动匹配，假设 Boss 有一个 Car 类型的属性，如果容器中刚好有一个 Car 类型的 Bean，Spring 就会自动将其装配给 Boss 这个属性
- **constructor**：与 byType 类似， 只不过它是针对构造函数注入而言的。如果 Boss 有一个构造函数，构造函数包含一个 Car 类型的入参，如果容器中有一个 Car 类型的 Bean，则 Spring 将自动把这个 Bean 作为 Boss 构造函数的入参；如果容器中没有找到和构造函数入参匹配类型的 Bean，则 Spring 将抛出异常。
- **autodetect**：根据 Bean 的自省机制决定采用 byType 还是 constructor 进行自动装配，如果 Bean 提供了默认的构造函数，则采用 byType，否则采用 constructor。

### 13.Spring 中的 Bean 的作用域有哪些?

Spring 的 Bean 主要支持五种作用域：

- **singleton** : 在 Spring 容器仅存在一个 Bean 实例，Bean 以单实例的方式存在，是 Bean 默认的作用域。
- **prototype** : 每次从容器重调用 Bean 时，都会返回一个新的实例。

以下三个作用域于只在 Web 应用中适用：

- **request** : 每一次 HTTP 请求都会产生一个新的 Bean，该 Bean 仅在当前 HTTP Request 内有效。
- **session** : 同一个 HTTP Session 共享一个 Bean，不同的 HTTP Session 使用不同的 Bean。
- **globalSession**：同一个全局 Session 共享一个 Bean，只用于基于 Protlet 的 Web 应用，Spring5 中已经不存在了。

### 14.Spring 中的单例 Bean 会存在线程安全问题吗？

是的，Spring 中的单例（Singleton）Bean 可能会存在线程安全问题。

#### 单例 Bean 的线程安全问题

**描述**：在 Spring 中，单例作用域（Singleton Scope）意味着在整个 Spring 容器中只有一个 Bean 实例。这个实例会被多个线程共享使用。如果这个单例 Bean 中包含了可变状态（即成员变量可以被修改），并且这些状态在多个线程之间共享，那么就可能会出现线程安全问题。

#### 线程安全问题的示例

假设有一个单例 Bean `Counter`，它包含一个可变的计数器变量：

```java
@Component
public class Counter {
    private int count = 0;

    public void increment() {
        count++;
    }

    public int getCount() {
        return count;
    }
}
```

在多线程环境中，如果多个线程同时调用 `increment` 方法，由于 `count` 变量的读写操作不是原子的，可能会导致计数器的值不正确。

#### 解决线程安全问题的方法

**1. 无状态 Bean**：尽量设计无状态的 Bean，即不包含可变的成员变量。无状态的 Bean 是线程安全的，因为它们不在多个线程之间共享状态。

**2. 局部变量**：将可变状态限制在方法内部，使用局部变量而不是成员变量。局部变量是线程安全的，因为它们是线程私有的。

**3. 同步**：对共享的可变状态进行同步，确保同一时刻只有一个线程可以访问该状态。

```java
@Component
public class Counter {
    private int count = 0;

    public synchronized void increment() {
        count++;
    }

    public synchronized int getCount() {
        return count;
    }
}
```

**4. 使用线程安全的数据结构**：使用 Java 提供的线程安全的数据结构，如 `AtomicInteger`、`ConcurrentHashMap` 等。

```java
@Component
public class Counter {
    private AtomicInteger count = new AtomicInteger(0);

    public void increment() {
        count.incrementAndGet();
    }

    public int getCount() {
        return count.get();
    }
}
```

**5. 作用域调整**：如果 Bean 的状态必须是可变的，并且需要在不同线程之间共享，可以考虑将 Bean 的作用域调整为 `prototype`，这样每次请求都会创建一个新的 Bean 实例。

```java
@Component
@Scope("prototype")
public class Counter {
    private int count = 0;

    public void increment() {
        count++;
    }

    public int getCount() {
        return count;
    }
}
```

**6.将 Bean 中的成员变量保存到 ThreadLocal 中**:ThreadLocal 可以保证多线程环境下变量的隔离。

```java
public class MyService {
    private ThreadLocal<Integer> localVar = ThreadLocal.withInitial(() -> 0);

    public void process() {
        localVar.set(localVar.get() + 1);
    }
}
```

#### 总结- 14

Spring 中的单例（Singleton）Bean 可能会存在线程安全问题，特别是当 Bean 包含可变状态时。在多线程环境中，多个线程共享同一个单例 Bean 实例，可能会导致数据不一致或其他并发问题。

解决线程安全问题的方法包括：

1. 设计无状态的 Bean。
2. 使用局部变量而不是成员变量。
3. 对共享的可变状态进行同步。
4. 使用线程安全的数据结构。
5. 将 Bean 的作用域调整为 `prototype`。
6. 将 Bean 中的成员变量保存到 ThreadLocal 中

通过理解和应用这些方法，可以有效地避免单例 Bean 的线程安全问题，确保应用程序的正确性和稳定性。

### 15.循环依赖问题

循环依赖（Circular Dependency）是指两个或多个 Bean 互相依赖，形成一个闭环。例如，Bean A 依赖于 Bean B，而 Bean B 又依赖于 Bean A。这种依赖关系会导致在创建 Bean 实例时出现问题，因为 Spring 容器无法确定哪个 Bean 应该先创建。

循环依赖只发生在 Singleton 作用域的 Bean 之间，因为如果是 Prototype 作用域的 Bean，Spring 会直接抛出异常。

原因很简单，AB 循环依赖，A 实例化的时候，发现依赖 B，创建 B 实例，创建 B 的时候发现需要 A，创建 A1 实例……无限套娃。

#### Spring 可以解决哪些情况的循环依赖？

- AB 均采用构造器注入，不支持
- AB 均采用 setter 注入，支持
- AB 均采用属性自动注入，支持
- A 中注入的 B 为 setter 注入，B 中注入的 A 为构造器注入，支持
- B 中注入的 A 为 setter 注入，A 中注入的 B 为构造器注入，不支持

第四种可以，第五种不可以的原因是 Spring 在创建 Bean 时默认会根据自然排序进行创建，所以 A 会先于 B 进行创建。

当循环依赖的实例都采用 setter 方法注入时，Spring 支持，都采用构造器注入的时候，不支持。

#### Spring 怎么解决循环依赖的呢？

Spring 通过三级缓存（Three-Level Cache）机制来解决循环依赖。

- 一级缓存：用于存放完全初始化好的单例 Bean。
- 二级缓存：用于存放正在创建但未完全初始化的 Bean 实例。
- 三级缓存：用于存放 Bean 工厂对象，用于提前暴露 Bean。

三级缓存解决循环依赖的过程是什么样的？

A 实例的初始化过程：

①、创建 A 实例，实例化的时候把 A 的对象⼯⼚放⼊三级缓存，表示 A 开始实例化了，虽然这个对象还不完整，但是先曝光出来让大家知道。

②、A 注⼊属性时，发现依赖 B，此时 B 还没有被创建出来，所以去实例化 B。

③、同样，B 注⼊属性时发现依赖 A，它就从缓存里找 A 对象。依次从⼀级到三级缓存查询 A。

发现可以从三级缓存中通过对象⼯⼚拿到 A，虽然 A 不太完善，但是存在，就把 A 放⼊⼆级缓存，同时删除三级缓存中的 A，此时，B 已经实例化并且初始化完成了，把 B 放入⼀级缓存。

④、接着 A 继续属性赋值，顺利从⼀级缓存拿到实例化且初始化完成的 B 对象，A 对象创建也完成，删除⼆级缓存中的 A，同时把 A 放⼊⼀级缓存

⑤、最后，⼀级缓存中保存着实例化、初始化都完成的 A、B 对象。

#### 为什么要三级缓存？二级不行吗？

代理对象的提前暴露

在某些情况下，Spring 需要为 Bean 创建代理对象（例如，AOP 切面）。如果仅使用二级缓存，Spring 无法在 Bean 实例化的早期阶段创建代理对象并将其暴露出来。而三级缓存允许 Spring 在 Bean 实例化的早期阶段通过 Bean 工厂对象创建代理对象，并将其暴露出来，从而解决代理对象的提前暴露问题。

三级缓存中放的是⽣成具体对象的匿名内部类，获取 Object 的时候，它可以⽣成代理对象，也可以返回普通对象。使⽤三级缓存主要是为了保证不管什么时候使⽤的都是⼀个对象。

假设只有二级缓存的情况，往二级缓存中放的显示⼀个普通的 Bean 对象，Bean 初始化过程中，通过 BeanPostProcessor 去⽣成代理对象之后，覆盖掉二级缓存中的普通 Bean 对象，那么可能就导致取到的 Bean 对象不一致了。

### 16.@Autowired 的实现原理？

实现@Autowired 的关键是：AutowiredAnnotationBeanPostProcessor

在 Bean 的初始化阶段，会通过 Bean 后置处理器来进行一些前置和后置的处理。

实现@Autowired 的功能，也是通过后置处理器来完成的。这个后置处理器就是 AutowiredAnnotationBeanPostProcessor。

Spring 在创建 bean 的过程中，最终会调用到 doCreateBean()方法，在 doCreateBean()方法中会调用 populateBean()方法，来为 bean 进行属性填充，完成自动装配等工作。

在 populateBean()方法中一共调用了两次后置处理器，第一次是为了判断是否需要属性填充，如果不需要进行属性填充，那么就会直接进行 return，如果需要进行属性填充，那么方法就会继续向下执行，后面会进行第二次后置处理器的调用，这个时候，就会调用到 AutowiredAnnotationBeanPostProcessor 的 postProcessPropertyValues()方法，在该方法中就会进行@Autowired 注解的解析，然后实现自动装配。

```java
/**
* 属性赋值
**/
protected void populateBean(String beanName, RootBeanDefinition mbd, @Nullable BeanWrapper bw) {
          //…………
          if (hasInstAwareBpps) {
              if (pvs == null) {
                  pvs = mbd.getPropertyValues();
              }

              PropertyValues pvsToUse;
              for(Iterator var9 = this.getBeanPostProcessorCache().instantiationAware.iterator(); var9.hasNext(); pvs = pvsToUse) {
                  InstantiationAwareBeanPostProcessor bp = (InstantiationAwareBeanPostProcessor)var9.next();
                  pvsToUse = bp.postProcessProperties((PropertyValues)pvs, bw.getWrappedInstance(), beanName);
                  if (pvsToUse == null) {
                      if (filteredPds == null) {
                          filteredPds = this.filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);
                      }
                      //执行后处理器，填充属性，完成自动装配
                      //调用InstantiationAwareBeanPostProcessor的postProcessPropertyValues()方法
                      pvsToUse = bp.postProcessPropertyValues((PropertyValues)pvs, filteredPds, bw.getWrappedInstance(), beanName);
                      if (pvsToUse == null) {
                          return;
                      }
                  }
              }
          }
         //…………
  }
```

postProcessorPropertyValues()方法的源码如下，在该方法中，会先调用 findAutowiringMetadata()方法解析出 bean 中带有@Autowired 注解、@Inject 和@Value 注解的属性和方法。然后调用 metadata.inject()方法，进行属性填充。

```java
  public PropertyValues postProcessProperties(PropertyValues pvs, Object bean, String beanName) {
      //@Autowired注解、@Inject和@Value注解的属性和方法
      InjectionMetadata metadata = this.findAutowiringMetadata(beanName, bean.getClass(), pvs);

      try {
          //属性填充
          metadata.inject(bean, beanName, pvs);
          return pvs;
      } catch (BeanCreationException var6) {
          throw var6;
      } catch (Throwable var7) {
          throw new BeanCreationException(beanName, "Injection of autowired dependencies failed", var7);
      }
  }
```

### 17.说说什么是 AOP？

AOP（Aspect-Oriented Programming，面向切面编程）是一种编程范式，旨在通过分离横切关注点（cross-cutting concerns）来提高代码的模块化。横切关注点是指那些在多个模块中都会涉及的功能，例如日志记录、安全检查、事务管理等。AOP 通过将这些横切关注点从业务逻辑中分离出来，使代码更加清晰、可维护。

#### AOP 的核心概念

1. **切面（Aspect）**：
   - 切面是横切关注点的模块化实现。它可以包含多个通知（advice）和切点（pointcut）。
   - 例如，一个日志切面可以包含记录方法调用的通知。

2. **通知（Advice）**：
   - 通知是切面中的具体动作，它定义了在切点处执行的代码。
   - 通知类型包括前置通知（Before）、后置通知（After）、返回通知（AfterReturning）、异常通知（AfterThrowing）和环绕通知（Around）。

3. **切点（Pointcut）**：
   - 切点定义了在哪些连接点（Join Point）上执行通知。它通过表达式来匹配连接点。
   - 例如，可以定义一个切点匹配所有以 `get` 开头的方法。

4. **连接点（Join Point）**：
   - 连接点是程序执行中的一个特定点，例如方法调用或异常抛出。
   - 在 Spring AOP 中，连接点主要是方法调用。

5. **目标对象（Target Object）**：
   - 目标对象是被一个或多个切面增强的对象。也称为被代理对象（proxied object）。

6. **代理（Proxy）**：
   - 代理是 AOP 框架创建的对象，用于实现切面功能。代理对象包含目标对象的所有方法，并在适当的时候调用通知。
   - Spring AOP 使用 JDK 动态代理或 CGLIB 代理来创建代理对象。

7. **织入（Weaving）**：
   - 织入是将切面应用到目标对象并创建代理对象的过程。织入可以在编译时、类加载时或运行时进行。
   - Spring AOP 主要在运行时进行织入。

#### 织入有哪几种方式？

①、编译期织入：切面在目标类编译时被织入。

②、类加载期织入：切面在目标类加载到 JVM 时被织入。需要特殊的类加载器，它可以在目标类被引入应用之前增强该目标类的字节码。

③、运行期织入：切面在应用运行的某个时刻被织入。一般情况下，在织入切面时，AOP 容器会为目标对象动态地创建一个代理对象。

Spring AOP 采用运行期织入，而 AspectJ 可以在编译期织入和类加载时织入。

#### AspectJ是什么？

AspectJ 是一个 AOP 框架，它可以做很多 Spring AOP 干不了的事情，比如说支持编译时、编译后和类加载时织入切面。并且提供更复杂的切点表达式和通知类型。

#### AOP有几种环绕方式？

AOP 一般有 5 种环绕方式：

**前置环绕**（Before）：

在目标方法执行之前执行自定义逻辑。

**后置环绕**（After）：

在目标方法执行之后执行自定义逻辑。

**返回环绕**（AfterReturning）：

在目标方法成功返回之后执行自定义逻辑，可以修改返回值。

**异常环绕**（AfterThrowing）：

在目标方法抛出异常之后执行自定义逻辑，可以处理或修改异常。

**完整环绕**（Around）：

在目标方法执行之前和之后都执行自定义逻辑，可以完全控制目标方法的执行。

#### Spring AOP 示例

以下是一个简单的 Spring AOP 示例，展示了如何使用 AOP 来记录方法调用的日志。

**定义切面**：

```java
@Aspect
@Component
public class LoggingAspect {

    @Before("execution(* com.example.service.*.*(..))")
    public void logBeforeMethod(JoinPoint joinPoint) {
        System.out.println("Before method: " + joinPoint.getSignature().getName());
    }

    @After("execution(* com.example.service.*.*(..))")
    public void logAfterMethod(JoinPoint joinPoint) {
        System.out.println("After method: " + joinPoint.getSignature().getName());
    }
}
```

**配置 AOP**：

```java
@Configuration
@EnableAspectJAutoProxy
public class AppConfig {
    // 配置类，启用 AOP 支持
}
```

**目标对象**：

```java
@Service
public class MyService {
    public void performTask() {
        System.out.println("Performing task");
    }
}
```

**使用目标对象**：

```java
public class Main {
    public static void main(String[] args) {
        ApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class);
        MyService myService = context.getBean(MyService.class);
        myService.performTask();
    }
}
```

#### 总结- 17

AOP，也就是面向切面编程，是一种编程范式，旨在提高代码的模块化。比如说可以将日志记录、事务管理等分离出来，来提高代码的可重用性。

AOP 的核心概念包括切面（Aspect）、连接点（Join Point）、通知（Advice）、切点（Pointcut）和织入（Weaving）等。

① 像日志打印、事务管理等都可以抽离为切面，可以声明在类的方法上。像 @Transactional 注解，就是一个典型的 AOP 应用，它就是通过 AOP 来实现事务管理的。我们只需要在方法上添加 @Transactional 注解，Spring 就会在方法执行前后添加事务管理的逻辑。

② Spring AOP 是基于代理的，它默认使用 JDK 动态代理和 CGLIB 代理来实现 AOP。

③ Spring AOP 的织入方式是运行时织入，而 AspectJ 支持编译时织入、类加载时织入。

### 18.说说 JDK 动态代理和 CGLIB 代理？

在 Spring AOP 中，代理是实现切面功能的核心机制。Spring AOP 主要使用两种代理方式：JDK 动态代理和 CGLIB 代理。以下是这两种代理方式的详细介绍：

#### JDK 动态代理

**描述**：JDK 动态代理是基于 Java 反射机制的一种代理方式，*它只能代理实现了接口的类。*

**特点**：

- **接口代理**：JDK 动态代理只能代理实现了接口的类。
- **运行时生成**：代理类在运行时动态生成，而不是在编译时生成。
- **性能**：由于使用了反射机制，性能相对较低，但在大多数情况下是可以接受的。

**示例**：

```java
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;

public class JdkDynamicProxyExample {
    public static void main(String[] args) {
        // 创建目标对象
        MyService target = new MyServiceImpl();

        // 创建代理对象
        MyService proxy = (MyService) Proxy.newProxyInstance(
                target.getClass().getClassLoader(),
                target.getClass().getInterfaces(),
                new MyInvocationHandler(target)
        );

        // 调用代理对象的方法
        proxy.performTask();
    }
}

interface MyService {
    void performTask();
}

class MyServiceImpl implements MyService {
    @Override
    public void performTask() {
        System.out.println("Performing task");
    }
}

class MyInvocationHandler implements InvocationHandler {
    private final Object target;

    public MyInvocationHandler(Object target) {
        this.target = target;
    }

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        System.out.println("Before method: " + method.getName());
        Object result = method.invoke(target, args);
        System.out.println("After method: " + method.getName());
        return result;
    }
}
```

#### CGLIB 代理

**描述**：CGLIB（Code Generation Library）代理是基于字节码生成的一种代理方式，它可以代理没有实现接口的类。

**特点**：

- **子类代理**：CGLIB 代理通过生成目标类的子类来实现代理，因此可以代理没有实现接口的类。
- **运行时生成**：代理类在运行时动态生成，而不是在编译时生成。
- **性能**：由于直接操作字节码，性能比 JDK 动态代理高。

**示例**：

```java
import net.sf.cglib.proxy.Enhancer;
import net.sf.cglib.proxy.MethodInterceptor;
import net.sf.cglib.proxy.MethodProxy;

import java.lang.reflect.Method;

public class CglibProxyExample {
    public static void main(String[] args) {
        // 创建目标对象
        MyService target = new MyService();

        // 创建代理对象
        MyService proxy = (MyService) Enhancer.create(
                target.getClass(),
                new MyMethodInterceptor(target)
        );

        // 调用代理对象的方法
        proxy.performTask();
    }
}

class MyService {
    public void performTask() {
        System.out.println("Performing task");
    }
}

class MyMethodInterceptor implements MethodInterceptor {
    private final Object target;

    public MyMethodInterceptor(Object target) {
        this.target = target;
    }

    @Override
    public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {
        System.out.println("Before method: " + method.getName());
        Object result = proxy.invoke(target, args);
        System.out.println("After method: " + method.getName());
        return result;
    }
}
```

#### Spring AOP 中的代理选择

Spring AOP 默认会根据目标类是否实现了接口来选择代理方式：

- **JDK 动态代理**：如果目标类实现了接口，Spring AOP 会使用 JDK 动态代理。
- **CGLIB 代理**：如果目标类没有实现接口，Spring AOP 会使用 CGLIB 代理。

你也可以通过配置强制使用 CGLIB 代理：

```java
@Configuration
@EnableAspectJAutoProxy(proxyTargetClass = true)
public class AppConfig {
    // 配置类，启用 AOP 支持，并强制使用 CGLIB 代理
}
```

#### 总结- 18

在 Spring AOP 中，代理是实现切面功能的核心机制。Spring AOP 主要使用两种代理方式：

1. **JDK 动态代理**：
   - 基于 Java 反射机制。
   - 只能代理实现了接口的类。
   - 代理类在运行时动态生成。
   - 性能相对较低，但在大多数情况下是可以接受的。

2. **CGLIB 代理**：
   - 基于字节码生成。
   - 可以代理没有实现接口的类。
   - 代理类在运行时动态生成。
   - 性能比 JDK 动态代理高。

通过理解这两种代理方式的特点和使用场景，可以更好地选择和使用 Spring AOP 提供的代理机制，提高代码的模块化和可维护性。

### 19.说说 Spring AOP 和 AspectJ AOP 区别?

**Spring AOP**  

Spring AOP 属于运行时增强，主要具有如下特点：

基于*动态代理*来实现，默认如果使用接口的，用 JDK 提供的动态代理实现，如果是方法则使用 CGLIB 实现

Spring AOP 需要依赖 IoC 容器来管理，并且只能作用于 Spring 容器，使用纯 Java 代码实现

在性能上，由于 Spring AOP 是基于动态代理来实现的，在容器启动时需要生成代理实例，在方法调用上也会增加栈的深度，使得 Spring AOP 的性能不如 AspectJ 的那么好。

Spring AOP 致力于解决企业级开发中最普遍的 AOP(方法织入)。

**AspectJ**  

AspectJ 是一个易用的功能强大的 AOP 框架，属于编译时增强， 可以单独使用，也可以整合到其它框架中，是 AOP 编程的完全解决方案。AspectJ 需要用到单独的编译器 ajc。

AspectJ 属于*静态织入*，通过修改代码来实现，在实际运行之前就完成了织入，所以说它生成的类是没有额外运行时开销的，一般有如下几个织入的时机：

编译期织入（Compile-time weaving）：如类 A 使用 AspectJ 添加了一个属性，类 B 引用了它，这个场景就需要编译期的时候就进行织入，否则没法编译类 B。

编译后织入（Post-compile weaving）：也就是已经生成了 .class 文件，或已经打成 jar 包了，这种情况我们需要增强处理的话，就要用到编译后织入。

类加载后织入（Load-time weaving）：指的是在加载类的时候进行织入，要实现这个时期的织入，有几种常见的方法
